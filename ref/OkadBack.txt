( -*- mode: aforth -*- )
( block 18 )
:var ns [0x202] :var nblk [0x5a0] :var nc [0xf] ( 144a12 01g 42c/01w/22a copyright 2009-2011 greenarrays,inc) 20 load 22 load 24 load ( colors) 28 load 
: abuf  10000  ;
: cbuf  29000  ; ( decompress) mark 30 load restore empt 
: env  34  winver 2* + ; env ( ironment) load 44 2 loads 62 5 loads 88 load 84 load
: floppy  52  ;
: dump  48  load ;
: flush save ;
: icons  54  ;
: audit  90  ;
: index  76  ;
: html  176  ; mark empty ( arrayforth) 144 load qwerty seeb ( application tools) 202 2 loads mark empty exit ( or compile any following...)
: q ( 706 )  660  load ; mark empty

( block 19 )
( x86 colorforth and arrayforth tm)
: ns ( number of sectors compressed if neg,)
( last compressed if pos.)
: nblk ( number of uncompressed blocks.)
: nc ( no. of compressed cylinders, deprecated)
 these vars must be first things in block!


: abuf ( starting block of) ( 3 ) ( mb audit buffer)
: cbuf ( starting block of) ( 3 ) ( mb compression buffer)
: floppy ( utilities for floppy format and ops.)
: dump ( compile memory display background task)
: flush ( eases concurrent use of pf/ef.)
: icons ( compile icon editor)
: audit ( utility for reconciliation and merging)
: index ( file listing first lines of blocks)
: html ( colorforth source to 2-up html file) ( saying)  qwerty  enables ( the qwerty keyboard mode till next boot.)
 seeb ( toggles blue word display)  on.

( block 20 )
( macros) macro 
: swap 0x168b 2, 0xc28b0689 , ;
: 0 [compile] ?dup 0xc031 2, ; : if 0x74 2, here ;
: -if 0x79 2, here ; : while ( n-nn) [compile] if swap ;
: -while ( n-nn) [compile] -if swap ; : a [compile] ?dup 0xc28b 2, ;
: a! ?lit if 0xba 1, , ;  then 0xd08b 2, [compile] drop ;
: 2* 0xe0d1 2, ;
: 4@ ( b-n) 0x8b 2, ; forth 
: a, 2* 2* , ; macro 
: @ ?lit if [compile] ?dup 0x58b 2, a, ;  then 0x85048b 3, $ 0 , ;
: ! ?lit if ?lit if 0x5c7 2, swap a, , ;  then 0x589 2, a, [compile] drop ;  then [compile] a! 0x950489 3, $ 0 , [compile] drop ;
: nip 0x4768d 3, ;
: + ?lit if 0x5 1, , ;  then 0x603 2, [compile] nip ;
: or 0x633
: binary ?lit if swap 2 + 1, , ;  then 2, [compile] nip ;
: and 0x623 [compile] binary ; : +or 0x60b [compile] binary ;
: u+ ?lit if 0x681 2, , ;  then 0x44601 3, [compile] drop ;
: ? ?lit 0xa9 1, , ; : over [compile] ?dup 0x4468b 3, ;

( block 21 )
( pentium macros' 1, 2, 3, , compile 1-4 bytes)
: drop ( lodsd, flags unchanged, why sp is in esi - in kernel)
: then ( fix address - in kernel)
: swap ( sp xchg)
: 0 ( 0 0 xor, macro 0 identical to number 0)
: if ( jz, flags set, max 127 bytes, leave address)
: -if ( jns, same)
: a ( 2 0 mov, never used?)
: a! ( 0 2 mov, unoptimized)
: 2* ( shift left)
: 4@ ( fetch word on byte boundary.)
: a, ( compile word address)
: @/! ( fetch/store from/to word address, or eax)
: nip swap drop
: +/or/and ( number or sp with eax)
: u+ ( add to 2nd number, number or sp)
: ? ( test bits, set flags, literal only!)
: over ( sp 4 + @)

( block 22 )
( - macros)
: push ?lit if 0x68 1, , ;  then 0x50 1, [compile] drop ;
: pop [compile] ?dup 0x58 1, ;
: - 0xd0f7 2, ;
: *end swap
: end 0xeb
: loop 1, here - + 1, ;
: until 0x74 [compile] loop ;
: -until 0x79 [compile] loop ;
: for [compile] push [compile] begin ;
: *next swap
: next 0x75240cff
: 0next , here - + 1, 0x4c483 3, ;
: -next 0x79240cff [compile] 0next ;
: i [compile] ?dup 0x24048b 3, ;
: +! ?lit if ?lit if 0x581 2, swap a, , ;  then 0x501 2, a, [compile] drop ;  then [compile] a! 0x950401 3, $ 0 , [compile] drop ;
: nop 0x90 1, ;
: align here - 3 and drop if [compile] nop [compile] align ;  then ;
: or! [compile] a! 0x950409 3, $ 0 , [compile] drop ;
: * 0x6af0f 3, [compile] nip ;
: */ 0xc88b 2, [compile] drop 0xf9f72ef7 , [compile] nip ;
: /mod [compile] swap 0x99 1, 0x16893ef7 , ;
: / [compile] /mod [compile] nip ;
: mod [compile] /mod [compile] drop ;

( block 23 )

: push ( lit to sp; eax to sp)
: pop ( sp to eax)
: - ( ones-complement)
: begin -a ( current code address - byte)
: while a-aa ( if-escape from any structure usage example begin xxx while xxx next xxx then)
: for n ( push count onto return stack,) begin
: *next aa-aa ( swap) for ( and) if ( addresses)
: next a ( decrement count, jnz to) for, ( pop return stack when done)
: -next a ( same, jns - loop includes 0)
: i -n ( copy loop index to data stack)
: *end aa-aa ( swap) end ( and) if ( addresses)
: end a ( jmp to) begin
: +! na ( add to memory, 2 literals optimized)
: align ( next call to end on word boundary)
: or! na ( inclusive-or to memory, unoptimized)
: * mm-p ( 32-bit product)
: */ mnd-q ( 64-bit product, then quotient)
: /mod nd-rq ( remainder and quotient)
: / nd-q ( quotient)
: mod nd-r ( remainder)

( block 24 )
( - compiled macros)
: 2/ ( n-n) 0xf8d1 2, ; : time ( -n) [compile] ?dup 0x310f 2, ;
: 7push 0x57 1, ; : 7pop 0x5f 1, ; forth 
: @ @ ; : ! ! ; : + + ; : - - ;
: */ */ ; : * * ; : / / ; : 2/ 2/ ;
: dup dup ; : drop drop ; : nip ( ab-b) nip ;
: over over ; : swap swap ; : and and ;
: or or ; : +or +or ; : +! +! ;
: exit 7pop 7pop ; : negate ( n-n) - 1 + ;
: min ( nn-n) less if drop ;  then swap drop ;
: abs ( n-u) dup negate
: max ( nn-n) less if swap then drop ;
: v+ ( vv-v) push u+ pop + ;
: loads ( bn) for dup push load pop 2 + next drop ;
: writes ( acn) for write next drop drop ;
: reads ( acn) for read next drop drop ; macro 
: dann [compile] then ;
: then ( a-a) here over negate + 128 +
-256 and drop if abort dann [compile] dann ; forth

( block 25 )

: 2/ ( arithmetic right shift)
: time ( pentium cycle counter, calibrate to actual clock rate)
: 7push/7pop ( save/restore save register 7, edi)
: @-drop ( these macros redefined in) forth ( so they may be executed)
: +or ( and) negate ( when you just can't use -)
: min ( and) max ( minimum and maximum)
: abs ( absolute value)
: v+ ( add 2-vectors)
: exit ( terminates interpretation of a block.)
: loads ( load successive blocks)
: nc ( number of cylinders booted and saved)
: writes ( address, cylinder, cylinder count)
: reads ( address, cylinder, count.)  floppy access note do not hit any keys while floppy is being written - wait for light to go out 
: then ( aborts on jump out of range.)

( block 26 )


( block 27 )


( block 28 )
( colors etc)
: -offset ( n-n)  offset  @ negate + ;
: block  offset  @ +
: blks 0x100 * ;
: wrtboot  0 block  0 1 writes stop ;
: white 0xffffff color ;
: red 0xff0000 color ;
: green 0xff00 color ;
: blue 0xff color ;
: silver 0xbfbfbf color ;
: black 0 color ;
: 5* 5 for 2emit next ;
: cf 25 dup at red 0xb 0x5 0x1 0x1 0x5 5* green 0x14 0x2 0x1 0x3 0xe 5* ( chip) 25 550 at red 0x1c 0x1c 0x19 0x5 0xd 5* ;
: fill ( nan) for over over ! 1 + next drop drop ;
: move ( sdn) for over @ over ! 1 + 1 u+ next drop drop ;
: erase ( bn) push 0 swap block pop blks fill ;
: copy ( n)  blk  @ block over block 512 move  blk  ! ;

( block 29 )

: block n-a ( block number to word address)
: wrtboot ( write boot and kernel)
: colors ( specified as rgb' 888 bits)
: at xy ( set current screen position - in kernel)
: box xy ( lower-right of colored rectangle - in kernel)
: 5* emit ( five characters in reverse order)
: cf ( display double-size colorforth)
: fill n an ( writes n into a cell string)
: move sdn ( copies a cell string from s to d)
: erase bn ( zeroes a string of blocks)
: copy n ( copies current editor block and its shadow to the given block)

( block 30 )
( decompress) empt 32 load 
: char ( -n) $ 0 b! ( ?new) 4 bits b 8 and drop if b 4 and drop if 3 bits 7 ;  then 1 bits 5 ;  then 4 b 0xf and drop if ;  then
: eob ( n) drop pop drop ;
: chars ( n-n) char ?full c! 2*c b or chars ;
: word ( n) 28  nb  ! dup chars tbits ;
: short ( n) 28 bits
: t, -4  nb  ! b tbits ;
: number ( n) $ 0 b! 1 bits t,
: 32bits 16 bits 16 bits b , ;
: variable ( n) word 32bits ;
: tag ( -n) b 0xf and dup jump eob word number word word number short word short word word word variable short word short
: words ( ?new) 4 bits tag words ;
: range ( ann) over block  h  ! dup push erase  aa  ! $ 0  na  ! begin words  h  @ 256 + -256 and  h  ! next ;
: restore  ns  @ dup and -if abs  ns  ! 36 block  cbuf  block  18 blks nc @ -2 + *  move  cbuf block  36  nblk @ -36 +  range ;  then drop ;

( block 31 )

: char ( examine high bits; shift 4, 5 or 7 bits)
: eob ( end of block)
: chars ( shift characters until 0)
: word ( shift characters, then tag)
: short ( 28-bit value+tag)
: number ( 1-bit base+tag, value in next word)
: 32bits ( for values)
: variable ( word, value)
: tag ( vector)
: words ( examine tags)
: range ( process each block)
: move ( blocks 72 thru 1419 to 3000)
: res ( restore compressed blocks)

( block 32 )
( - more) macro ( uses ebx)
: b [compile] ?dup 0xc38b 2, ;
: b! 0xd88b 2, [compile] drop ;
: c! 0xc88b 2, [compile] drop ;
: 2*d 0xc3a50f 3, ;
: 2*c 0xe0d3 2, ; forth :var na [0x15] :var nb [0x9] :var h [0x4062000] :var an :var aa [0x472a4bd] :var nz [0x4]
: ?new  na  @ dup and drop if ;  then
: new  aa  @ @  an  ! 1  aa  +! 32  na  ! ;
: shift ( n-n) dup negate dup  nb  +!  na  +! c!  an  @ 2*d 2*c  an  ! ;
: bits ( n) ?new dup negate  na  @ + -if dup push + shift new pop negate shift ;  then drop shift ;
: tbits ( nn)  nb  @ 8 + c! 2*c or
: ,  h  @ ! 1  h  +! ;
: tz ( nn-n) over  nz  ! dup negate push + b begin dup 1 and drop if drop drop pop drop  nz  @ ;  then 2/ next b! dup  nz  @ - + -  nb  +! pop drop ;
: ?full ( n-n)  nb  @ dup and -if tz dup push -4 +  nb  +! tbits $ 0 dup pop dup - 29 +  nb  ! ;  then drop ;

( block 33 )

: b ( pop ebx, register 3, into eax)
: c! ( push eax into register 1, ecx)
: 2*d ( shift ebx left by ecx. bits from eax)
: 2*c ( shift eax left by ecx)
: na ( bits remaining in source word)
: nb ( bits remaining in ebx)
: h ( destination address)
: , ( store at destination)
: ?new ( fetch new word if necessary)
: new ( 32-bits in current word)
: shift ( eax into ebx, decrement) nb
: tbits ( fill ebx with tag)
: ?full ( is there room in ebx?)
: bits ( shift bits into ebx. overflow into next word)

( block 34 )
( native system dependencies) macro 
: p@ [compile] a! [compile] ?dup 0xec 1, ; forth 
: key? 0x64 p@ 1 and drop if 0x60 p@ 0x80 and drop if ;  then pop drop then ;
: clock  40  load ;
: altfrm ( -b)  aper @ 1024 768 * -4 * +  ;
: topram ( -b)  0x30000000  ;
: !work ( n) block 0 over  1  + @  35  +  36  / writes stop ;
: @rest ( nn) push  36  + block  2  pop reads stop ;
: @back ( n) dup block 0  2  reads dup  18  + block dup @  18 block @  or drop if drop  78  @rest ;  then dup  1  + @ dup and -if nip abs  35  +  36  /  -2  + @rest ;  then drop drop  78  @rest ;
: !back ( n) block 0  nblk  @  18  / writes stop ;
: @cyls ( acn) reads stop ;
: screen 0 dup at 1024 768 box ;
: utime ( -n) 0 ;


: serial ( -n)  108  ;

( block 35 )

: key? ( exits calling defn if key struck)
: clock ( loads time of day suppt)
: altfrm ( byte addr of alternate frame buffer)
: topram ( end ram avail for applications.)
: @back and !back ( read/wrt full disk to/from adr)  @back reads only active part of compressed 
: @cyls ( equiv to reads)
: screen ( fills screen with current color)
: utime ( null definition for now for compatability)

( block 36 )
( windows system dependencies)
: key?  keych  @ 0 or drop if pop drop ;  then ;
: beep ;
: clock 38 load ;
: topram
: altfrm ( -b)  endram -4096 768 * +  ;
: !work ( n) dup block  1  + @  1  + 2/ wwork ;
: @back ( n) dup 19 rback dup  18  + block dup @  18 block @  or drop if drop  1440  rback ;  then dup  1  + @ dup and -if nip abs  1  + 2/ rback ;  then drop  3  + @ rback ;
: !back ( n)  nblk  @ wback ;
: @cyls ( acn)  abuf  @back push  18  *  abuf  + block swap pop  18 256 *  * move ;
: screen 0 dup at 868 for 0 1024 line next 0 dup at ;
: serial ( -n)  112  ;
: fopen ( af-h) push push 0 32 ( exist) 3 0 ( 0 )  3  pop pop swap  4  * fcreate ; :var flng [0x39a4] flng 4 * dup 
: frd ( anh-n) push push push  0 +  pop pop swap pop fread
: frw? ( ok-n) if drop  flng  @ then ;
: fwr ( anh-n) push push push  0 +  pop pop swap pop fwrite frw? ;
: r/o  0x80000000  ;
: w/o  0x40000000  ;
: r/w  r/o w/o +  ;

( block 37 )

: key? ( exits calling defn if key struck)
: save ( writes full disk image)
: beep ( alert in hardsim)
: clock ( loads time of day suppt)
: altfrm ( byte adr of alt frame buffer)
: topram ( end ram avail for applications.)
: @back and !back ( read/wrt full disk to/from adr)  @back reads only active part of compressed, and only active part of straight disks with vars 
: @cyls ( equiv to reads)
: screen ( fills screen with current color)


: fopen ( opens an existing win32 file given word adr of name and access code of) r/o w/o ( or) r/w. ( returns handle, indicators nz if it's good. the alternate value) ( 3 ) ( enables sharing for read and write; necessary to open a file sf has open with clib.)
: frd ( and) fwr ( read and write on things with win32 handles.)

( block 38 )
( - clock)
: sec ( -n) utime  60 60 * 24 *  mod ;
: minute ( -n) sec 60 / ;

( block 39 )

: utime ( returns unix time in sec since epoch 0000z fri 1/01/1970)
: sec ( seconds since midnight needs unsigned mod by time we are all dead)
: min ( minutes past midnight)

( block 40 )
( native clock) macro ( pentium timer)
: p@ [compile] a! [compile] ?dup 0xec 1, ;
: p! [compile] a! 0xee 1, [compile] drop ; forth 
: ms 100000 * for next ;
: ca 0x70 p! 0x71 ;
: c@ ca p@ ;
: c! ca p! ;
: !bcd push 10 /mod 16 * + pop c! ;
: !hm 100 /mod 4 !bcd 2 !bcd $ 0 dup c! ;
: bcd c@ 16 /mod 10 * + ;
: sec0 4 bcd 60 * 2 bcd + 60 * 0 bcd + ;
: sec sec0 2 ms dup sec0 or drop if drop sec ;  then ;
: minute sec 60 / ;
: hms sec 60 /mod 60 /mod 100 * + 100 * + ;
: ymd 9 bcd 100 * 8 bcd + 100 * 7 bcd + ;
: day 6 c@ -1 + ;
: hi 10 c@ 0x80 and drop if ;  then hi ;
: lo 10 c@ 0x80 and drop if lo ;  then ;
: cal hi lo time - hi lo time + ( 748) ;
: beep 0xb6 0x43 p! 0xee 0x42 p! $ 0 0x42 p! ( on) 0x61 p@ 3 or 0x61 p! 50000000 for next ( off) 0x61 p@ 3 or 0x61 p! ;

( block 41 )


( block 42 )


( block 43 )


( block 44 )
( logo and watermark)
: logo show black screen 800 710 blue box 600 50 at 1024 620 red box 200 100 at 700 500 green box ( 18 ) ( list) text cf keyboard ; logo
: -safe ( a-f) negate here + 0x80000000 and drop ;
: ?logo sp 17 + @ -safe if logo ;  then ;
: empty empt ?logo ;
: 2u.r ( nw) -1 + dup push for 10 /mod next 0xf and begin  0  + if pop  1  +
: .lo for  24  + 2emit next ;  then drop space space next  1  .lo ;
: ?ec blk 2 + @ 0 + drop if red ;  then silver ;
: watermark show black screen 765 603 at  blk  @ ?ec 6 2u.r +list keyboard ;
: +buf ( n-n)  blk  @ over or if over or  blk 1 +  ! ;  then drop ;
: edit ( n) +buf  blk  !
: e watermark +e ;
: list ( n) +buf  blk  ! lis ;
: l  blk  @ list ;

( block 45 )
( logo and editor display extensions.) ( empty smart for less display wanking)
: logo ( displays colorforth logo)
: -safe ( returns true flag if addr is past)  here.
: ?logo ( displays logo screen if current display) ( generator has been forgotten.)
: empty ( switches to) logo ( display only if current display has been forgotten.) editor display ( is extended to show block no.) ( being edited above the keyboard hints, colored red if the editor is 'hot'.)
: +buf ( preserves) blk ( if new block is different)
: list ( displays the given block without entering the editor.)
: l ( lists the current editor block.)

( block 46 )
( miscellaneous)
: !dict ( fmh)  h  !  macros  !  forths  ! ;
: interp ( b) align load ; ( temp) 9 here 4 / -1 + +! 
: finish  cad  @ interp ;
: -kbd ( -t) 7push pop dup and drop ;
: fh ( n-b) -kbd if 7push pop  0 block negate  + 256 / + ;  then  blk  @ + ;
: paws pause ;
: pause dup paws drop ;

( block 47 )

: !dict ( resets dictionary to a saved state)
: interp ( is a temp patch for missing interpreter entry point.)
: finish ( executes at same stack level as load but starts interpreting at editor's current cursor position.)
: -kbd ( returns true/nonzero flag if a word that calls it is being interpreted from a block as opposed to from the keyboard. use with caution from deep within an app that might have monkeyed with register) ( 7 )
: fh ( from here, block number relative to editor or interpreter block as appropriate.)
: pause ( is redefined to push an extra item onto stack while displaying for symmetry with kbd.)

( block 48 )
( dump) empty :var x [0x482c4f0] :var y [0xfb40dca0]
: 5-8 8 /mod 32 /mod 32 /mod 0x100 * + 0x100 * + 0x100 * swap 4 * + ;
: one dup @ dup 5-8 h. space h. space dup h. cr ;
: lines for one -1 + next drop ;
: dump  x  !
: r show black screen  x  @ 15 + 16 text lines keyboard ;
: it @ + @ dup h. space ;
: lines for white i  x  it i  y  it or drop if red then i . cr -next ;
: cmp show blue screen text 19 lines red  x  @ h. space  y  @ h. keyboard ;
: u 16
: +xy dup  x  +!  y  +! ;
: d -16 +xy ;
: ati 0xf4100000 ( ff7fc000) or ( agp graphics reg)
: byte 4 / dump ;
: fix for 0 over ! 1 + next ; dump

( block 49 )
( does not say empty, compiles on top of application)
: x -a ( current address)
: one a-a ( line of display)
: lines an
: dump a ( background task continually displays memory --- takes address -- displays three cols with address on right contents in middle and- the left col is f18 instruction view)
: u ( increment address)
: d ( decrement)
: ati ( address of agp graphic registers)
: byte a ( byte address dump)
: fix an-a ( test word)

( block 50 )
( timing) :var tmt [0x1115a1a8] :var tmn [0xf652bbb4] :var tmp [0x3d44e16] :var secs
: tmclr 0  tmt  ! 0  tmn  ! 0  tmp  ! 0  secs  ! ;
: tms ( a) time -  1  + swap +! ;
: tme ( a) time swap +! ;
: tare  tmt  tms pause  tmt  tme ;
: 0tare  tmn  tms switch  tmn  tme ;
: counter utime negate  secs  +! ;
: timer utime  secs  +! ;

( block 51 )


( block 52 )
( floppy utility) empty :var hd [0x1] :var ad [0x25312]
: array pop 2/ 2/ ;
: com align array  , 0x1202004d 0x6c 2, 
: word ( n)  ad  @ ! 1  ad  +! ;
: sectors ( cs-c) buffer  ad  ! 18 for over  hd  @ 0x100 * + over 18 mod 1 + 0x10000 * + 0x2000000 + word 1 + next drop ;
: head ( ch-c) dup  hd  ! 0x400 * 0x1202004d +  com  ! dup 2* - 1801 + sectors format ;
: cylinders ( n) push  com  0 pop for 0 head 1 head 1 + next ( stop) drop drop ;
: format ( nc @) 80 cylinders stop ;
: archive  0 block  0  nc  @ writes stop ;
: check  abuf block  0  nc  @ reads stop ;
: ati 0x10cd4123  vesa  ! ; ( setup for ati video card)
: nvidia 0x10cd4118  vesa  ! ; ( for nvidia card then save)

( block 53 )

: format ( issue format command 30 cyl - in kernel)
: hd ( disk head)
: ad ( current address in) buffer
: buffer ( usual floppy cylinder buffer)
: array ( return word address)
: com ( format command)
: word ( store word into command string)
: sectors ( build sector table)
: head ( build sectors for selected head)
: cylinders ( sectors advance 1 for each cylinder - to allow time for head step)
: format ( only desired cylinders to save time)
: bytes ( arguments for crc)
: archive ( verify save' compute crc, save, read-back, recompute crc - first 64 bytes used by floppy read/write -- the two crc numbers should be the same !)

( block 54 )
( icons) empty macro 
: @w 0x8b66 3, ;
: !w [compile] a! 0x28966 3, [compile] drop ;
: *byte 0xc486 2, ; forth :var ic [0xb] :var cu [0xa7]
: sq  xy  @ 0x10000 /mod 16 + swap 16 + box
17 0 +at ;
: loc  ic  @  16 24 8 */  *  12 block 4 *  + ;
: 0/1 0x8000 ? if green sq ;  then blue sq ;
: row dup @w *byte 16 for 0/1 2* next drop
 -17 16 *  17 +at ;
: ikon loc 24 for row 2 + next drop ;
: adj 17 * swap ;
: cursor  cu  @ 16 /mod adj adj over over at
red 52 u+ 52 + box ;
: line ( i-in) for dup emit 1 + next ;
: set ( xy) over lm at 0 10 for 12 line cr next
8 line drop ;
: ok show black screen cursor 18 dup at ikon
text  ic  @ dup . h. 400 60 set keyboard ; 56 load ok h

( block 55 )
( draw big-bits icon)
: @w a-n ( fetch 16-bit word from byte address)
: !w na ( store same)
: *byte n-n ( swap bytes)
: ic -a ( current icon)
: cu -a ( cursor)
: sq ( draw small square)
: xy -a ( current screen position, set by) at
: loc -a ( location of current icons bit-map)
: 0/1 n-n ( color square depending on bit 15)
: row a-a ( draw row of icon)
: ikon ( draw big-bits icon)
: adj nn-nn ( magnify cursor position)
: cursor ( draw red box for cursor)
: ok ( background task to continually draw icon, icon number at top)

( block 56 )
( - control panel)
: +ic 1  ic  +! ;
: -ic  ic  @ -1 + 0 max  ic  ! ;
: bit  cu  @ 2/ 2/ 2/ 2/ 2* loc + 0x10000  cu  @ 0xf and 1 + for 2/ next *byte ;
: toggle bit over @w or swap !w ;
: td toggle
: d 16
: wrap  cu  @ +  16 24 *  dup u+ /mod drop  cu  ! ;
: tu toggle
: u -16 wrap ;
: tr toggle
: r 1 wrap ;
: tl toggle
: l -1 wrap ;
: h pad nul nul accept nul tl tu td tr l u d r -ic nul nul +ic nul nul nul nul nul nul nul nul nul nul nul nul  , 0x2500 0x110160c , , dup , 0x2b000023 , 0 , 0 , 0

( block 57 )
( edit icon)

( block 58 )


( block 59 )


( block 60 )
( serial 3f8 2e8 1050) macro 
: p@ [compile] a! [compile] dup 0xec 1, ;
: p! [compile] a! 0xee 1, [compile] drop ;
: 1@ 0x8a 2, ;
: 1! [compile] a! 0x288 2, [compile] drop ; forth 
: r  0 +  + ;
: 9600 12 ;
: 115200 1 ;
: b/s 0x83  3 r  p! 115200  0 r  p! 0  1 r  p! 3  3 r  p! ;
: init b/s ( 16550) 1  2 r  p! 0  4 r  p! ;
: xmit ( n)  5 r  p@ 0x20 and drop if  0 r  p! ;  then ( pause) xmit ;
: cts  6 r  p@ 0x30 and 0x30 or drop if cts ;  then xmit ;
: st  6 r  p@
: xbits 0x30 and 0x10 / dup 1 and 2* 2* + 2/ ;
: st!  4 r  p! ;
: ?rcv  5 r  p@ 1 and drop if  0 r  p@ then ;
: rcv ?rcv if ;  then ( pause) rcv ;

( block 61 )

: p@ p-n ( fetch byte from port)
: p! np ( store byte to port)
: 1@ a-n ( fetch byte from byte address)
: 1! na ( store byte to byte address)
: r n-p ( convert relative to absolute port address. base port on stack at compile time. compiled as literal at yellow-green transition)
: 9600
: 115200 ( baud-rate divisors. these are names, not numbers)
: b/s ( set baud rate. edit to change)
: init ( initialize uart)
: xmit n ( wait for ready and transmit byte)
: cts n ( wait for clear-to-send then xmit)
: st -n ( fetch status byte)
: xbits n-n ( exchange status bits)
: st! n ( store control byte)
: ?rcv ( fetch byte if ready. set flag to be tested by) if
: rcv -n ( wait for ready and fetch byte)

( block 62 )
( word search) macro 
: bt ( nm-n)  0x68bd08b  ,  0xf04768d  ,  0xd21bc2a3  , ; forth 
: tag? ( nm-n) over 0xf and swap bt drop ;
: red? ( n-nm)  0x1008  tag? if  0x4092  ;  then  0x1008  ;
: t2 ( nn-nn) 1 +
: t1 ( nn-nn) 1  curs  +!
: t0 ( nn-nn) 1 + ;
: map ( nnn-nn) 0xf and jump
     t0 t1 t2 t1 t1 t2 t1 t1
     t1 t1 t1 t1 t2 t1 t1 t1
: tcurs ( nn-n) over block push -1  curs  ! 0
: tcu1 ( nnn-n) dup i + @ map over over negate + drop -if t1 drop drop pop drop ;  then tcu1 ;
: -curs ( -)  curs  @ -1 + 0 max  curs  ! ; here 
: tpoint  blk  @  curs  @ tcurs drop -curs ; cpoint !

( block 63 )
( word search tcurs)
: bt ( returns nz and less if bit n of m is set. pops t to 2, bit test index t mask 2, 2-2-sbb to set nz if carry.)
: tag? ( nz and less if bit in m indexed by tag of token n is 1.)
: t2 nn-nn ( 2 cell - big nums, var)
: t1 nn-nn ( 1 cell)
: t0 nn-nn ( extensions, undefined)
: map end n wrd-end n ( inc n and maybe curs)
: tcurs blk offset-blk ( convert offset to tokens in curs)
: -curs - ( decrement curs to zero)
: tpoint - ( fix abort to point cursor correctly, except if last word in block)

( block 64 )
( - more) :var fmask [0xfffffff0] :var fnn [0xef880010]
:var fna [0x4009200] :var fbits [0x1008] 18 block fna ! 
: +shad ( a-a) dup  fna  @ or 256 and + ;
: 1word ( -n) word  words  @
: 1wz 2 less drop if drop ;  then nip -1 + 1wz ;
: want? ( nm-n) tag? if or ;  then drop drop -1 ;
: -found ( na) @  fbits  @ want?  fmask  @ and drop ;
: reedit ( fna) nip dup 1 +  fna  !
     0x100 /mod -offset swap tcurs swap
     dup and drop if dup  blk  ! then edit ;
: find 1word 0x5e9a : fnd+ 18 block -16
: fnd ( nbam)  fmask  !  fna  !  fbits  ! 16 or  fnn  ! 0
: f ( f)  fnn  @ 16 or  fna  @ begin
     +shad  nblk  @ block less drop while
     over over -found while 1 + end
     then reedit ;  then drop drop drop ;
: def 1word  0x1008  fnd+ ; here ekt 21 + ! 
: fkc drop  pcad  @ @  0x140  tag? if  32  / edit ;
 then red? fnd+ ( blk @) dup ; here ekt 22 + ! 
: fk drop ( drop)  cad  @  fna  ! 1 f ( blk @) dup ;
: from ( n) 1word swap  0x5e9a  swap block  -16  fnd ;
: literal ( n) 0x20 *  0x140  18 block  -32  fnd ;

( block 65 )
( word search)
: +shad ( skips shadows if in one and skipping.)
: 1word -n ( return 1st cell of word from kbd.)
: find ( finds following short word, starting in block 18, regardless of color.)
: def ( finds only definitions.)
: f ( find next occurrence of word last found)
: fk ( 'f' key in edit keyboard. drops key and block number and behaves like f except continues search from current editor position in current kind of block src/shad.)
: fkc ( if word left of cursor is a number, list that block. if red or magenta definition, searches for references. otherwise searches for definitions.)
: from n- ( like find but start from block number)
: literal n- ( finds any equivalent literal)

( block 66 )
( editor recolor) 8 display + @ 13 display + ! 
: array pop 2/ 2/ + @ ; ( 1-4-9 2-5 8-6-15)
: reclr align array
 , 0 , 4 , 5 , 3 , 9 , 2 , 15 , 7
, 6 , 1 , 10 , 11 , 12 , 13 , 14 , 8 
: wadr ( -a)  pcad  @  blk  @ max ; here ekt 20 + ! 
: change wadr @ 0xf and reclr wadr @ 0xfffffff0 and or wadr ! ; 0x220e100a ekt 33 + !

( obsolete comment cases) 0xf000000 ekt 32 + !
ekt 16 + @ dup ekt 17 + ! ekt 18 + !

( block 67 )
( tags)
( extend) execute 32-bit ( define)
 compile 32-bit  27-bit [compile] immediate
 27-bit ( comment cap caps)
( variable address blue 27-bit)


: array ( fetch new tag)
: reclr ( table of color cycles)
: wadr -a ( address of word to left of cursor)
: change ( color of word to left of cursor)
: 220e100a ( 0a-c 10-d 0e-f 22-j)

( block 68 )
( blue words) :var ?blu [0xff] 0 ?blu ! 
: -w@ ( -n) 7push pop -1 + @ ;
: .blu  ?blu  @ color
: type1  9 display + @ 5 +  push ; here
: blu ;
: -blue ( b-t) dup 1 + 4@ +  -5 +  or drop ;
: d03 ( -a)  3 display +  ; here 
: exr  d03 @  nop  d03  ! red type1 ;
: -cr blu  0 +  nop  d03  ! ;
: sp/2 0xb0000  xy  +! ;
: bs  xy 1 +  @ 21 + 0x10000 *  xy  @ less drop drop if 0xffea0000  xy  +! then ;
: wd ( nn-/n) over or if 0 and drop ;  then nip pop pop drop push 1 or drop ;
: simple ( -w) -w@ -16 and ( *) 0xfa000000 wd if bs .blu -cr bs ;  then ( ,) 0xfc000000 wd if bs .blu cr ;  then ( .) 0xea000000 wd if .blu bs ;  then ( ..) 0xebd40000 wd if .blu bs ;  then ( ...) 0xebd7a800 wd if .blu bs ;  then ;

( block 69 )
( blue and grey words)
: must ( fit into one cell!)
: -w@ ( returns word being interpreted by display)
: .blu ( display blue word)
: type1 ( displays word with color already set)
: exr ( one-shot red display suppressing cr)
: -cr ( arms exr for next red word encountered.)
: s/2 ( halfspace for reports.)
: bs ( backspace protecting left margin)
: wd ( is a factor of) simple ( to test shannon codes)
: simple ( returns regular blue word for execution but handles special words internally.)
: exb ( display and execute blue word iff found in dictionary.)

( block 70 )
( - blue and grey) here 14 display + ! 
: exb simple .blu itick if drop ;  then dup -blue if drop ;  then push ( drop) ;
: seeb  ?blu  @ 0xff or  ?blu  ! ;
: ?seeb ( -t)  ?blu  @  0  + drop ;
: @lit -w@ 32 / ; ( grey) here display 13 + ! 
: tadr 0xc0c0c0 color @lit 1024 /mod swap 2 over -256 and drop if 1 + then h.n 0 + if 39 emit dup 1 h.n then drop space ; ( old blue words)
: br blu cr cr ;
: tab ( n) for space next ;
: indent blu cr 3 tab ;
: kr cr ;
: cr blu kr ;

( block 71 )

: seeb ( toggle display of blue words)
: ?seeb ( set flag non-zero if blue words visible)
: @lit ( fetch 27-bit literal from current word)
: tadr ( display target address)
: br ( blank line)
: tab ( advance n spaces)
: indent ( 5 spaces)

( block 72 )
( convert cf character to/from ascii)
macro 
: 1@ 0x8a 2, ; : 1! [compile] a! 0x288 2, [compile] drop ; forth 
: string pop ;
: cf-ii align string
 , 0x6f747200 , 0x696e6165 , 0x79636d73 , 0x7766676c
, 0x62707664 , 0x71757868 , 0x33323130 , 0x37363534
, 0x2d6a3938 , 0x2f7a2e6b , 0x2b21273b , 0x3f2c2a40 
: ch 0xfffffff0 and unpack  cf-ii  + 1@ 0xff and ;


: ii-cf string
 , 0x2a00 , 0x2b , 0x2b2d0000 , 0x2725232e
, 0x1b1a1918 , 0x1f1e1d1c , 0x28292120 , 0x2f000000
, 0x3a43355c , 0x3d3e3440 , 0x54523744 , 0x3336393c
, 0x38314742 , 0x3f414632 , 0x563b45 , 0x23000000
, 0xa13052c , 0xd0e0410 , 0x24220714 , 0x306090c
, 0x8011712 , 0xf111602 , 0x260b15 
: chc 0xffffffe0 +  ii-cf  + 1@ 0xff and ;


: set1 0x3d21223a 0x3e2c203c
: !8 ( nn-)  cf-ii 0x2c + 2/ 2/  !  cf-ii 0x28 + 2/ 2/  ! ;
: set0 0x2b21273b 0x3f2c2a40 !8 ;

( block 73 )
( colorforth to ascii and ascii to colorforth)
: cf-ii ( otr inae ycms wfgl bpvd quxh)
     ( 3210 7654 -j98 /z.k +!'; ?,*@)
: ii-cf ( ! +* /.-, 3zjk 7654 ;'98 ?)
     ( cba@ gfed 02ih onml srqp wvut 1yx)
     ( cba@ gfed 02ih onml srqp wvut 1yx)

 to facilitate pathnames and html strings... 
: set1 ( modifies cf-ii table.)
; ( to colon,)  ' ( to doublequote,) + ( to equal,)
@ ( to lessthan,) * ( to blank,) ? ( to greaterthan)
: set0 ( restores original cf-ii table.)

( block 74 )
( pathname input) -nat 72 load set1 
: strng ( n-a) pop + ;
: fnam ( n-a) align strng  here 80 + h ! :var hld [0xc]
: emt ( n-)  hld  @ fnam 1! 1  hld  +! ;
: +shan ch emt dup and if +shan ;  then drop ;


: ,src 7@+ @
: xx dup and if +shan 7@+ @ dup 15 and drop
while then  0  and emt 7dec ;  then xx ;
: named ( string) 0  hld  ! -kbd if ,src ;
 then ( keyboard) 0 word 0
begin push dup and while end then drop
begin pop dup and while +shan end then emt ;

: onam ( n-a) align strng  here 80 + h ! 
: bnam ( n-a) align strng  here 80 + h ! 
: !str ( b) push named  0 fnam  4 / pop 4 /  20  move ;
: onamed 0 onam !str ; onamed ( okadwork.cf)
: bnamed 0 bnam !str ; bnamed ( okadback.cf)
0 onam 'ofn ! 0 bnam 'bfn !

( block 75 )
( filename input)
: strng ( defines an array of bytes.)
: fnam ( is a zero terminated ascii string consisting of) hld ( chars including the null.) emt ( appends a character to this string.)
: +shan ( appends a shannon word to fnam.)


: named ( returns the byte address of a null terminated ascii string representing the following colorforth string, which may follow in either source code or in keyboard input.)
( example)  named ( //./a;)


: onamed ( and) bnamed ( override the default .cf)
( filenames used by save and audit)

( block 76 )
( index) empty -nat
:var pad [0x109e4000] abuf block 4 * pad !
:var hld [0x109e79a4] pad @ hld ! :var pos [0x2] 0 pos ! 
: nxt ( a-an) dup 1 + swap @ ;
: -eol?  pos  @  47  or drop ;
: .sp 32
: .ch ( c) -eol? if  hld  @ 1! 1  hld  +! 1  pos  +! ;
      then drop ;
: crlf 0  pos  ! 13 .ch 10 .ch ;


: .hd ( n)  -10  + -if  0x3a  + .ch ;  then  0x41  + .ch ;
: .dec ( n)  0  + -if 0x2d .ch negate then  -1  swap
begin  10  /mod dup and while end then drop
: spit ( -1 ...) begin .hd  0  + -until drop ;


: hd ( n-nn) dup  0xf  and swap 2/ 2/ 2/ 2/ ;
: .hex ( n)  -1  swap begin hd 0xfffffff and while end then drop spit ;
78 load

named ( index.txt) exit 18 1440 run

( block 77 )
( index)
: hld ( place in file)
: spot ( in line)
: nxt ( fetch next word)
: emit ( ascii character, won't go past column) ( 72 )
: space ( written to file)
: crlf ( to file)
: digit ( hex digit to file)
: .h ( print hex number)
: .d ( decimal number)

 usage example in bottom line.

( block 78 )
( - more)
: word ( n) .sp  0xfffffff0  and
: cont ( n) dup and if ch .ch cont ;  then drop ;
: short ( n) .sp 2/ 2/ 2/ 2/ dup 1 and drop
     if 2/ .hex ;  then 2/ .dec ;
: variable ( an-a) word 0
: long ( an-a) .sp push nxt pop 0x10 and drop
     if .hex ;  then .dec ;
: eol ( n) begin drop 47  pos  ! ;
: tag ( a-a) dup and until dup 0xf and jump
cont word long eol word long short word
short word word word variable short eol short
: ?sp ( nl-n) + -if .sp then ;
: line ( n) -100 ?sp -900 ?sp 1000 +
     dup .dec space block 0  pos  !
     begin -eol? while nxt tag end
     then drop crlf ;
: run ( 1st lst+1)  pad  @  hld  ! over negate + 2/
     for dup line  2  + next drop
: sav 0 32 2 0 0 w/o  0 fnam  fcreate dup push
 pad  @  hld  @ over negate + pop fwr drop fclose ;

( block 79 )
( index.1)
: short ( number)
: literal ( long number)
: word ( text, not number)
: cont ( inuation word)
: variable ( name and value)
: eol ( red word means end of line)
: tag ( vector table)
: words ( print maximum n words or to eol)
: run  first-block last+1
( prints first line of each block in range)
( to a log file) in windows

( block 80 )
( qx) :var ?qxc [0x102f7e01] :var qb 82 load 
: ?c ( n-n) green dup  blk  @ or drop if white then ;
: !qx  ?qxc  assign ?c ; !qx
: nx  qb  @ 120 +
: qx ( n !qx) 0 max abuf /mod push 2 /mod 60 / 120 * + pop abuf * +  qb  ! show black screen white 0 60 for dup 30 /mod 42 * swap tab/2  qb  @ over 2* +  ?qxc  xqt dup .r .cmt 1 + next drop keyboard ;
: bx  qb  @ -120 + qx ; : ax  blk  @ qx ;
: sx  qb  @ 1 or qx ;
: ox  qb  @  abuf  /mod 1 or  abuf  * + qx ;

( block 81 )
( index page overview display)


: qx ( shows the heading comments of the index page in which block)  n ( lies, source or shadow.)


: nx ( shows the next page and) bx ( the preceding.)
: sx ( toggles between source and shadows for the current page.)


: ax ( shows the page in which the current editor block lies.) this block is displayed in green

( block 82 )
( - formatting) :var ws [0x102f7c81]
: tab/2 ( xy) push  11  *  3  + pop  15  *  3  +
over lm at ; : emit/2 ( c)  48  + emit
: -sp/2  -11 0x10000 *  nop  xy  +! ;


: /bl  ws  assign nop ; : /sp  ws  assign sp/2 ;
: .r ( n)  4  for 10 /mod next 0xf and  4  for  0  + if
pop  1  + : .lo for  24  + emit/2 next ;
 then drop  ws  xqt next  1  .lo ; /sp 
: .n ( n)  32  / /bl .r /sp ;
: .s/2 ( n)  0  + if unpack emit/2 .s/2 ;  then drop ;
: .wd ( n)  0x8200  tag? if sp/2 then  0x8000  tag? if .n ;  then -16 and .s/2 ;
: .cmt ( n) 18 less drop if drop ;  then block 7 for dup @  0  + while  0x8201  tag? while .wd
 1  + next drop ;  then then pop drop drop drop ;

( block 83 )
( index page overview display)

( these definitions are necessary due to the way in which colorforth kernel is factored.)

( block 84 )
( resident compress) 86 load 
: short 4 rbits 28 bits ;
: lit 4 rbits 2/ 2/ 2/ 2/ 1 rbits
: 32bits drop 1 + dup @ 16 bits 16 bits ;
: variable 1word 32bits ;
: /whit ( n-n) -16 and 9 or atom ;
: tag ( an-an) dup 0xf and jump cont atom lit atom atom lit short atom short atom /whit /whit variable short atom short
: atoms ( a) dup @ dup and if tag drop 1 + atoms ;  then 4 bits drop drop ;
: range ( nn-an) here/4 here4 push new for dup block atoms 1 + next drop $ 0 31 bits drop pop here4 over negate + ;
: !lng ( nw)  127  +  128  /  72  + dup ( nsec)  0  block  1  + ! dup negate  ns  !  35  +  36  /  nc  ! ;
: save 7push  h  @ push  cbuf 36 + block 4 *  h ! 36  nblk @ -36 +  range ( an) !lng drop $ 0 block  cbuf  block  36 blks  move  cbuf  !work  ns  @ abs  ns  ! pop  h  ! 7pop ;

( block 85 )

: short ( tag, then 28bit value+base)
: lit ( tag, then base)
: 32bits ( from next word. 2 chunks)
: variable ( single word, then 32-bits)
: /whit ( replaces a word's tag with 9, making it a lowercase comment.)
: tag ( identify kind of word)  note /whit used for tags 0xa and 0xb to convert these deprecated capitalized comments to lower case. when all source of interest has been compressed at least once this may be removed. 
: atoms ( scan thru block. 8 0s eob)
: range ( process blocks, number and count. 31 0s eof)
: sve ( compress blocks 72 thru 1419)
: flop ( write floppy; save number of cylinders)

( block 86 )
( - more) macro ( uses ebx)
: r3@ [compile] ?dup 0xc38b 2, ;
: r1! 0xc88b 2, [compile] drop ;
: 2*d 0xc3a50f 3, ;
: 2*c 0xe0d3 2, ;
: 2/r 0xc8d3 2, ; forth :var nb [0xd]
: here/4 here 3 and if 1, here/4 ;  then drop ;
: here4 here 2/ 2/ ;
: new 32  nb  ! ;
: shift ( nn-n) dup negate  nb  +! r1! 2*d 2*c ;
: rbits dup r1! swap 2/r swap
: bits ( nn-n) dup negate  nb  @ + -if dup push + shift r3@ , new pop negate shift ;  then drop shift ;
: char -if 2* -if 2/ 7 bits ;  then 2/ 0x80000000 or 5 bits ;  then 4 bits ;
: chars dup and if char chars ;  then ;
: 1word 4 rbits chars 4 bits ;
: atom ( an-an) 4 rbits
: cont chars over 1 + @ dup and if 0xf and drop if 4 bits ;  then ;  then drop 4 bits ;

( block 87 )

: r3@ ( fetches register) ( 3 ) ( onto stack.)
: r1! ( stores top of stack to register 1.)
: 2*d ( shift ebx left by ecx. bits from eax)
: 2*c ( shift eax left by ecx)
: 2/r ( rotate eax right by ecx)
: nb ( number of bits remaining in word)
: here/4 ( align to word boundary)
: here4 ( word address in dictionary)
: new ( 32-bits in current word)
: shift ( eax into ebx, decrement) nb
: rbits ( rotate bits to high-order position)
: bits ( shift bits into ebx; cross word boundary)
: char ( examine high bits. shift 4, 5 or 7 bits)
: chars ( shift all non-zero characters)
: 1word ( short word without continuation for variable)
: atom ( shift tag, then characters)
: cont ( continue without tag)

( block 88 )
( display text) macro 
: 7@+ ( -a) [compile] ?dup 0xc78b 2, 0x47 1, ;
: 7dec 0x4f 1, ;
: @ret ( -b) [compile] ?dup 0x24048b 3, 0x5240483 , ;
: 4@ ( b-n) 0x8b 2, ; forth 
: tick ( b-b) dup  1  + 4@ + 5 + ;
: call 0xe8
: dst 1, @ret tick here 3 + - + , ;
: jmp 0xe9 dst ;
: execute ( b) push ;
: .shan ( n-) dup and if unpack emit .shan ;  then drop ;
: .shans ( a) begin dup @  0x8201  tag? while -16 and .shan 1 + dup @  0x8200  tag? drop if space then end then drop drop ;
: +str ( a-a) + ; macro 
: ,lit ( n) [compile] ?dup 0xb8 1, , ;
: strings ( i-a) 7push pop [compile] ,lit jmp +str nop ;
: .' ( comments) 7@+ [compile] ,lit call .shans nop ;
: remember  forths  @ [compile] ,lit  macros  @ [compile] ,lit  h  @  15  + [compile] ,lit ( call) jmp !dict nop ; forth
: ' ( -b) -kbd if 7@+ @ itick if abort then ;  then tic ;
: eval ( a) 7push  1  + push 7pop  sp 1 +  @ execute 7pop ;

( block 89 )
( various useful extensions.)


: 7@+ ( interpret only, returns adr of next word in block and skips over it ... 7-0-mov 7-inc)
: 7dec ( used to correct address after 7@+)
: @ret ( fetch return address, skip bytes of code.)
: 4@ ( cell fetch on byte boundary)
: tick ( given adr of call instr, return tgt adr)
: call ( and) jmp ( generate xfers to next word)


: .shan ( displays a shannon coded string)
: ,lit ( compiles a literal.)
: .' ( displays the following comment or comments.)
: remember used ( in a containing word to make that word restore dictionary to what immedately follows it.)


: strings ( starts an array of words in source.)
: ' ( interp only, returns next word's code addr.)
: execute ( is a call to the given routine adr.)
: eval ( interprets the source word whose address is given.)

( block 90 )
( disk audit utility) empty 30 load :var bias :var sep [0x2710] abuf sep ! :var head [0x59f] 1439 head ! 
: +blocks ( sdn) 2* ( bloks ;)
: bloks ( sdn) push swap block swap block pop  256  * move ;
: n18 ( i-a)  abuf 18 + block  + ;
: wipe  blk  @ 1 erase ( e) lis ;
: to ( n)  head  ! ;
: obliterate ( lh) over negate + erase ;
: matching ( sd) less if swap then dup  bias  ! negate +  sep  ! ;
: cast ( nn-n) dup push /mod 1 or pop * + ;
: other ( n-n')  bias  @ negate +  sep  @ cast  bias  @ + ;
: lesser ( n-n) dup other min ; 92 load 
: ?blk ( n-n?n+) lesser dup block over other block  256  for over @ over @ or drop if drop drop dup  1  + pop drop ;  then  1  +  1  u+ next drop drop  1  + ;
: ?blks ( sn-?) for ?blk next drop ;
: ?bin ( kernel) 0 12 ?blks ( icons) 12 6 ?blks ;
: unpk abs  1 n18  !  abuf 36 +  block  cbuf  block  1404  blks move  cbuf block  abuf 36 +  3 n18  @  -36  + range ;
: check  abuf  @back  0 n18  @  18 block @  or drop if ;  then  1 n18  @ dup and -if unpk ;  then drop ;

( block 91 )
( disk mgmt and reconciliation utility.)
: bloks ( copies n blocks from s to d, front to back so only moves overlap downward safely.)
: +blocks ( copies n blocks and their shadows.)
: obliterate ( wipes from block l to block h.)
: matching ( sets up to match s to d.)
: to ( sets block no. past end of source area.)
: other ( given a block number in one of the areas returns the corresponding block no. in the other area.)
: lesser ( given a block number returns the lesser of the pair it is a member of)
: ?blks ( scans a range of blks leaving nos of any differing blks on the stack.)
: ?bin ( scans the binary parts of okad disk.)
: check ( reads backup to) ( 3000 ) ( and decompresses if appropriate)

( block 92 )
( - compare) :var cvec [0x102f9404]
: blink  cvec  assign ( n) dup other  blk  ! edit ;
: var ( nnxx-nnd) push push 1 + 1 u+ pop pop
: *1 ( nnxx-nnd) or ;
: *2 ( nnxx-nnd) var push over @ over @ or pop + ;
: tag ( nn-n) dup 0xf and jump *1 *1 *2 *1 *1 *2 *1 *1 *1 *1 *1 *1 var *1 *1 *1
: ?nul ( nnxx-nnxx) over over +or drop if ;  then drop drop pop drop drop drop ;
: co ( naa-n) over @ over @ ?nul tag drop if drop drop  cvec  xqt ;  then 1 + 1 u+ co ;
: com ( n-n) dup block over other block co ;
: g  blk  @ lesser
: gg ( n) blink  head  @ over - + drop -if drop ;  then  1  + com gg ;
: v  blk  @ other edit ;
: give  blk  @ dup other 1 bloks ;
: take  blk  @ dup other swap 1 bloks ;
: all 0  abuf  matching  nblk  @  -1  + to  17  gg ;
: diff  cvec  assign red ;
: !cx  ?qxc  assign ( n-n) ?c diff com ; !cx
: empty empt !qx ;

( block 93 )

: blink ( displays the given block with its other set as the editor's 'other' block)
: var ( compares a variable name, advancing pointers to skip its value.)
: *1 ( compares garden variety words.)
: *2 ( compares large literals.)
: tag ( compares source cells given, true if diff, advancing ptrs and ignoring variable vals.)
: ?nul ( ends loop in co if nuls hit in both blks.)
: co ( does work of com given adrs of both blks.)
: com ( invokes editor to blink the given block if it differs from the other, otherwise returns.)
: g ( scans for diffs after current editor block.)
: v ( shows the other block)
: give ( writes current editor block over its twin)
: take ( writes twin over current editor block.)
: check ( reads backup to 3000 for matching.)
: all ( scans the whole usable area of the disk.)
: cvec ( is behavior on com finding difference;)
: diff ( makes it just set color for qx.)
: !cx ( makes qx aware of us,)
: empty ( redefined to kill that awareness.)

( block 94 )
( improved stack display) :var nr [0x2]
: -msg  ' nul  'msg ! 2  nr  ! ;
: msg -msg pop 'msg ! ;
: rep -1  nr  +!  nr  @ 0 + drop if ;  then -msg ;
: ?msg 'msg @ -safe if -msg ;  then ;
: empty empt ?msg ?logo ;
: ks0 ( -a) 'stk 1 + @ 4 / -1 + ;
: ksp ( -a) 'stk 2 + @ 4@ 4@ 4 / ;
: .s ks0 ksp negate + ( dup .) 0 less drop if abs . .' ( below empty) ;  then 0 + if  5  over less drop if .' ( ...) swap then drop dup push ksp + begin dup @ ?. -1 + next ( drop) then drop ; ( install) ' .s 'stk ! ( exit)
: -range msg rep red .' ( out of range) ; macro 
: then ( a-a) here over negate + 128 + -256 and drop if -range abort dann [compile] dann ; forth exit
: dstk
: z ( 'msg assign white) 'stk 2 + @ 9 + 4@ 4@ ( 4 ) ( / ?.) ;

( block 95 )

: -msg ( deactivates any current message and sets) nr ( to default life span of) ( 2 ) ( refreshes, which typically means)  two keystrokes. 
: msg ( is std word to assign rest of defn to msg.)
: rep ( is used inside a msg to count down life.)
: ?msg ( deactivates if its code's been forgotten.)
: empty ( changes display/message only if needed.)  messages display till forgotten, or aged using rep, or are replaced by another, or someone says -msg, or the message otherwise monitors the situation and uses -msg itself.
: ks0 ( and) ksp ( return empty and current stack) ( pointers in word units.)
: .s ( displays stack, top on right,)  yellow ( number is max number of entries to display. indicates stack below empty and ... when excess items.) ( factored separately so new versions may be) ( tested as messages with)  nos

( block 96 )


( block 97 )


( block 98 )


( block 99 )


( block 100 )


( block 101 )


( block 102 )


( block 103 )


( block 104 )


( block 105 )


( block 106 )


( block 107 )


( block 108 )
( ide native async) 0 fh orgn ! macro 
: 1@ ( b-c) 0x8a 2, ;
: 1! ( cb) [compile] a! 0x288 2, [compile] drop ;
: 2@ ( b-h) 0x8b66 3, ;
: 2! ( hb) [compile] a! 0x28966 3, [compile] drop ;
: 4@ ( b-n) 0x8b 2, ;
: 4! ( nb) [compile] a! 0x289 2, [compile] drop ;
: swab ( h-h) 0xc486 2, ;
: swa4 ( n-n) 0xc80f 2, ; forth 
: a-b ( a-b) 2* 2* ;
: b-a ( b-a)  3  + 2/ 2/ ;
: create ( -a) pop b-a ;
: rez ( n) h +! ;
: ?zero ( n-n)  0  or if dup or ;  then ( -)  -1  or ;

:var act :var vport [0x175] :var 0tg [0x1] :var 1tg [0x1] :var 2tg [0x1]
: cold 1  0tg  ! 1  1tg  ! 1  2tg  ! 0  act  ! ;

( ser) 110 load 118 load ( routes) 120 load
( generic) 122 6 loads ( panel) 134 load
( user) 136 load 142 load ( creeper) 140 load
canon load

( block 109 )
( talk to chip via native rs232.)


: 1@ ( and) 1! ( byte fetch and store, byte address.)
: 2@ ( and) 2! ( halfcell fetch/store, byte adr.)
: swab ( and) swa4 ( 2-way and 4-way byte swaps.)
: a-b ( and) b-a ( convert cells to+from bytes.)


: bofs ( and) ofs ( make byte and cell offset adrs in a structure given byte posn and byte width.)
: create ( used after)  align ( to exit with word adr of cell following in dictionary.) note that writing into such allocations invalidates nearby instruction cache! 
: rez ( allots n bytes in the dictionary.)
: ?zero ( classical zero-equal returning 0 or -1 with indicators.)


: ntgt ( indices for active paths, 1 for adjacent.)
: act ( number of selected path, to which) vport ( leads.)
: cold ( sets no active paths.)
: user ( test code before canonicals.)

( block 110 )
( - umbilical) 0x3f8 ( serial) 60 load 
: !nam ; :var sport :var bps
: rsh ( ni-n) 0 + if for 2/ next ;  then drop ;
: sdat align create  24576 rez :var bi [0x1e]
: -stream 0  bi  ! ;
: stream ( -b)  sdat a-b  ;
: /str ( -b)  bi  @  stream  + ;


: @18 ( -n) /str 4@  0x3ffff  and
: +wd 3  bi  +! ;
: !18 ( n)  0x3ffff  or  0x40  *  0x12  + /str 4! +wd ;


: +ser ( -ok) init 1  0  + ;
: -ser ;
: reset  1  st!  100000  for next  3  st! ;
: toser ( bn) for dup 1@ xmit  1  + next drop ;
: inser ( w) stream swap  3  * for
     rcv over 1!  1  + next drop ;

( block 111 )
( async data are 18 bits per 3 bytes. to chip word inverted, shifted up 6, '12' inserted, then sent low order byte first. from chip are tbd.)


: !nam sport ( and) bps ( dummies for compatibility)
: 4@ ( and) 4! ( full cell on byte address.)
: +ser ( opens serial; true if good, handle in dh.)
: -ser ( closes the handle.)
: reset ( resets the chip.)
: toser ( transmits n bytes to chip.)
: inser ( receives w f18 words from the chip.)


: -stream ( clears byte index) bi ( in) sdat ( buffer.)
: stream ( byte adr of buffer.)
: /str ( byte adr of next 18-bit slot in buff.)


: @18 ( returns the next 18 bits from the stream.)
: !18 ( appends 18 bits to the stream. no higher order bits may be present!)

( block 112 )
( ide windows async) 0 fh orgn ! macro 
: 1@ ( b-c) 0x8a 2, ; : 1! ( cb) [compile] a! 0x288 2, [compile] drop ;
: 2@ ( b-h) 0x8b66 3, ; : 2! ( hb) [compile] a! 0x28966 3, [compile] drop ;
: 4@ ( b-n) 0x8b 2, ; : 4! ( nb) [compile] a! 0x289 2, [compile] drop ;
: swab ( h-h) 0xc486 2, ;
: swa4 ( n-n) 0xc80f 2, ; forth


: a-b ( a-b) 2* 2* ; : b-a ( b-a)  3  + 2/ 2/ ;
: create ( -a) pop b-a ; : rez ( n) h +! ;
: ?zero ( n-n)  0  or if dup or ;  then ( -)  -1  or ;

:var act :var vport [0x115] :var 0tg [0x1] :var 1tg [0x1] :var 2tg [0x1]
: cold 1  0tg  ! 1  1tg  ! 1  2tg  ! 0  act  ! ;

( ser) 114 3 loads ( routes) 120 load
( generic) 122 6 loads ( panel) 134 load
( user) 136 load 142 load ( creeper) 140 load
canon load

( block 113 )
( talk to chip via onspec usb.)


: 1@ ( and) 1! ( byte fetch and store, byte address.)
: 2@ ( and) 2! ( halfcell fetch/store, byte adr.)
: swab ( and) swa4 ( 2-way and 4-way byte swaps.)
: a-b ( and) b-a ( convert cells to+from bytes.)


: bofs ( and) ofs ( make byte and cell offset adrs in a structure given byte posn and byte width.)
: create ( used after)  align ( to exit with word adr of cell following in dictionary.) note that writing into such allocations invalidates nearby instruction cache! 
: rez ( allots n bytes in the dictionary.)
: +or ( inclusive or.)
: ?zero ( classical zero-equal returning 0 or -1 with indicators.)


: ntgt ( indices for active paths, 1 for adjacent.)
: act ( number of selected path, to which) vport ( leads.)
: cold ( sets no active paths.)
: user ( test code before canonicals.)

( block 114 )
( - umbilical) :var sport [0x3] 1 sport ! 
: rsh ( ni-n) 0 + if for 2/ next ;  then drop ;
: sdat align create  24576 rez :var bi [0x17d]
: -stream 0  bi  ! ;
: stream ( -b)  sdat a-b  ;
: /str ( -b)  bi  @  stream  + ;


: @18 ( -n) /str 4@  0x3ffff  and
: +wd 3  bi  +! ;
: !18 ( n)  0x3ffff  or  0x40  *  0x12  + /str 4! +wd ;


: snam ( -a) align create ( //./)  , 0x2f2e2f2f ( com) , 0x6d6f63 , 0x0 
: !nam  sport  @ 10 over - + drop -if 256 * 2560 /mod + 0x3000 + then 0x30 + snam a-b 7 + 4! ; !nam 
: toser ( bn)  dh  @ fwr drop ;
: inser ( w) stream swap  3  *  dh  @ frd drop ;

( block 115 )
( async data are 18 bits per 3 bytes. to chip word inverted, shifted up 6, '12' inserted, then sent low order byte first. from chip are tbd.)


: sport ( comp com port number)
: snam ( null terminated string //./comx)
: !nam ( sets port number in snam.)
: +ser ( opens serial; true if good, handle in dh.)
: -ser ( closes the handle.)
: reset ( resets chip. no inversion in rx line.)
: toser ( transmits)  n ( bytes from byteadr) b 
: inser ( receives w f18 words from the sync boot node.)


: -stream ( clears byte index) bi ( in) sdat ( buffer.)
: stream ( byte adr of buffer.)
: /str ( byte adr of next 18-bit slot in buff.)


: @18 ( returns the next 18 bits from the stream.)
: !18 ( appends 18 bits to the stream. no higher order bits may be present!)

( block 116 )
( - com port management)
:var dflg [0x1011] 0x1011 dflg !
:var bps [0xe1000] 115200 bps ! 
: dcb ( n-a) align strng  here 32 + h ! 
: @dcb 0 dcb  dh  @ rdcb drop ; 0 0 dcb b-a 8 fill 
: !dcb  dflg  @  8 dcb  4! 0 dcb  dh  @ wdcb drop ;
: /dcb @dcb !dcb ;
: baud ( n) @dcb  4 dcb  4! ( bits) 8  18 dcb  1!
( np/1sb) 0  19 dcb  2! !dcb ;


: +ser ( -ok) snam r/w fopen  dh  ! if
 bps  @ baud 1 ;  then 0 ;
: -ser  dh  @  0  + if fclose 0 then  dh  ! ;
: ctl! ( n)  dh  @ fesc drop ;
: reset ( lo)  4  ctl!  500000  for next ( hi)  3  ctl! ;

( block 117 )

: dcb ( structure controls mode of a com port.)
: dflg ( flags sent every time we control com port) ( 0x1 ) ( binary always,) ( 0x10 ) ( dtr on,) ( 0x100 ) ( rts on.)
: @dcb ( and) !dcb ( read and write com port control.)  dflg ( is always included in the setting.)
: /dcb ( sets dflg without changing anything else)
: baud ( sets baud rate and character framing.)


: +ser ( opens serial; true if good, handle in dh.)
: -ser ( closes the handle.)
: reset ( resets chip. no inversion in rx line.)

( block 118 )
( - node) ( 708 ) ( boot frames)
: wos ( -n) 0 ;
: /frame ( nw xfr jmp) -stream  0x10000  + !18 !18  1  + 2/ ( words) 2* ( actual) ( -1 ) ( +) !18 ;
: +frame ( wn) for dup @ !18  1  + next drop ;
: +ram ( w n node) nn-n 2*  0x8000  + block u+ for dup @  0x15555  or !18  1  + next drop ;
: !frame ( f) drop stream  bi  @ toser ;


: exec  0xae  ;
: talk cold -ser +ser if drop reset 0x40 0  exec  /frame 0x0 0x40  1600  +ram  wos  !frame ( good) ;  then ( bad) -ser drop 0xbad dup abort ;

: exch ( w n f n) push push dup  0x2  +  -2  and  vport  @ pop /frame  vport  @  0x12000  + !18 dup -  0x1  and drop if  vport  @  0x10000  + !18 then +frame  wos  !frame pop inser -stream ;


: ok  0x12  ;
: fet  0x15  ;
: stat  0x1b  ;
: bstk  0x1d  ;

( block 119 )
( boot frames begin with a 3 word header;)
      100xx ( jump to xx when done)
     ddd ( mem/port adr to store payload)
     n ( transfer length)
      n ( words of payload, none if) n ( is 0.)
: /frame ( heads a new given)  even ( words of payload, destination addr, final jump addr.)
: +frame ( appends words to payload.)
: +ram ( appends a string of code from binary produced by) compile ( for the given)  node.
: !frame ( transmits frame given)  wos ( or) wos!


: talk ( prepares chip for control thru node 19.)
: exch ( performs a transaction with target given addr and length of port stream, stream end action in boot node, and number of words reply.)

: ok ( stream end to simply ack completion;) fet ( pumps one word from target;) bstk ( shepherds stack dump;) stat ( pumps ten.) exec ( is next boot frame.)

( block 120 )
( - node) ( 708 ) ( paths)
: line ( ncd) swap push swap
     begin dup , over + -next drop drop ;
: count ( nc-ncd) dup  100  mod  0  + if
( horz) swap drop  1  ; ( vert)  then drop  100  /  100  ;
: to ( nn) over negate + -if
( back) negate count negate line ;
( forw)  then count line ;


: 0pa align create  708 700 to 600 0 to
1 17 to 117 717 to 716 708 to , -1 
: 1pa align create  , 708 , 608 , -1 
: 2pa align create  708 717 to 617 17 to
16 0 to , 100 101 116 to 216 200 to
300 316 to 416 400 to 500 516 to
616 600 to 700 708 to , -1

( block 121 )

: 0pth 1pth 2pth ( are manually set route lists for using the north, south, and west ports of node 19. end list is marked by -1)

( customize these paths by replacing entries in) paths ( table after loading ide.)

( block 122 )
( - boot target adjacent) :var 'wall [0x1019729c]
: swall ( nn-i) over over or  1  and drop if or  2  and ;  then ( 10 )  100  / swap ( 10 )  100  / or  2  and  1  + ;
: wall ( nn-i)  'wall  xqt ; ' swall 'wall !


: do! align create ( @p+a!.@p+)  , 0x4ab7
     , 0x0 , 0x0 ( !;;;) , 0xb555 
: do@ align create ( ...@p+)  , 0x2c9b7
     , 0x0 ( a!@!p+;) , 0x2be35 
: doi align create  , 0x10000 
: dopu align create ( @p+;)  , 0x5555 , 0x0 
: dostk align create ( !p+dup-push!p+)  , 0xcdbe


: aa@ ( a-n)  do@ 1 +  ! do@  3  fet  1  exch @18 ;
: aa! ( na)  do! 1 +  !  do! 2 +  ! do!  4  ok  1  exch ;
: acall ( a)  0x10000  +
: ains ( w)  doi  ! doi  1  ok  1  exch ;
: apsh ( n)  dopu 1 +  ! dopu  2  ok  1  exch ;
: astk dostk  1  bstk  10  exch ;

( block 123 )
( this code supports boot node controlling one of its immediate neighbors directly.) these all begin with focusing call and each must return!

: port ( returns port for 0-3 rdlu ndx, then edges)
: wall ( is index for port between two nodes)
: 'wall ( vectors the active) wall ( definition)
: swall ( is standard) wall ( definition)


: doxxx ( port execution templates for target.)
: aa@ ( fetches from memory or port in target onto our stack here.)
: aa! ( stores a value from our stack here to port or memory in target.)
: ains ( executes an arbitrary instruction word which must end by returning.)
: acall ( executes a target word which must return or jump to ports.)
: apsh ( pushes a number onto target stack.)
: astk ( queries target stack nondestructively.)

( block 124 )
( - stream components) :var 'pth [0x4065c15]
: nstream ( an-n'w) swap  'pth  !  -2  + -if  0  pop drop ;  then ( pre)  2  ;
: ?path ( i-n)  'pth  @ + @ ;
: side ( n-a)  'pth  @ + dup @ swap  1  + @ wall port ;
: /hdr ( w-w) dup  -2  and  0  side  exec  /frame ( pre)  0  side  0x12000  + !18  -1  + dup  1  and drop if  0  side  0x10000  + !18 then  -1  + ;


: +pump ( nw-nw)  -8  + ( @p+b!@p+@p+)  0x4b17  !18
 0x1  side dup !18 dup  0x10000  + !18  0x12000  + !18
( !b!b.@p+)  0x9bb7  !18 ( w) dup  -1  + !18
( dup-push-if)  0x24861  !18 ( @p+!b.unext)  0x5bb4  !18 ;
: +load ( w n nb nd) push push ( @p+a!.@p+)  0x4ab7  !18 ( a) over !18 ( n)  -1  + !18 ( dup-push-if)  0x24861  !18
( @p+!+.unxt)  0x58b4  !18 pop pop +ram ;
: +post ( p @p+b!.@p+)  0x4bb7  !18  1  side !18  0  side !18 ( a!@p+push;)  0x2bdbd  !18 ( p) !18 ;

( block 125 )
( templates and load streams)
: 'pth ( current posn in path list of nodes.)
: nstream ( given addr of path tbl, nodes away, gives no of wire nodes and total stream length)
: ?path ( returns node number relative to current posn in selected path.)
: side ( gives adr of) $ 0 ( near,) $ 1 ( far side next node)
: /hdr ( starts a stream of given length; if odd, we leave out jump after waking 1st node.)


: +pump ( makes port pump thru next node; its ram load and init postamble must be out of w.)
: +load ( builds a program load from binary given node ram addr, word count, words to take from binary, and node number. caller must append any words not taken from binary.)
: +post ( follows a node's ram load to set b to out, a to in, and jump to) p.

( block 126 )
( - umbilical plumbing) :var 'foc [0x101979ea]
: using ( nn) wall port  vport  ! ;
: avail ( n-p)  1000  mod nn-n idle ;


: +path ( n'wn-n'w) dup  'pth  +! negate u+ ;


: unfoc ( -a)  'foc  assign  1  ?path avail ; unfoc 
: foc ( -a)  'foc  assign  0  side ;


: rip ( nw-nw)  0  u+ if ( post)  -5  + +pump  1  +path rip  -1  +path then  'foc  xqt +post ;
: rips ( an-n'w) nstream over  13  * +  5  + /hdr rip
: hose ( nw) drop drop 0 ?path 1 ?path using  wos  !frame ;


: wire ( nw-nw)  0  u+ if ( wire)  0x16 10 + negate  + +pump  1  +path wire  -1  +path ( wire) 0x0  0x16  dup  1602  +load  0  side +post ;  then ( last) 0x0  0x20  dup  -1  +  1603  +load  1  side  0x12000  + !18  0  side +post ;
: wires ( an-n'w) nstream over  18 ( lwire) 0x16 +  * +  10 ( llast) 0x20 +  + nop /hdr wire hose ;

( block 127 )
( this block creates and destroys umbilical wiring within the chip.)


: using ( sets) vport ( between given pair of nodes.)
: avail ( is idle pc val for given node. the initial mod is to support multichip ide.)


: +path ( steps) pos ( to,) neg ( away from target.)


: wires ( builds wire for path table)  a. ( entry zero is boot node.) n ( is number of nodes away from boot in path;)  $ 0 ( no uut,) $ 1 ( no wire, uut is meighbor,) $ 2 ( neighbor is last guy,) $ 3  n-2 ( wire nodes then last guy. generates call at end of last guy pgm that last guy sends target for focus.)
: rips ( rips out a wire built by) wire
: foc ( sets)  'foc ( to leave ripped wires focused on ide boot node;)  unfoc ( restores)  'foc ( to default.)

( block 128 )
( - routing control)
: targets ( -a)  act  @ align tbl  , 0tg , 1tg , 2tg 
: paths ( -a)  act  @ align tbl  here , 0pa , 1pa , 2pa : 'pths  0 + b-a  ;


: path ( i)  act  ! paths dup @ swap  1  + @ wall port  vport  ! ;
: node ( n)  3  for i  -1  + path paths targets @ + @ over or drop while next drop ;  then pop drop drop ;


: -hook ( i) path targets @  1  or drop if paths targets @ rips  1  targets ! then ;
: hook ( i n) swap -hook  2  begin over over paths + @ or drop while dup paths + @  0  + drop -if drop drop ;  then  1  + end then dup targets ! paths swap wires drop ;


: ?adj pop  1  + dup 4@ swap  4  + targets @ 1 or drop if push drop ;  then + push ;

( block 129 )
( these functions support route setup and selection for internal wiring.)


: targets ( table of target index variables.)
: paths ( table of route lists.)


: path ( selects active path)  i ( 0,1,2)
: node ( selects path whose target is node)  n


: -hook ( rips out any wiring on path)  i
: hook ( hooks up path)  i ( to node) n ( ripping out any old wiring on that path.)


: ?adj ( executes following word and exits defn if selected path is to adjacent node, otherwise skips following word.)

( block 130 )
( - target anywhere)
: dor! align create  , 0x12005 , 0x0 , 0x0 
: dor@ align create  , 0x12000 , 0x0 
: dori align create  , 0x1200a , 0x0 
: dorp align create  , 0x1200d , 0x0 
: dorst align create  , 0x12010 
: stak align create  40 rez


: r@ ( a-n) ?adj aa@  dor@ 1 +  ! dor@  2  fet  1  exch @18 ;
: r! ( na) ?adj aa!  dor! 1 +  !  dor! 2 +  ! dor!  3  ok  1  exch ;
: call ( a)  0x10000  +
: rins ( w) ?adj ains  dori 1 +  ! dori  2  ok  1  exch ;
: lit' ( n) ?adj apsh  dorp 1 +  ! dorp  2  ok  1  exch ;
: aupd astk
: @stk @18 ( s)  stak 1 +  ! @18 ( t)  stak  !  stak 2 +  8 for @18 over !  1  + next drop ;
: upd ?adj aupd dorst  1  stat  10  exch @stk ;
: lit lit' upd ;
: boot ( a n nd) nn-n swap push 2* 32768 + block over + swap begin over @  0x15555  or over r!  1  +  1  u+ next drop drop ;

( block 131 )
( these operations work on any target node.)


: dorx ( port templates for remote target.)


: r@ r! rins lit call ( are the specific names for the primitives using appropriate sequences for adjacent or remote target nodes.)


: boot ( loads code into current remote node from binary image for node)  nd ( from addr) a ( in both image and ram for) n ( words.)

( block 132 )
( - remote instructions)
: compile recompile ; : canon  138  ;
: focus paths targets @ + dup @ swap -1 + @ wall port call ;
: virgin paths targets @ + @ avail call ;


: rop ( n)  0xa  or  13  for 2* next ( ;s)  0x1555  + rins upd ;
: @b  0xa  rop ; : @a  0xb  rop ; : @+  0x9  rop ;
: !b  0xe  rop ; : !a  0xf  rop ; : !+  0xd  rop ;
: r+*  0x10  rop ;
: r2*  0x11  rop ; : r2/  0x12  rop ;
: r-  0x13  rop ; : r+  0x14  rop ;
: rand  0x15  rop ; : ror  0x16  rop ;
: rdrop  0x17  rop ; : rdup  0x18  rop ;
: rover  0x1a  rop ;
: ra!  0x1f  rop ; : ra@  0x1b  rop ;
: rb!  0x1e  rop ;


: up 0x145 ; : data 0x141 ; : down 0x115 ;
: left 0x175 ; : ldata 0x171 ; : right 0x1d5 ;
: io 0x15d ;

( block 133 )
( single instruction words that may be executed by the target. these must end with return for s40 restriction compliance.)

( the following won't work on s40 due to bug 1.)
: r@p+  0xc  rop ;
: psh ( n) r@p+ ( value) rins ;

( block 134 )
( indicator panel) 135 load ( node stack / upd)

( path, via, hops, tgt - green selected)

( mem dump / ?ram or ?rom)

( block 135 )
( code for panel)
: panel  134  list ;
: .s blu silver cr cr  stak 6 +  4 for dup @ 5 h.n space  1  + next  -5  + cr 6 for dup @ 5 h.n space  -1  + next drop ;
: ?color ( nn-nn) over over or drop if silver ;  then green ;
: .pth blu  act  @ cr 3 for cr i  -1  + path  act  @ ?color . paths dup  1  + @ . targets @ dup . + @ . next path ;


: /ram align create  64 a-b rez 
: rsp ( n dup) 1 and drop if sp/2 then ;
: .ram blu silver cr  /ram  64 for i  7  and ?zero drop if cr space then i rsp dup @ 5 h.n i 1 and drop if space then  1  + next drop ;

( block 136 )
( - tester)
: ent 0 ;
: n6tst 0 64 6 boot ent call 0 r@ dup 123 + dup 0 r! 0 r@ or if abort then drop 0 r! ( upd) ;
: rot ( n-n)  0x3ffff  and 2*  0x40000  /mod + ;
: sto ( n) dup  63  for rot dup i r! -next drop
 63  for rot i r@ over over or
     drop if i abort then drop -next drop ;
: pat ( n)  18  for dup sto rot next drop ;
: ramtst 0 sto 0x3ffff sto 1 pat 0x3fffe pat ;
: one ( n)  2  swap hook pause ( n6tst) ramtst ;
: ?ok ( n-t)  2pa @ nn-n  or ;
: all ( n) nn-n  1  + for i  -1  + ?ok drop if i  -1  + n-nn one then next ;
: !dac ( n i) 2 swap hook 0x155 or io r! ;
: !dacs ( n) dup 709 !dac dup 713 !dac dup 717 !dac dup 617 !dac 117 !dac ;
: nn ( n-n) -1 + dup !dacs ;
: ms 100000 * for next ;
: watch begin upd pause 1000 ms key? end ;
: ?ram 0 : suck ( a) ra@  /ram  64 for over r@ over !  1  +  1  u+ next drop drop ra! ;
: ?rom  0x80  suck ;

( block 137 )
( this test routine tester loads and runs the code compiled for node 6 on all other nodes except the root, stopping if a node crashes or, possibly, other failure criteria are met)


: one ( runs the test routine from node 6 compilation, entry point) ent ( , on node)  n ( . aborts if we cannot write and read back memory.) select desired path at start. 
: all ( tries the test starting with node n and going down to node zero, skipping node 19.)


: watch ( displays live stack from current node. this and other interactive functions can be enabled in a running program by placing a definition like this in outer loop...)
: poll @b 0x200 and if up b! @b push ;' 0x15d b! then drop ;


: !dac ( sets given output value in node i)
: !dacs ( sets given value in all dacs.)

( block 138 )
( - canonical words)
: -canon remember
: @ ( a-n) r@ ;
: ! ( na) r! ; ( call lit upd rins boot !b already ok)
: +* r+* ;
: 2* r2* ;
: 2/ r2/ ;
: - r- ;
: + r+ ;
: and rand ;
: or ror ;
: drop rdrop ;
: dup rdup ;
: over rover ;
: a! ra! ;
: a ra@ ;
: b! rb! ;

( block 139 )
( the final step in loading the ide is to redefine the canonical forth words to operate on the target node. this is done as a separate step so that you may define any sort of exerciser before losing access to host colorforth words.)

( block 140 )
( - ide ats support)
: zxch ( w n f n) push push dup ( 0x2 ) ( +) ( -2 ) ( and)  vport  @ pop /frame ( vport @) ( 0x12000 ) ( + !18 dup -) ( 0x1 ) ( and drop if vport @) ( 0x10000 ) ( + !18 then) +frame  wos  !frame pop inser -stream ;


: dox align create ( @p call)  , 0x56a9 ( arg) , 0x0 
: xchg ( cmd arg - result)  dox 1 +  !  dox  ! dox  0x2  fet  1 ( exch)  zxch @18 ;


: pfocus paths targets @ + dup @ swap -1 + @ wall port dup call lit rb! ;
: vtest ( arg.ent-ans) 0x5600 or swap xchg ;
: test ( arg-ans) 0x4 vtest ;
: tfocus ( port) 0x5636 swap  0x10000  + xchg drop ;
: creep 0x563a  67  xchg drop ;
: rip 0x5602 0x20000 xchg drop ;


: zfocus ( node) paths targets @ + @ wall port
0x10000 or dup dup r! 0x5636 over r! dup dup r!
lit' ra! ;

( block 141 )
( this block interchanges ats commands with any node adjacent to the ide boot node.)


: pfocus ( must be used after booting package into an adjacent node and before using the following words. focuses that node properly on the boot node with both) p ( and) b ( -)  note! after pfocus regular ide functions may not be done against nodes in this path until  rip  has restored them to  warm  state.


: tfocus ( performs ats focus function to select port thru which test and creep operate. use ide port names.)
: test ( executes test w/)  arg ( giving positive) ans. 
: creep ( creeps into focused node, making it active and changing current active to wire.)
: rip ( tears out ats connection to active node returning it and all wire nodes to warm states.)

: zfocus ( used by hand in ide to effectively tfocus the ide node under test on a given tgt node)  works whether or not r! preserves a

( block 142 )
( - all-nodes tester)
: fwall ( -n) paths targets @ + dup @ swap  -1  + @ wall ;
: fport ( -a) fwall port ;
: fbit ( -n) fwall align tbl
( r)  , 0x8000 ( d) , 0x2000 ( l) , 0x800 ( u) , 0x200 
: nodes ( -n) 0 begin  1  +
dup paths +  1  + @  0  + drop -until paths @
over paths + @ or drop if ;  then  -1  + ;
: !one ( i)  2  path 2 swap paths + @ hook
0 64  1604  boot fbit 2 r! ( 6 ) 14 call ;
: !all  2  path nodes ( 40 ) for pause i !one next ;
: ?one ( i-f)  2  path 2 swap paths + @ hook pause
0x3e r@ ( 0x1e100 ) 0x8d00 or 0x3f r@ ( 0x17d ) 0x430e or +or drop if upd ?ram 0 dup or drop ;  then 1 dup and drop ;
: ?all  2  path 0 nodes ( 40 ) for 1 + pause dup ?one while next drop ;  then pop drop ;
: zz for i next ;
: z 1 ?one upd ;

( block 143 )
( manage running a test in all nodes)
: fwall ( returns rdlu for feeding node)
: fport ( returns port from feeding node.)
: fbit ( returns io mask bit for feed node write.)
: nodes ( returns number of nodes in current path.)
: !one ( programs and starts the node whose index is given in 1..nodes)
: !all ( programs all nodes in the current path.)

( block 144 )
( arrayforth tm and okad tools and designs)
( copyright 2009-2012 greenarrays, inc.)
:var cuco [0x5] :var testb :var dh 0 dh !
:var first [0xffffffff] -1 first ! :var orgn 0 orgn ! 
: compile  146  load ;
: recompile compile  orgn  @ load lis ;
: softsim : so  148  load ;


: -nat winver drop if ;  then exit ;
: tbl ( i-n) pop 2/ 2/ + @ ;
: xqt ( a) @ push ; : assign ( a) pop swap ! ;
: ray ( i-a) pop 2/ 2/ + ;
: aray ( n) [compile] align call ray  4  *  h  +! ;

( ascii file names) 74 load
( png screen capture) 168 load
( qx) 80 load ( stack) 94 load 
: -tape  1  1 and ; ( for redacted systems)

( chip design) 190 3 loads mark empty
( okad tools) ( 198 ) ( load) ( 900 ) ( load)

( block 145 )
( main load block for okad2 applications)
: testb ( nonzero to enable testbeds.)
: dh ( holds drive handle we are responsible for.)
: first ( execution of hardsim or softsim. initializes variables in either.)
: recompile ( compiles f18 code then reloads tool that depends on it like ide from load block in) orgn.
: compile ( compiles relevant f18 code.)


: -nat ( exits a block if running on native system)
: tbl ( self fetching cell array. usage...)
: squared ( i-n) align tbl  0 , 1 , 4 , 9 , 16 , 
: xqt ( calls the code whose adr is in the var given.)
: assign ( places addr of following code in the location given and exits current definition.)


: ray ( defines i-a array usage) align ray
: aray ( use after red to make ray of n cells)

( block 146 )
( f18 compiler) empty c
0 0 laid nns fill 0 0 kinds nns fill

1400 load


: reset ( a) ?rst  com  @ resets ! ;
: kind ( n)  com  @ kinds ! ;
: node ( nn) nn-n nns mod dup  com  ! 0 -org
node's 64 eras n-nn @rom load ;
: bin ( nn) 0 memory swap nn-n  com  ! 0 memory 64 move ;


: program  nns -1 +  for i  com  !
i idle reset i n-nn @rom load -next
( special rom's)  1304  load
-tape drop if  150  load then ;

1402 6 loads target 1380 load host  :: h' ' ; :: ' h' 6 + 4@ ; :: reclaim remember  target program empty

( block 147 )
( compiles all relevant f18 code.)


: laid ( is cleared for setting as nodes laid out)
: resets ( is set to default multiport executes for all nodes and may be overridden in source code using) reset
: kinds ( is set to default testbed none and may be overridden with) kind ( to 0-none 1-async 2-sync 3-1wire 4-spi 5-strap 6-serdes 7-servers)
: node ( starts random compilation for node)  nn ( by compiling node) nn's ( rom)
: bin ( saves the binary just generated in the bin for node)  nn, ( which must be outside chip) ( 0 ) ( 0 ) ( .)
: program ( compile code for multicomputers. always compiles standard rom; if not tapeout, the load block at) ( 1300 ) ( defines test environment which may be in rom, ram, or both.)
: reclaim ( remembers and restores dictionary)

( block 148 )
( f18 software simulator) empty compile ( demo bootstream) 1242 load empty ( prelude) 1250 load ( boot descriptors) 1236 load ( engine) 1252 8 loads ( opcodes) 1268 4 loads ( boot loader) 1238 load ( display) 1276 6 loads 1248 load 1288 2 loads ( preserve variables) :var nmem :var n2mem
: nm2m  nod2  @ !node  n2mem  @ mem !  nod  @ !node  nmem  @ mem ! ; :var big [0x64]
: puka ( nn-a) nn-n 2* 0x8000 + block ;
: code ( nn nn) puka push puka pop 64 move ; ( keyboard) 1292 2 loads ( ports and pins) 1296 2 loads ( interactive) 1240 load
: /softsim 0  time  ! power  first  @ 1 + if drop nm2m ;  then ( 0 )  first  ! 100  big  ! 1  gap  ! -1  wind?  !  100  !node  0  mem !  100  other  0  !node  0  mem !  0  node 0  xo  ! 0  yo  ! !vis ; ( init and testbeds) 216 load ( start) /softsim ok h

( block 149 )
( comment demo bootstream if you are going to be generating your own for simulation.)

( block 150 )
( test code for chip) reclaim

( ide parts) 1372 5 loads reclaim
( all nodes) 1350 load reclaim

( ats tests) 480 load reclaim

( polyforth) 360 load reclaim
( eforth) 1080 load reclaim

( applic code) 200 load



( block 151 )
( this block defines what)  compile ( does.)
( the system code loaded at the start is used by common development tools and should generally be left alone. it goes into bins 1600..2317 as follow)

( 1600 ) ( ide code code; spi r/w/boot) ( 1700 ) ( polyforth) ( 1800 ) ( ---; temp sram for eforth.) ( 1900 ) ( ats/ide; ---) ( 2000 ) ( creeper modules) ( 1 ) ( full) ( 2100 ) ( creeper modules) ( 2 ) ( full) ( 2200 ) ( creeper modules) ( 3 ) ( half) ( 2300 ) ( creeper modules) ( 4 ) ( reserved) ( note that special rom leaves residue in 008 and 106.)

( block 152 )
( redact okad disk) audit load

( to arm this block, make)
( this word white...) exit

( okad) 196 1244 obliterate

( type save to commit changes)

( block 153 )
( load this block to redact an okad disk for public release or extensive programming.)

 additional housekeeping...
 144 ( comment loading of okad application.)
18 ( uncomment loading of application tools.)
196ff ( merge in released pd software.)

( block 154 )
( c-a-c - ascii for gds only!) macro 
: 1@ 0x8a 2, ; forth 
: string pop ;
: cf-ii string  , 0x6f747200 , 0x696e6165 , 0x79636d73 , 0x7766676c , 0x62707664 , 0x71757868 ( 336a7a6b) , 0x33323130 , 0x37363534 ( 2d313938 - 2d7a3938) , 0x5f7a3938 ( 2f322e30) , 0x2f6a2e6b ( 2b213a3b) , 0x24213a3b , 0x3f2c2a40 
: ch 0xfffffff0 and unpack  cf-ii  + 1@ 0xff and ;
: ii-cf string  , 0x2a00 ( 0 +) , 0x2b , 0x2b2d0000 , 0x2725232e ( zjk 1b262224) , 0x1b1a1918 , 0x1f1e1d1c , 0x28292120 , 0x2f000000 , 0x3a43355c , 0x3d3e3440 ( 02 484a3744 kj) , 0x54523744 , 0x3336393c , 0x38314742 , 0x3f414632 ( 1 493b45 z) , 0x563b45 ( -) , 0x23000000 , 0xa13052c , 0xd0e0410 ( 02 181a0714 kj) , 0x24220714 , 0x306090c , 0x8011712 , 0xf111602 ( 1 190b15 z) , 0x260b15 
: chc 0xffffffe0 +  ii-cf  + 1@ 0xff and ;

( block 155 )
( colorforth to/from ascii w/gds specifics)


: cf-ii ( otr inae ycms wfgl bpvd quxh)
     ( 3210 7654 -j98 /z.k +!'; ?,*@)
: ii-cf ( ! +* /.-, 3zjk 7654 ;'98 ?)
     ( cba@ gfed 02ih onml srqp wvut)
     ( 1yx cba@ gfed 02ih onml srqp wvut 1yx)
: notice  j and z transposed in cf-ii; - converts to underscore, + to dollar.

( block 156 )
( big letters) macro 
: *byte 0xc80f 2, ; forth 
: clr  aper 2 +  ; :var sz [0xe] :var cur [0x552400] 14 sz ! 
: ptab ( xy) 1024 * +  aper @ 4 /  +  cur  ! ;
: center ( n)  sz  @ -24 * 768 + 2/ ptab ;
: table 12 *  12 block  + ;
: 1line ( a)  sz  @ for  clr  @ over ! 1 + next drop ;
: pix ( a)  sz  @ for dup 1line 1024 + next drop ;
: row ( an-an) 16 for dup and -if over pix then  sz  @ u+ 2* next 1024  sz  @ *  sz  @ -16 * + u+ ;
: !emit table  cur  @ 12 for over @ *byte row row drop 1 u+ next drop drop  sz  @ 18 *  cur  +! ;
: !digit 24 + !emit ;
: 2. ( nn) /mod !digit !digit ;
: 4. ( n) 100 /mod 10 2. 10 2. ;

( block 157 )


( block 158 )
( big clock) empty 40 load 156 load 
: hm sec 60 /
: sex ( n) 60 /mod 100 mod 10 2. 10 2. ; :var t0 [0x7eca]
: ?beep if ;  then beep ;
: till  t0  @ sec negate + green -if negate red then ?beep sex ;
: set ( n) 60 * sec +  t0  !
: ok show black screen blue 0 center hm ( till) ;
: run dup pause drop key? run ; ok run

( block 159 )


( block 160 )
( compare) empty 30 load 
: n18 ( i-a)  abuf 18 + block  + ;
: unpk abs  1 n18  !  abuf 36 +  block  cbuf  block  1404  blks move  cbuf block  abuf 36 +  3 n18  @  -36  + range ;
: check  abuf  @back  0 n18  @  18 block @  or drop if ;  then  1 n18  @ dup and -if unpk ;  then drop ;
: blink dup  abuf  +  blk  ! edit ;
: var push push 1 + 1 u+ pop pop
: *1 or ;
: *2 var push over @ over @ or pop + ;
: tag ( nn-n) dup 0xf and jump *1 *1 *2 *1 *1 *2 *1 *1 *1 *1 *1 *1 var *1 *1 *1
: co ( naa-n) 256 for over @ over @ tag drop if drop drop pop drop pop drop dup 2 u+ ( i) pop swap blink ;  then 1 + 1 u+ next drop drop ;
: com ( n) dup block over  abuf  + block co ;
: q ( nn) for com 2 + next drop ;
: all 18  1439 -18 + 2/  q ;
: old  blk  @  abuf  mod dup  abuf  +  blk  ! copy ;

( block 161 )

: check ( reads backup to) ( 3000 ) ( and decompresses if appropriate)
: blink ( displays the given block with its other set as the editor's 'other' block)
: var ( compares a variable name, advancing pointers to skip its value.)
: *1 ( compares garden variety words.)
: *2 ( compares large literals.)
: tag ( compare compares the two source cells given, returning true if they differ. ignores variable differences.)
: ?nul ( ends the loop in co when nuls are found in both blocks.)
: co ( given the addresses of the two blocks does the work of com.)
: com ( invokes editor to blink the given block if it differs from the other, leaving stack set to continue the scan by typing q. otherwise returns.)
: all ( scans the whole usable area of the disk.)
: q ( scans for differences given starting block and number of source blocks skipping shadows.)
: note! ( return stk probably grows!)

( block 162 )


( block 163 )


( block 164 )


( block 165 )


( block 166 )


( block 167 )


( block 168 )
( png empty) -nat :var w [0x400] :var hh [0x300] :var d [0x1]
: frame ( 0x1d0000 )  aper @ 4 /  ; 172 load 174 load 
: -crc ( a) here over negate + crc .. ;
: here/4 ( -a) here 3 and drop if 0 1, here/4 ;  then here 2 2/s ;
: bys ( nn-b) .. here swap , ;
( pallettes) 170 load


: !png ( awh-an)  d  @ /  hh  !  d  @ /  w  ! here/4 swap 0x474e5089 , 0xa1a0a0d , ( ihdr) 0x52444849 13 bys  w  @ ..  hh  @ .. 0x304 , 0x0 1, -crc ( plte) pallette ( idat) 0x54414449 0 bys swap deflate -crc ( iend) 0x444e4549 0 bys -crc here/4 over negate + ;


: 'at ( xy-a) 1024 * +  frame  + ;
: full 1  d  ! 0 dup 'at 1024 768 !png ;
: png full wgds ;

( block 169 )

: d ( is reduction factor)

( block 170 )
( - pallettes)
: paper 0x45544c50 48 bys
0xffffff 3, 0xc00000 3, 0xc000 3, 0xc0c000 3,
0xc0 3, 0xc000c0 3, 0xc0c0 3, 0x404040 3,
0xc0c0c0 3, 0xff0000 3, 0xff00 3, 0xffff00 3,
0xff 3, 0xff00ff 3, 0xffff 3, 0x0 3, -crc ;


: crt 0x45544c50 48 bys
0x0 3, 0xc00000 3, 0xc000 3, 0xc0c000 3,
0xc0 3, 0xc000c0 3, 0xc0c0 3, 0x404040 3,
0xc0c0c0 3, 0xff0000 3, 0xff00 3, 0xffff00 3,
0xff 3, 0xff00ff 3, 0xffff 3, 0xffffff 3, -crc ;


: pallette ( paper) crt ;

( block 171 )


( block 172 )
( - crc) :var ad1 [0x6ca8] :var ad2 [0x529a] macro


: 2/s ?lit 0xe8c1 2, 1, ; : 1@ 0x8a 2, ; forth 
: bit ( n-n) 1 ? if 1 2/s 0xedb88320 or ;
      then 1 2/s ;
: ,crc ( nn) for dup 8 for bit next ,
     1 + next drop ;
: table ( -a) align array  0 256 ,crc 
: crc ( bn-n) -1 swap for over 1@ over or 0xff and table swap 8 2/s or 1 u+ next - nip ;


: +adl ( n) 0xff and  ad1  @ + dup  ad2  @ +
: adl!  ad2  !  ad1  ! ;
: +mod  ad1  @ 65521 mod  ad2  @ 65521 mod adl! ;

( block 173 )

: 2/s ( shift right by literal)
: 1@ ( fetch byte, address in eax)
: array ( return word address in dictionary)
: bit ( process 1 bit with standard 32-bit crc)
: fill ( construct crc table for bytes)
: table ( said table)
: crc ( compute crc for a byte string)
: ad1/ad2 ( adler checksums)
: +adl ( add a byte to both checksums)
: adl! ( store checksums)
: +mod ( truncate checksums)

( block 174 )
( - lz77) macro : *byte 0xc486 2, ;
: !bx [compile] a! 0x289 2, [compile] drop ; forth


: *bys dup 16 2/s *byte swap 0xffff and *byte 0x10000 * + ; : .. *bys , ;
: 0/1 0x80 ? if 0x7e and 0x7e or drop if 7 ;  then 0xf ;  then 0 and ;
: 4b dup 0/1 0x9 and over 8 2/s 0/1 0xa and +or swap 16 2/s 0/1 0xc and +or ;
: pix dup @  d  @ u+ 4b ;
: row 1, dup  w  @ 2/ dup 1 + dup 2, - 2, 0 dup 1, +adl for pix 16 * push pix pop or dup 1, +adl next drop +mod  d  @ 1024 * + ;


: deflate 0x178 2, 1 0 adl!  hh  @ -1 + for 0 row next 1 row drop  ad2  @ *byte 2,  ad1  @ *byte 2, here over 4 + negate + *bys over -4 + !bx ;

( block 175 )

: 0/1 ( 0, f or 7 for dark, bright or dim)

( block 176 )
( cf-html) empty -nat
:var pad [0x109e4000] abuf block 4 * pad !
:var hld [0x10b54c81] pad @ hld ! 178 6 loads 
: estyle ,link ,t1cr ( cfhtml.css '?) ;
: .hdr  pad  @  hld  ! ,t1cr ( @html? @head?) istyle
( estyle) ,t1cr ( @/head? @body? @table?) ;
: .blk ( n) 0  pos  ! crlf ,t1 ( @td*class+cf?)
dup even? if dup .dec ,t1cr ( *list) then
.cr block ,t1 ( @code) 0  class  ! 0  --cr  !
begin @+ dup and while .token end then
 class  @ eq? if ,t1 ( ?) then drop drop
begin -eol? while .nb end then .cr
,t1 ( @/code?) .cr ,t1cr ( @/td?) ;
: .sep ,t1 ( @td?) .nb .nb ,t1 ( @/td?) ;
: .blks ( first last+2) over negate + 2/ for
,t1 ( @tr?) dup 1 or .blk .sep dup .blk
,t1cr ( @/tr?)  2  + next drop ;
: .tlr ,t1cr ( @/table? @/body? @/html?) sav ;
: run ( first last+2) .hdr .blks .tlr ;

named ( cf.html) exit 18 1440 run

( block 177 )
( colorforth to html utility)

( the html is created between) pad ( and) hld
( by)  .html ( and its factors) .hdr .blks ( and) .tlr ( , then written to the file last)  named ( .)

( uncomment)  estyle ( in) .hdr ( to use an external)
( stylesheet, maybe for printing.)

( pairs of blocks are formatted 2-up using html tables, with the odd/even blocks used to invoke)  .html ( or) .blks ( displayed on the right. 'n list' is shown above the even block.)

176 188 .html ( puts shadows on left, while)
177 189 .html ( puts them on the right.)

seeb ( toggles blue-word visibility.)

( the last line of each block is filled)
( with)  nbsp ( for column alignment. the)  class  @
( line closes the) [compile] code ( tag of an empty block.)

( block 178 )
( - generate html details)

: eq? ( nn-n) over or if drop -1 then - ( nz? ;)
: nz? ( n) dup and drop ;
: even? ( n) 0x1 or 0x1 and drop ;


: @+ ( a-an) dup 1 + swap @ ;
: @tag ( a-at) dup @ 0xf and ;


: sc 0x3b ( semicolon)
: ch, ( c)  hld  @ 1! 1  hld  +! ;
: lb 0x7b ( left-brace) ch, ;
: rb sc 0x7d ( right-brace) ch,
: crlf 13 ch, 10 ch, ;


: ,token ( n) ch if ch, ,token ;  then drop drop ;
: ,word ( a-a) begin @+ ,token @tag drop until ;
( loop)  begin ,word
: ,comments ( a) @tag 9 or drop until drop ; macro

: ,t ( words) 7push pop [compile] ,lit call ,comments nop ;
: ,trb ( words) [compile] ,t call rb nop ;
: ,t1 ( words) call set1 [compile] ,t call set0 nop ;
: ,t1cr ( words) [compile] ,t1 call crlf nop  forth

( block 179 )

: eq? : nz? : diff? : even? ( leave only flags)

: @+ : @tag ( are common factors)

( the following words generate ascii text only for html tags and source formatting; it will not be visible in the html display.)


: sc : ch, : lb : rb : crlf ( punctuation output)

( the macros enable in-line output from the)
( standard cf-ascii table using)  set0 ( default or the extended table using) set1


: ,token ( output ascii characters for one token)
: ,word ( output a token and any extension tokens)
: ,comments ( output contiguous comment words)


: ,t ( output from current set, don't change set.)
: ,trb ,t ( output followed by) rb
: ,t1 ( output from) set1 ( , return to) set0 ( at end)
: ,t1cr ,t1 ( output followed by) crlf

( block 180 )
( - translate text and numbers) :var pos :var --bs [0x1]
: -bol?  pos  @ nz? ;
: -eol?  pos  @ 46 or drop ;
: .cr ,t1 ( @br?) 0  pos  ! ; ( loop)  begin .cr
: emit ( c) ch, 1  pos  +! ;
: .ch ( c) -eol? until emit ;
: .sp -eol? if -bol? if 0x20 emit ;  then then ;
: .2sp .sp
: .nb 0x26 ( ampersand) .ch ,t ( nbsp) sc ;
: ?sp  --bs  @ nz? if .sp then 1  --bs  ! ;
: -sp 0  --bs  ! ;
: .sp.tn ( n) ?sp ( .tn ;)
: .tn ( n) ch if .ch .tn ;  then drop drop ;
: ?ch ( n) ?seeb if .ch ;  then drop .nb ;
: ?sp.tn ( n) ?sp ( ?tn ;)
: ?tn ( n) ch if ?ch ?tn ;  then drop drop ;
: .hd ( n)  -10  + -if  0x3a  + .ch ;  then  0x41  + .ch ;
: .dec ( n .sp) ?sp  0  + -if 0x2d .ch negate then  -1  swap begin  10  /mod dup and while end then drop
: spit ( -1 ...) begin .hd  0  + -until drop ;
: hd ( n-nn) dup  0xf  and swap 2/ 2/ 2/ 2/ ;
: .hex ( n .sp) ?sp  -1  swap begin hd 0xfffffff and while end then drop spit ;
: .ad/s ( n) 1024 /mod swap hd hd hd drop ?sp dup and if dup .hd then drop .hd .hd  0  + if  47  .ch dup .hd then drop ;

( block 181 )
:var pos ( character display) pos ( ition in line)
: -bol? : -eol? ( test position)
: .cr ( visible crlf)
: emit ( visible character)
: .ch : .sp : .2sp : .nb ( quirky characteristics)
[compile] note  .sp ( does nothing at left margin)
[compile] note .ch ( does) .cr ( after 46th character)
[compile] note .2sp ( takes only one space at left margin)
[compile] note .nb ( takes only one character position.)


: .tn : .sp.tn ( display a token.)


: .hd : hd : spit ( are number-output factors)
: .dec : .hex : .ad/s ( display numbers)

( block 182 )
( - translate cf token details)
:var class [0x2d200009] :var --cr
: ,class ( a) @  class  @ over or drop ( diff?) if
 class  @ nz? if ,t1 ( @/code? @code) then
,t1 ( *class+) dup  class  ! ,token ,t1 ( ?) ;
 then drop ; macro 
: ,c 7push pop [compile] ,lit call ,class nop ; forth 
: .quirks ( n)  --bs  @ -1 + nz? if 1  --bs  ! drop ;  then  --cr  @ nz? if .2sp drop 0  --cr  ! ;  then ( class) nz? if -bol? if .cr then then ;
: .space -eol? if .nb then ;
: .indent .cr ( 4 ) 2 for .nb next ;
: .blue ( n) ?seeb if dup .sp.tn then 0x9080000e ( cr) eq? if .cr drop ;  then 0xe721000e ( -cr) eq? if 1  --cr  ! drop ;  then 0x8625920e ( space) eq? if .space drop ;  then 0x76c08c4e ( indent) eq? if .indent drop ;  then 0xc620000e ( br) eq? if .cr .cr then drop ;
: ?simple ( n-n) 0xfc00000e eq? if ?tn .cr pop drop ;  then 0xfa00000e eq? if ?tn -sp pop drop ;  then 0xea00000e eq? if ?sp.tn -sp pop drop ;  then 0xebd4000e eq? if ?sp.tn -sp pop drop ;  then 0xebd7a80e eq? if ?sp.tn -sp pop drop ;  then ;

( block 183 )
:var class ( current class)
:var --cr ( true suppresses) cr ( before next red word)

: ,class : ,c ( class defining words, cf style)


: .quirks ( handle the spacing before red words)


: .space ( blue spaces are ignored at eol!)
: .indent ( 4 ) ( + html leading space)


: .blue ( generate most of the blue-word effects)

( block 184 )
( - translate cf tokens)
: sh? ( n-n) 2/ 2/ 2/ 2/ dup 2/ swap 1 and drop ;
: lh? ( an-an) push @+ pop 0x10 and drop ;


: .t1 ( n) ,c ( t1) .sp.tn ;
: .t2 ( an-a) lh? if ,c ( h2) .hex ;  then ,c ( d2) .dec ;
: .t3 ( n)  class  @ ,c ( t3) .quirks ( .sp.tn) .tn ;
: .t4 ( n) ,c ( t4) .sp.tn ;
: .t5 ( an-a) lh? if ,c ( h5) .hex ;  then ,c ( d5) .dec ;
: .t6 ( n) sh? if ,c ( h6) .hex ;  then ,c ( d6) .dec ;
: .t7 ( n) ,c ( t7) .sp.tn ;
: .t8 ( n) sh? if ,c ( h8) .hex ;  then ,c ( d8) .dec ;
: .t9 ( n) ,c ( t9) .sp.tn ;
: .ta ( n) ,c ( ta) .sp.tn ;
: .tb ( n) ,c ( tb) .sp.tn ;
: .tc ( an-a) ,c ( tc) .sp.tn ,c ( dc) @+ .dec ;
: .td ( n) sh? ,c ( hd) .ad/s ;
: .te ( n) ,c ( te) ?simple .blue ;
: .tf ( n) sh? if ,c ( hf) .hex ;  then ,c ( df) .dec ;


: .token ( an-a) dup 0xf and jump
.tn .t1 .t2 .t3 .t4 .t5 .t6 .t7
.t8 .t9 .ta .tb .tc .td .te .tf

( block 185 )

: sh? ( extract short number, true flag if hex)
: lh? ( extract long number, true flag if hex)

( tag ------- cf class ------- html class)
[compile] .t0 ( extension token ........) [compile] same [compile] as [compile] last
: .t1 ( execute word ...........)  t1
: .t2 ( execute long number ....)  h2, d2 
: .t3 ( define word ...........) : t3
: .t4 ( compile word ...........) t4
: .t5 ( compile long number ....) h5, d5
: .t6 ( compile short number ...) h6, d6
: .t7 ( compile macro ..........) [compile] t7
: .t8 ( execute short number ...)  h8, d8 
: .t9 ( lowercase text comment . t9)
: .ta ( capitalized text comment ta) [compile] deprecated
: .tb ( uppercase text comment . tb) [compile] deprecated
: .tc ( variable ...............) :var tc dc
: .td ( target address ......... hd)
: .te ( editor command .........) [compile] te
: .tf ( short number comment ... hf, df)


: .token ( translate tag-by-tag)
     [compile] note ( address may be incremented)

( block 186 )
( - stylesheet details and file output)
: vat ,t ( *vertical-align; top) sc ;
: bcw crlf ,t ( *background-color; white) sc ;
: wsn crlf ,t ( *white-space; nowrap) sc ;
: fo ,t ( *font-) ;
: ffm crlf fo
     ,t ( family; lucida*console,monospace) sc ;
: fwb crlf fo ,t ( weight; bold) sc ;
: fz fo ,t ( size;) ;
: fc lb ,t ( *color;) 0x23 ( sharp) ch, ;
: fsi sc fo ,t ( style; italic) rb ;
: tt sc ,t ( *text-transform;) ;


: ,link ,t1 ( @link *rel+stylesheet)
     ,t1 ( *type+'text/css' *href+') ;


: fopen ( af-h) push push 0 32 ( exist) 2 0 0
     pop pop swap fcreate ;
: sav  0 fnam  w/o fopen dup push
      pad  @ dup negate  hld  @ + pop
     fwr drop fclose ;

( block 187 )

: vat : bcw : wsn : fo : ffm : fwb : fz : fc : fsi : tt
( space-saving factors of internal stylesheet)


: ,link ( most of the external stylesheet link)


: fopen : sav ( open, write, close html file)
[compile] note ( byte addresses throughout)

( block 188 )
( - internal stylesheet)
: istyle ,t1cr ( @style*type+'text/css'?) set1
,t ( td) lb vat bcw wsn ffm fwb fz ,trb ( x-large) ,t ( code) lb fz ,t ( large) tt ,trb ( lowercase)
,t ( .t1) fc ,trb ( ddaa00)
,t ( .h2) fc ,t ( aa7700) fsi
,t ( .d2) fc ,trb ( ddaa00)
,t ( .t3) fc ,trb ( ff0000)
,t ( .t4) fc ,trb ( 00cc00)
,t ( .h5) fc ,t ( 009900) fsi
,t ( .d5) fc ,trb ( 00cc00)
,t ( .h6) fc ,t ( 009900) fsi
,t ( .d6) fc ,trb ( 00cc00)
,t ( .t7) fc ,trb ( 00cccc)
,t ( .h8) fc ,t ( aa7700) fsi
,t ( .d8) fc ,trb ( ddaa00)
,t ( .t9) fc ,trb ( 444444)
,t ( .ta) fc ,t ( 000000) tt ,trb ( capitalize)
,t ( .tb) fc ,t ( 000000) tt ,trb ( uppercase)
,t ( .tc) fc ,trb ( ff00ff)
,t ( .dc) fc ,trb ( 00ff00)
,t ( .hd) fc ,t ( bbbbbb) fsi
,t ( .te) fc ,trb ( 0000ff)
,t ( .hf) fc ,t ( 777777) fsi
,t ( .df) fc ,trb ( 444444) ,t1cr ( @/style?) ;

( block 189 )

: istyle ( internal styles are aimed toward)
( providing code examples for stand-alone use in other documents. although it's black-on-white, it faithfully displays the colorforth screen.)

( some cf-html rendering tests)

 load 2147483647 0x80000000 
: t1 ;  2147483646 0x80000001 87 0x57 [compile] ?lit  87 0x57 ( rtoeani rtos ascii) :var var [0x7b]
: quirky ( 0x5 )
     ( 87 ) ( 0x57 )  -87 ( end) 0x0  0x0 ( 0x0 )

( block 190 )
( ga144 chrt .18 design specific)
: gdsnos  440  ;
: nnx ( 8 )  18  ; : nny ( 4 )  8  ; : nns  nnx nny *  ;
: nnc ( nns)  nns 2 * 144 +  ;
: nn-n ( n-n) ( 10 )  100  /mod  nnx  * + ;
: n-nn ( n-n)  nnx  /mod ( 10 )  100  * + ;


: gapl  2 ( strap) 5 + ( pwr) 0 + ( chans) 20 2 * +  ;
: gapr  2 ( strap) 5 + ( pwr) 0 + ( chans) 24 2 * +  ;
: gapb  2 ( strap) 5 + ( pwr) 0 + ( chans) 28 2 * +  ;
: gapt  2 ( strap) 5 + ( pwr) 0 + ( chans) 18 2 * +  ;
: ray0 ( -xy) gapl  199  + gapb  199  + ;
: rayn ( -xy) nnx  350  * nny  759  * -1 + ray0 v+ ;


: gx  rayn drop gapr + 199 +  ;
: gy  rayn nip gapt + 199 +  ;


: origin ( 164 ) ( 89 ) 26 26 ;
: cx  origin drop 2 * gx + 2 +  ;
: cy  origin nip 2 * gy + 2 +  ;
: -cx  cx negate  ; : cx*y  cx cy *  ;


: gfx  8  ; : gfy  16  ;

( block 191 )

: gdsnos ( block for gds layer numbers)
: nnx ( and nny number of nodes/row and /column)
: nnc ( number of nodes compiled)
: nn-n ( and) n-nn ( convert yx notation to and from linear node numbers)
: gapl, r, b, t ( distance in tiles between inner edge of padring bus and outer edge of core pwr)
: ray0 ( and) rayn ( are gxy relative phys origin and upper right corner of node array. source of constants is)  xtab ( and) ytab. 
: gx ( and) gy ( bounds of pad ring.)  always remember to check  global  reset wiring when size or placement of node array or pad ring are changed! 
: cx ( and) cy ( bounds of seal ring.)
: -cx ( negative tiles/row)
: origin ( origin of 'die' i.e. pad ring within seal ring. c coords rel to seal; g rel to 'die')
: gfx ( and) gfy ( fill cell grid)

( block 192 )
( ga144 pads, ports and resets)


: port ( i-pa) align tbl  , 0x1d5 , 0x115 , 0x175 , 0x145 , 0x195 , 0x185 , 0x1b5 , 0x1a5 
: idle ( n-p)  nnx  /mod  nny -1 +  mod  1  min  4  + swap  nnx -1 +  mod  1  min 2* + port ;
: rstadr align tbl  , 0xaa , 0x195 , 0x185 , 0x1b5 , 0x1a5 
: rstdef strings ( p0aa p13f p12f p11f p10f)
: ?rst ( pa-i)  4  for dup i rstadr or while drop -next abort then drop drop pop ;

( block 193 )

: port ( returns port for 0-3 rdlu then edges)
: idle ( is idle p value for given node.)
: rstadr ( and) rstdef ( number values and white names of p straps rom, corn, side, top/bot, mid.)
: ?rst ( returns index of valid reset or aborts.)

( block 194 )
( ga144 node types)


: laid  nns aray : resets  nns aray 
: kinds  nns aray


: 0's ( n) for 0 , next ;
: +roms ( -ia) align ray  nns 0's 
: iz ( nn i) swap nn-n +roms ! ;
701 2 iz 705 10 iz 708 6 iz
     709 14 iz 713 14 iz 717 14 iz
117 14 iz 617 14 iz
1 2 iz 200 18 iz 300 4 iz
( eforth) 105 20 iz 106 20 iz ( sdram...)
7 20 iz 8 20 iz 9 20 iz 107 20 iz 108 20 iz 
: @rom ( nn-n) nn-n +roms @  22  less if drop  1418  + ;  then drop  100  mod  1301  + ;


: bedtab ( -serbed)  cuco  @ nn-n kinds @ ;
: ?serbed  testb  @ 0 or drop if bedtab ;  then 0 ;

( block 195 )

: laid ( nz if node laid out)
: resets ( index of reset address)
: kinds ( kind for testbeds)
: +roms ( and) @rom ( are here only as temporary kludges. we will eventually load a table from the node defns for default kind and prom source.)
: +roms ( array indexed by linear node number returning code number for rom load block.)
: iz ( sets node)  nn ( to use rom load block) n ( codes- 0-arith 2-serdes 4-syncboot 6-async 10-spi 14-analog 18-1wire)
: @rom ( returns block number for production rom code applicable to the given node.)
: ?serbed ( 0-none 1-async 2-sync 3-1wire 4-spi 5-strap 6-serdes 7-servers for)  cuco ( if) testb ( nz.)

( block 196 )


( block 197 )


( block 198 )


( block 199 )


( block 200 )
( user f18 code) reclaim

( softsim example) reclaim node 0 1342 load
( practical example pwm code) reclaim 842 load

( block 201 )
( use this load block to compile your code)
( for the f18 computers.)

( as delivered, sample code loaded here is pro- vided to facilitate working with examples)
( presented in the user's guide. it may be)
( deleted if you no longer have use for it.)

( block 202 )
( ga application tools)
: a-com  3  ;
: a-bps 921600 ;
: c-com  10  ;
: c-bps 921600 ; :: host 206 ;
: target 208 ; ( modules)
: sram  264  ; ( utils)
: streamer  282  ;
: loader  210  ;
: selftest ( port)  708  load ; :var stp [0x3]
: autotest ( port)  712  load ;

( block 203 )
( these definitions are used in released code or documented procedures and shouldn't be changed or overloaded casually.)


: a-com ( and) c-com ( are com port numbers for eval board usb ports a and c.)
: a-bps ( and) c-bps ( are baud rates to which ide)
( sets these usb ports.) :: host ( and) target ( load block numbers for serial ide configured to work with eval board host or target chips using default usb ports.)

 definitions for getting started app note 
: selftest ( runs ats selftest on either chip via the ide com port number given.)
: autotest ( given host ide com port number, runs ate tests of target chip using sync boot. then tests)  serdes ( between the chips.)

( block 204 )
( - user application tools)

( block 205 )
( this is the place to compile definitions that you wish to be available after) empty. ( be sure to test compile separately before placing them here or you may cause) ( 18 ) ( load to abort.)

( block 206 )
( evb001 host chip ide) empty compile

serial load
( customize) -canon 0 fh orgn !
a-com sport ! a-bps bps ! !nam


: dac ( n) 0x155 and io r! ;

( canon load)

( block 207 )
( this load block compiles and configures the)
( ide for the host chip on the eval board. it's also an example of configuring and customizing the ide without hacking it and breaking other uses of the ide.)

( this block starts by loading the serial ide in its standard form.) -canon ( forgets the mapping of canonical words like)  @ ( and) dup ( onto the f18 so that we may interact with x86 code and ram.)
( we then set)  orgn ( so that the ide)  compile ( will reload this block, and we set)  sport ( to the usb port a for normal ide operations on host chip.) !nam ( updates pathname for that com port.)


: dac ( is defined to illustrate extending the ide)
 canon load ( restores mapping of canonical words onto the f18. comment this if you wish to use the 'r-words' for all f18 operations.)

( block 208 )
( evb001 target chip ide) empty compile

serial load
( customize) -canon 0 fh orgn !
c-com sport ! c-bps bps ! !nam


: dac ( n) 0x155 and io r! ;

( canon load)

( block 209 )
( this load block compiles and configures the)
( ide for the eval board's target chip. it's)
( also an example of configuring and customizing the ide without hacking it and breaking other uses of the ide.)

( this block starts by loading the serial ide in its standard form.) -canon ( forgets the mapping of canonical words like)  @ ( and) dup ( onto the f18 so that we may interact with x86 code and ram.)
( we then set)  orgn ( so that the ide)  compile ( will reload this block, and we set)  sport ( to the usb port c for normal ide ops on target chip.)
!nam ( updates pathname for that com port.)


: dac ( is defined to illustrate extending the ide)
 canon load ( restores mapping of canonical words onto the f18. comment this if you wish to use the 'r-words' for all f18 operations.)

( block 210 )
( ide based loader) :var pth [0x2] :var root [0x2c4] talk ( tables and routing) 2 fh 2 loads
: body follower  0  + drop -if  root  @ active or drop if deliver ;  then ;  then  1  +route body  -1  +route deliver ;
: ship ( n) dup  pth  ! route active  root  !  1  +route foc body unfoc  pth  @ -hook ;

( block 211 )
( ide scripting)
: body ( recursively visit and initialize) ( each node in the path)
: ship ( use given path and set foc mode) ( visit each node in the path then cleanup) ( by convention path) ( 2 ) ( in the ide reaches all) ( nodes and is suitable for use by most apps.)  usage ( is simple.) ( 1.) host ( or target) load loader load ( 2. describe the application using +node et al. 3.) ship

( block 212 )
( - configuration tables) :var com [0x85]
: tabl pop 2/ 2/  com  @ + ;
: jsr 0xe8 dst ; ( call has been clobbered already)
: table ( nn) [compile] align jsr tabl for dup , next drop ;
: a-boot  -1 144 table
: c-boot  -1 144 table 
: b-boot  -1 144 table
: p-reg  0xa9 144 table 
: a-reg  -1 144 table
: b-reg  io 144 table
: /a ( a) a-reg ! ;
: /b ( a) b-reg ! ;
: /p ( a) p-reg ! ;
: +node ( n) nn-n  com  ! ;
: /part ( acb) b-boot ! c-boot ! a-boot ! ;
: /ram ( b) b-boot ! 64 c-boot ! 0 a-boot ! ;
: rammer ( -acb) a-boot @ c-boot @ b-boot @ ;
: aaray pop 2/ 2/  com  @  11  * + ;
: array ( n) [compile] align jsr aaray  11  * for 0 , next ;
: 'stack  144 array :var sp [0xa]
: @s+ 'stack  sp  @ + @ 1  sp  +! ;
: !s- ( n) 'stack  sp  @ + ! -1  sp  +! ;
: /stack ( stuff count) 10  sp  ! dup !s- for !s- next ;

( block 213 )
( - configuration tables)
: tabl
: jsr ( call from block) ( 88 ) ( has been clobbered) ( so replace it with jsr instead)
: table ( build and initialize a table) ( tables hold configuration information)
: /a a ( specifies)  a ( value for current node)
: /b a ( specifies)  b ( value for current node)
: /p a ( specifies entry point for current node)
: +node n ( makes n the current node)
: /part acb ( specifies)  address count ( and) bin ( for code to be loaded into current node later)
: /ram b ( specifies just the bin, load all) ( 64 )
: rammer -acb ( returns)  address count ( and) bin ( from table)
: /stack stuff count ( specifies)  count ( items to be placed on the stack at load time)

( block 214 )
( - routing) :var 'rte [0x40bfca6]
: route ( i) 'pths + @  'rte  ! ;
: active ( -n)  'rte  @ @ ;
: follower ( -n)  'rte  @  1  + @ ;
: +route ( n)  'rte  +! active nn-n  com  ! ;
: ?load c-boot @  0  + drop -if ;  then rammer boot ;
: deliver  pth  @ active hook ( pause) ?load a-reg @ -  0  + drop -if a-reg @ lit' ra! then b-reg @ -  0  + drop -if b-reg @ lit' rb! then 'stack  10  + @ dup and if dup dup negate  10  +  sp  ! for @s+ lit' next then drop p-reg @ call ;

( block 215 )
( - routing)
: route i ( start on a path)
: active -n ( node being configured)
: follower -n ( next node in path)
: +route n ( change active node)
: ?load ( load code into node now if table says to)
: deliver ( init ram, a, b, stack, and p if) ( tables say to do so)

( block 216 )
( softsim configuration) ( spi boot testbed) ( 1244 ) ( 2 ) ( loads) ( sync boot testbed 'addr,len') ( 1230 ) ( load) ( smtm) 0 +node 0 /ram 0 /p ( /command test) 400 +node 0 /ram 0x25 /a 0x12 /b 9 8 7 6 5 4 3 2 1 0x12345 10 /stack 0xa9 /p ( rom write test) ( 200 ) ( +node) ( 0x13 ) ( /p) ( 0 ) ( 0x32 ) ( 103 ) ( break) ( 0 ) ( 0xbe ) ( 300 ) ( break)

( block 217 )
( this block is loaded by softsim to set the) ( configuration for a given simulation. edit it as needed to set up testbeds, load application code and initialize it for running, and set) ( breakpoints.) see arrayforth user's manual for information about these options.

( block 218 )


( block 219 )


( block 220 )


( block 221 )


( block 222 )


( block 223 )


( block 224 )


( block 225 )


( block 226 )


( block 227 )


( block 228 )


( block 229 )


( block 230 )


( block 231 )


( block 232 )


( block 233 )


( block 234 )


( block 235 )


( block 236 )


( block 237 )


( block 238 )


( block 239 )


( block 240 )
( framer) overlay 
: exec  0xb6  ; : warm  0xa9  ; : io  0x15d  ;

: right  0x1d5  ; : down  0x115  ;
: left  0x175  ; : up  0x145  ;
( streams) 2 fh 4 loads


: body ( w-w) follower  0  + drop -if
?load post ;  then -load -post pump
 1  +route body  -1  +route ?load post ;

: length ( -n) 1  'pth  @  1  + begin dup @ -  0  +
-while - nn-n  com  ! c-boot @  0  + -if  -4  +
then ( load)  5  + ( pump)  5  + ( post) @post + u+
 1  + end then drop drop ( -1pump)  -5  + ;


: head ( a-w) active nn-n  com  !  0x10000  + !18
 0  side dup !18 length dup !18
swap  0x12000  + !18  1  +route ;
: frame  exec  head  -1  + body drop  -1  +route c-boot @  0  + drop -if 0 0 0 /part then p-reg @ booter /root ; ( default path) 22 fh load

( block 241 )
( framer load gets the stream vocabulary)


: body ( recursively make the body of a boot frame)
: length ( add up number of words in boot frame)
: head ( make boot frame header)
: frame ( make the whole boot frame)
     ( -1 ) ( for focus , +3 for header)

( block 242 )
( - framer) :var com [0x83]
: tabl pop 2/ 2/  com  @ + ;
: table ( nn) [compile] align call tabl for dup , next drop ;
: a-boot  -1 144 table
: c-boot  -1 144 table 
: b-boot  -1 144 table
: p-reg  0xa9 144 table 
: a-reg  -1 144 table
: b-reg  io 144 table 
: inits  1 144 table
: init 11 inits ! ;
: /a ( a) a-reg ! init ;
: /b ( a) b-reg ! init ;
: /p ( a) p-reg ! ;
: +node ( n) nn-n  com  ! ;
: /part ( acb) b-boot ! c-boot ! a-boot ! ;
: /ram ( b) b-boot ! 64 c-boot ! 0 a-boot ! ;
: booter ( -acb) a-boot @ c-boot @ b-boot @ ;
: aaray pop 2/ 2/  com  @  11  * + ;
: array ( n) [compile] align call aaray  11  * for 0 , next ;
: 'stack  144 array :var sp [0xa]
: @s+ 'stack  sp  @ + @ 1  sp  +! ;
: !s- ( n) 'stack  sp  @ + ! -1  sp  +! ;
: /stack ( stuff count) init 10  sp  ! dup !s- for !s- next ;

( block 243 )
( stream components) com ( identfies current node)
: table ( creates an array initialized to) ( -1 )
: x-boot
: x-reg ( arrays have booter and starter details)
: /p ( specifies entry point)
: /a ( initial value of a)
: /b ( initial value of b)
: +node ( connect to a node in a path)

: /part ( from ide, specifies ram address,)
( length and source)  note scrub must be maintained to match the defaults stored here! 
: booter ( find a, c, and b for +load)


: aaray
: array
: 'stack ( an array of) ( 144 ) ( 10 ) ( item stacks)
: @s+ ( get next item to be initialized)
: !s- ( store next item into stacks array)
: /stack ( specify stack initialization)

( block 244 )
( - framer) :var 'pth [0x40bf273]
: b-a ( b-a)  3  + 2/ 2/ ; : a-b ( a-b) 2* 2* ;
: create ( -a) pop b-a ;
: route pop b-a
: course ( a)  'pth  ! ;
: active ( -n)  'pth  @ @ ;
: follower ( -n)  'pth  @  1  + @ ;
: +route ( n)  'pth  +! active nn-n  com  ! ;

:var wd [0x483e045]
: 'stream ( -a)  nnc 2 * 0x8000 + block 1 +  ;
( clear) 'stream 1 + wd ! 
: stream ( -ac)  'stream 1 +  dup  wd  @ - + - dup  'stream -1 +  ! ;
: strlen ( -n) stream nip ;
: !18 ( n)  0x15555  or  wd  @ ! 1  wd  +! ;


: wall ( nn-i) over over or  1  and drop if
or  2  and ;  then  100  / swap  100  / or
 2  and  1  + ;
: side ( n-a)  'pth  @ + dup @ swap  1  + @ wall port ;

: 0/2 ( n-0/2)  0  + drop -if  0  ;  then  2  ;
: @post ( -n) a-reg @ 0/2 b-reg @ 0/2 +
'stack  10  + @  2  * +  1  + ;

( block 245 )
( stream components)
'pth ( points to current place in path)
: b-a ( byte to word address)
: route ( stores address of new path in)  'pth
: course ( is user vocab for setting a path.)
: active ( return current node in path)
: follower ( return next node in path)
: +route ( move to next node in path)
      pos ( moves forward) neg ( moves back)

wd ( point to next word in stream buffer)
: !18 ( stores word into stream buffer)


: wall ( given numbers of two adjacent nodes)
( return index for shared port)
: side ( given numbers of two adjacent nodes)
( return address of shared port)


: 0/2 ( false is 0 and true is) ( 2 )
: @post ( add up the size of active node's)
( postamble)
: to-do ... clean up 'stream as +2, define -1+ as length and -2+ as concat.

( block 246 )
( - framer)
: pump ( w-w)  -5  + ( @pdupa!@p)  0x4daf  !18
 0  side  0x12000  + !18 dup  -1  + !18
( push!..)  0x2fab2  !18 ( @p!unext.)  0x5a72  !18 ;
: post a-reg @ -  0  + drop -if
( @pa!..)  0x4ab2  !18 a-reg @ !18 then
     b-reg @ -  0  + drop -if
( @pb!..)  0x4bb2  !18 b-reg @ !18 then
     'stack  10  + @ dup and if dup
     dup negate  10  +  sp  ! for
( @p ..)  0x49b2  !18 @s+ !18 next then drop
( always) p-reg @  0x10000  + !18 ;


: +ram ( acb) nn-n 2*  0x8000  + block u+
for dup @  0x15555  or !18  1  + next drop ;
: +load ( acb) push ( @pa!@p.)  0x4a12  !18
over !18 dup  -1  + !18 ( push...)  0x2e9b2  !18
( @p!+unext.)  0x5872  !18 pop +ram ;

( block 247 )
( stream components)


: pump ( store) ( 5 ) ( word port pump to stream buffer)
: post ( variable length word postamble,)
( entry point, a, b, stack)
: +ram ( write ram contents to stream buffer)
: +load ( 5 ) ( word load pump to stream buffer)

( block 248 )
( - framer)
: ?load ( w-w) c-boot @  0  + drop -if ;  then
booter +load ;
: -load ( w-w) c-boot @  0  + -if drop ;  then
 5  + negate + ;
: -post ( w-w) @post negate + ;


: adjust begin strlen 7 and drop while
0 !18 end then strlen 'stream ! ;
: scrub ( n) +node  -1  dup dup /part
-1 /a io /b warm /p ;
: fresh begin active scrub  1  +route
active dup and drop -until ;


: /root ( a' a c b) push push push
0x10000 +or !18 pop dup !18 pop dup !18
 0  + if pop +ram ;  then drop drop pop drop ;

( block 249 )
( stream components)


: ?load ( maybe add load pump and ram contents)
: -load ( subtract ram words from payload count)
( if ram is to be loaded in active node)
: -post ( subtract length of postamble from)
( payload count)


: adjust ( align stream to) ( 8 ) ( 18 ) ( bit word boundary)
: scrub ( remove previous initialization clues)
( for node n in the current path)  must be main- tained whenever defaults for tables change. 
: fresh ( scrub the entire current path to prepare for another boot frame)

( block 250 )
( ers flash erase function) overlay
len ! dest !
serial load -canon
a-com sport ! a-bps bps ! !nam panel 
: esc key? esc ;
: wait esc 0  keych  ! ;
: expand ( n-lh) dup 0xffff and  4  * swap
0xf0000 and 64 / ;
: ersall  0x21  call ;
: ers32  0x18  call ;
: ers  dest  @ pause
 0  + drop if ersall ;  then ers32 ;
: read ( a-a') dup expand lit' lit'  0xc  call  -2  + ;
: r ( d-dw)  2  + rdrop  0x25  call upd ;
: check  dest  @ read  len  @ for
r 0xffff or drop if pop  0  ;  then -next  -1  ;
nores 285 list
.noboot pause wait ( ** install noboot jumper)
talk ( check a-com) 0 705 hook 0x0 64 1613 boot
.boot pause wait ( *** remove noboot jumper)
( ers) .erasing pause ersall chill ( check) overlay

( block 251 )
( erasing flash)


: ers ( an)
 a ( byte address in flash on 4k boundary)
n ( number of)  16 bit words ( to erase)

( block 252 )
( flash writer) ( 18 ) ( bit) overlay
7 + -8 and len ! dest ! source !
serial load -canon
a-com sport ! a-bps bps ! !nam talk

0 705 hook 0x0 64 1609 boot focus
0 706 hook 0x0 64 1610 boot

( flash commands) ( 1214 ) 2 fh load

285 list nosay
.burning pause burn chill
.checking pause check
overlay

( block 253 )
( writing a boot stream into flash)

( force length to) ( 0 ) ( mod) ( 8 ) ( so operation ends)
( at a) ( 16 ) ( bit boundary)


: 18burn ( sdn)
 s ( source address of buffer in host memory)
d ( destination) ( 8 ) ( bit address in flash)
n ( length of stream in) ( 18 ) ( bit words)

( block 254 )
( - code for flash writer)
: read ( a) left lit' ra! dup 0xf0000 and 64 /
swap 0xffff and 4 * lit' lit'  0x23  call ;
: r left lit' ra!  0x29  call upd ;
: commence left lit' ra!  len  @ 8 / -1 +
 dest  @ dup 0xf0000 and 64 / lit'
0xffff and 4 * lit' lit'  0x2d  call ;
: git ( a-an) dup  1  + swap @  0x15555  or ;
: get ( a-a) git lit' ;
: burning  source  @  len  @ for get !+ next drop ;
: fetch ( -n)  0x37  call ( 0x3f )  0x3a  r@ ;
: check ( -t)  dest  @ read  source  @  len  @
for git fetch over ( pause) over or
drop if pop fail ;
 then drop drop next drop good ;
: burn commence burning ;


: f 0 706 hook fetch 0 705 hook upd ;
: b 0 706 hook burn ;

( block 255 )


( block 256 )
( exercising flash) org 0x20 
: focus ( 0x20 ) @p dup a! .. ( /) --l- ( /) ! ;
: reading ( 0x23 ) ( l h) focus @p ! .. ( /) @p @p .. ( /)
! ! .. @p ! ; ( /) , 0x1200e ( /)
: @word ( 0x29 ) ( -n) @p ! .. ( /)  , 0x120d9 ( /)
 @p ! @ ; ( /)  !p .. ( /)
: writing ( 0x2d ) ( h l n) focus
left @p ! .. ( /) @p a! .. ( /)
! @p ! .. ( /) @p @p @p .. ( /) push push !
pop ! pop ! @p ! ; ( /) , 0x1201d ( /)
: stash ( 0x37 ) focus @word !p ; ( 0x3a ) , 0

exit 
: stash ( 0x37 ) focus a push @word 0x3f a! ! pop a! ;

( block 257 )


( block 258 )
( writing flash) ( 8 ) ( bits) overlay
len ! dest ! source !
serial load -canon
a-com sport ! a-bps bps ! !nam talk

( flash commands) ( 1220 ) 2 fh load

0 705 hook 0 64 1611 boot
285 list nosay ( nores)
.burning pause burn chill
.checking pause check
overlay

( block 259 )
( programming) ( 8 ) ( bit flash)


: burn ( sdn)
 s ( source address of buffer in host memory)
d ( destination) ( 8 ) ( bit address in flash)
n ( length of stream in) ( 16 ) ( bit words)

( block 260 )
( code for reading and writing flash) ( 8 ) ( bits)

: out 0 706 hook ; : in 0 705 hook ;
: read ( a-a') in dup dup 0xf0000 and 64 / lit'
0xffff and  4  * lit'  0xe  call rdup upd  -2  + ;
: r ( d-dw)  2  + rdrop  0x14  call upd ;
: r18 ( d-dw)  2  + rdrop  0xd9  call upd ;
: rr  0x8000  read r ;
: ers  0x24  call ; : pr  0x28  call ;
: send ( n) left ( pause) r! ;
: 2@+ ( b-b'h) dup 2 + swap 2@ 0xffff and swab ;
: burn in  dest  @ dup  0xf0000  and  64  / lit'
 0xffff  and  4  * lit'  len  @ lit'
left lit' ra! pr out  source  @  len  @
for 2@+  4  * send -next drop ;
: check ( -t)  dest  @ read drop
 source  @  len  @ for 2@+ ( 0x39 )  0x3b  call  0x3f  r@ or
drop if pop drop fail ;  then -next drop fair ;

( block 261 )
( reading and writing flash)


: read ( begin at) ( 20 ) ( bit flash byte address)
: r ( read the next) ( 16 ) ( bit word from flash)
: r18 ( read the next) ( 18 ) ( bit word from flash)
: rr ( begin and read first word at) ( 0x8000 )
: ers ( erase whole flash)
: pr ( program assuming already erased)
: back ( back out to node) ( 706 ) ( for streaming)
: send ( one word into node) ( 705 ) ( , pause to display)
: 2@+ ( fetch) ( 16 ) ( bit word + byte swap)
: burn n ( start programming flash in) ( 705 ) ( ,)
( then back out to) ( 706 ) ( and stream words from)
( the stream buffer into) ( 705 ) ( .)

( block 262 )
( default flash path for whole chip)
: line ( ncd) swap push swap begin dup , over + -next drop drop ;
: count ( nc-ncd) dup  100  mod  0  + if ( horz) swap drop  1  ; ( vert)  then drop  100  /  100  ;
: to ( nn) over negate + -if ( back) negate count negate line ; ( forw)  then count line ;
: entire align create  705 701 to 700 0 to 1 17 to 117 101 to 201 217 to 317 301 to 401 417 to 517 501 to 601 617 to 717 709 to , -1 ( retain asynch boot) 708 +node 0xaa /p

( block 263 )

: line ncd ( comma nodes into a table starting at node) n ( for) c ( nodes incrementing by) d

: /left ( extend line toward the left)
: /right ( extend line toward the right)
: /up ( extend line upward)
: /down ( extend line downward)
: entire ( default path table that)
( covers the whole virginal chip)

( block 264 )
( sram cluster mk1)

( load sram) 6 fh 3 loads
     ( norm) 12 fh ( degen) ( 12 ) ( 16 ) ( fh) load

( block 265 )
( load block for sram cluster mk1) ( as documented in an003.) ( packaged as per preliminary module standards) sram ( load block for f18 code) sram 2 + ( boot descriptors for cluster) sram 4 + ( optional residual path definition) ( f18 source code follows.)

( block 266 )
( - load descriptor) ( interface) 107 +node 1614 /ram down /b ( mask) 0x8a00 1 /stack ( re) 0x17 /p ( data) 7 +node 1615 /ram 0x20 /p ( cntl) 8 +node 1616 /ram 0x20 /p ( addr) 9 +node 1617 /ram 0x20 /p

( block 267 )
( load descriptor for sram cluster) ( this descriptor is suitable for use with) ( ide loader, streamer, and softsim.)

( block 268 )
( - residual paths)
: s705 align create  705 701 to 700 0 to 1 6 to 106 101 to 201 208 to 108 109 to 209 210 to 110 10 to 11 17 to 117 111 to 211 217 to 317 301 to 401 417 to 517 501 to 601 617 to 717 709 to , -1
: s708 align create  708 701 to 700 0 to 1 6 to 106 101 to 201 208 to 108 109 to 209 210 to 110 10 to 11 17 to 117 111 to 211 217 to 317 301 to 401 417 to 517 501 to 601 617 to 717 709 to , -1

( block 269 )
( memory clusters are often loaded before the) ( rest of the application so that external ram) ( may be initialized without burdening appli-) ( cation f18 code. these residual paths provide access from boot nodes to the rest of the chip in such cases.)
: s705 ( residual path for spi flash boot streams.)
: s708 ( residual path for async boot or ide.)

( block 270 )
( sram.16 address-bus) node 9
( 0xaa ) org 0x20


: start ( 0x20 ) right b! .. data a! .. 0x3 ( mask)
: cmd ( m) ( 0x26 ) @b ( a16) 2* 2* over @b -if
     ( 0x28 ) - ( p04) and or ( a18) ! cmd ;
     ( 0x2a )  then ( p04) and or .. ( a18) ! cmd ; ( 0x2c ) 1617 bin

( block 271 )
( node) ( 9 ) ( suspends while waiting for a16. it uses the two lower page bits to output an)
( 18-bit address.)

      a16 ( xx.aaaa.aaaa.aaaa.aaaa)
     p04 ( 00.0000.0000.0000.pppp)
     a18 ( aa.aaaa.aaaa.aaaa.aapp)

( the code is written to minimize/equalize the time to output the address, which must be stable when node8 stores the 'start' command.)

( block 272 )
( - control-pins) node 8 host  :: 'r-l- 0x1f5 lit ; target org 0x0

( 'start' pin control table 0-7)
( 0x0 ) 0x2556e ( , r00) 0x2557e ( , r01)
( 0x2 ) 0x3556e ( , r10) 0x3557e ( , r11)
( 0x4 ) 0x3557a ( , w11) 0x3556a ( , w10)
( 0x6 ) 0x2557a ( , w01) 0x2556a ( , w00)
( 0x8 ) org 0x20


: start ( 0x20 ) 'r-l- b! io a!
: cmd ( 0x24 ) @b ( stop) ! a push 0x7 ( mask) ..
     @b ( a16) !b @b ( +p/-p) dup !b
     2/ 2/ and ( i3) a! .. @ ( ctrl) pop a!
     ( start) ! cmd ; ( 0x2c ) 1616 bin

( block 273 )
( node8 is fed a stop command during start-up, then suspends while waiting for a16. after starting the read or write, it again suspends while waiting for the stop command.)

( bits 4..2 of the /possibly inverted/ page value are used 'as-is' to index into the start table, setting two address bits, write enable, and chip enable.) ** note that reads and writes are swapped if the page 'overflows' into bit4, with disastrous results **

( cmd index) .lit. ( pin17 pin05 pin03 pin01)
( w00 .0111) 0x2556a ( a19-0 a18-0 /we-0 /ce-0)
( r00 .0000) 0x2556e ( a19-0 a18-0 /we-1 /ce-0)
( w01 .0110) 0x2557a ( a19-0 a18-1 /we-0 /ce-0)
( r01 .0001) 0x2557e ( a19-0 a18-1 /we-1 /ce-0)
( w10 .0101) 0x3556a ( a19-1 a18-0 /we-0 /ce-0)
( r10 .0010) 0x3556e ( a19-1 a18-0 /we-1 /ce-0)
( w11 .0100) 0x3557a ( a19-1 a18-1 /we-0 /ce-0)
( r11 .0011) 0x3557e ( a19-1 a18-1 /we-1 /ce-0)

( block 274 )
( - data-bus) node 7 host  :: in 0x14555 lit ; :: out 0x15555 lit ; :: stop 0x3557f lit ; target

( 0xaa ) org 0x20 
: start ( 0x20 ) left b! out io data stop
     out io data stop in io a! ( in) !
     down a! ( stop) !b
: cmd ( /soid/) ( 0x31 ) @ ( a16) !b @ ( +p/-p) -if


: w16 ( /soid/p-) ( 0x33 ) ( +p/-p) !b
( /- setup + 45ns) @ ( w) a push push ( data) a!
pop ! ( io) a! ( out) ! ( 40 ) 13 for unext ( stop) !b
( -/) in ! pop a! cmd ;


: r16 ( /soid/p-) ( 0x3c ) then ( +p/-p) !b
( /- setup + 55ns) a push ( data) a!
( io) drop ( out) drop ( 50 ) 40 for unext ( stop) !b ( -/)
@ ( w) pop a! ! cmd ; ( 0x43 ) 1615 bin

( block 275 )
( node7 suspends waiting for a16, passes it and page/r/w to nodes) ( 8 ) ( and 9, finally controlling the data transfer and timing until sending the stop command.)

( the literals needed for writing are loaded)
( onto the stack and used circularly to save)
( time. /read's drops are free./)

( ----)  .lit. ( pin17 pin05 pin03 pin01)
( stop) 0x3557f ( a19-1 a18-1 /we-1 /ce-1)

( block 276 )
( - interface) node 107 org 0x0 
: cx ( wp-) ( 0x0 ) over push @ dup ( a) !b over ( p) !b @b ( w) pop - ( w1) or if ( ne) @ ( w2) dup or ( ff) ! ; ( eq)  then drop ( a) !b - ( -p) !b @ ( w2) !b 0xffff ! ;
: cmd ( 0xa ) @ -if @  ' cx  -until ( .e!) - !b !b @ !b ;  then ( 0xe ) @ -if ( mixpa) ( .mk!) ( 0xf ) - push drop drop pop if ( mia) ( ..stim) ( 0x11 ) drop and @ over over 2* ahead  swap ( ..mask) ( 0x14 )  then drop drop @ 2* over - ( ...both) ( 0xc16 ) then and or
: re ( 0x17 ) ( m) 0x15555 dup ahead  swap  then ( .e@) ( 0x19 ) ( a) !b ( p) !b @b ( w) ! ;
: cmds ( mixa) ( 0x1b ) a! cmd
: poll ( mix) then io a! ( 0x81e ) begin drop over over @ or and until ( 0x21 ) over over and if ( mixt) ( 0x23 ) and and ( mt) dup 0x10000 and if right ahead  swap  then ( 0x28 ) drop 0x1000 over and if left ahead  swap ( 0x2d )  then drop ( 0x400 ) dup up then then ( 0x2f ) ( mtba) a! and or dup ! ( m)  ' re  end ( 0x31 ) then drop 2* 2* -if right cmds ; ( 0x35 )  then 2* 2* 2* 2* -if left cmds ; ( 0x39 )  then up cmds ; ( 0x3b ) 1614 bin

( block 277 )
( node) ( 107 ) ( full capability version.) ( polls for master requests and delivers stimuli) ( all requests are atomic. passes)  ex@ ( and) ex! ( requests on to node 007, performs) cx? ( locally using those primitives. the command and stimulus mask)  m ( is maintained on the stack.) ( requests are variable length messages decoded as shown below where - means 18-bit inverse of) ( 16 ) ( bit argument.)
: ex@  +p +a ( fetch)
: cx?  -w1 +p a w2 ( comp-and-exch)
: ex!  -p -a w ( store)
: mk!  +0 -f m ( f-1 enables each master whose port write bit is set in) m. ( kills pending stimulus for any disabled master. abandons old mask.) ( f-0 adds a stimulus for each master whose port write bit is set in) m. ( caller should not post a stimulus for any disabled master.)

( block 278 )
( - user node 106, 108, or 207.)
: x! ( wa) ( 0x39 ) dup dup or
: ex! ( wap) : mk! ( mfp') ( 0x3a ) - !b - !b !b ;
: x@ ( a-w) ( 0x3c ) dup dup or
: ex@ ( ap-w) ( 0x3d ) !b !b @b ;
: cx? ( wapn-f) ( 0x3e ) - !b !b !b !b @b ; ( 0x40 )

( block 279 )
( example code for memory master nodes.)
( memory-access words assume that addresses and data are 16-bit parameters with the upper two bits zero and pages are 4-bits with the upper) ( 14 ) ( bits zero. p.a is thus a 20-bit address.)


: ex@  a p ( -)  w ( fetch w from p.a)
: ex!  w a p ( store w at p.a)
: mk!  w f $ -0 ( set masks from w per f.)
: cx?  w a p n ( -)  f ( comp-and-exch)

cx? ( compares value at)  p.a ( to) n. ( if same, writes) w ( to) p.a ( and returns true. otherwise, only returns false.)  x@ ( and) x! ( are 16-bit versions to access the lowest 64k of available memory.)

mk! ( sets mask from w when f is 0;)
( posts stimuli when f is 1.)

( block 280 )
( - degenerate sram) node 107 org 0x0


: cx ( wp-) ( 0x0 ) over push @ dup
     ( a) !b over ( p) !b @b ( w) pop - ( w1) or if
( ne) @ ( w2) dup or ( ff) ! ;
( eq)  then drop ( a) !b - ( -p) !b @ ( w2) !b 0xffff ! ;


: cmd ( 0xa ) @ -if @  ' cx  -until ( .e!) - !b !b @ !b ;  then ( 0xe ) @ ( .e@) ( 0xf ) ( a) !b ( p) !b @b ( w) ! ;

( 0x11 ) org 0x17 
: start ( 0x17 ) down b! right a!
: run ( 0x1b ) cmd run ; ( 0x1d )

( block 281 )
( node) ( 107 ) ( minimal capability version.)
( single master, no polling, no stimuli.)
( maximum speed, minimum power.)

( all requests are atomic. passes)  ex@ ( and) ex!
( requests on to node 007, performs) cx? ( locally using those primitives.)

( requests are variable length messages decoded as shown below where - means 18-bit inverse of) ( 16 ) ( bit argument.)


: ex@  +p +a ( fetch)
: cx?  -w1 +p a w2 ( comp-and-exch)
: ex!  -p -a w ( store)

( block 282 )
( streamer)
:var source [0x483e001] :var dest :var len [0xd88]
: stream ( -an)  source  @  len  @ ;
: 18burn ( sdn)  -30 fh  load ;
: burn ( sdn)  -24 fh  load ;
: ers ( an)  -32 fh  load ;
: framer  -42 fh  ;
: chill 500 for 1000000 for nop next next ;
: file  12 fh  ;
( feedback) 284 load 
: overlay remember

( block 283 )
( stream building utilities)
( persistant streamer variables)
 source ( word address in host memory buffer)
dest ( byte address in flash)
len ( length of stream in words)
: stream -an ( returns)  source ( an) len 
: 18burn sdn ( burn flash in) ( 18 ) ( bit words)
: burn sdn ( burn flash in) ( 16 ) ( bit words)
: ers an ( erase 4k blocks containing range)  an
: framer ( location of boot frame vocabulary)
: chill ( delay a long enough time to be sure)
( that the previous operation is complete)
: overlay ( remember point for streamer utility)
( saying)  overlay ( restores the dictionary to)
( its state when overlay was defined)

( block 284 )
( flash utilties feedback)
:var loaded [0x1d0] :var result
:var 'say [0x102f8d6f] :var 'ask [0x102f8c17]
: nosay  'say  assign nop ; nosay 
: noask  'ask  assign nop ; noask 
: .now blu  'say  xqt ;
: .ask blu  'ask  xqt ;
: .at. blu silver  loaded  @ . ;
: chs ( ...n) for emit next ; 2 fh load 
: .res blu  result  @
( -1 )  0  + -if .fair ;  then
( 0 )  -1  + -if drop .good ;  then
( 1 )  -1  + -if drop .fail ;  then ;
: fair -1  result  ! ;
: good 0  result  ! ;
: fail 1  result  ! ;
: nores 2  result  ! ; :var leng [0x1d11] 36 leng ! 
: .str blu silver .' ( stream) space .' ( length) space  leng  @ . .' ( words) space  leng  @ 18 8 */ . .' ( bytes) space ;

( block 285 )
( flash utilities)








( block 286 )
( - flash utilities feedback)
: .erasing noask ( nores)  'say  assign silver
( erasing) 0 0xd 0x6 0x7 0x8 0x5 0x1 0x4 8 chs ;
: .burning noask ( nores)  'say  assign silver
( burning) 0 0xd 0x6 0x7 0x6 0x1 0x16 0x13 8 chs ;
: .checking noask ( nores)  'say  assign silver
( checking) 0 0xd 0x6 0x7 0x24 0xa 0x4 0x14 0xa 9 chs ;
: .fair silver ( so far) 0 0x1 0x5 0xe 0 0x3 0x8 7 chs
( so good) 0 0x10 0x3 0x3 0xd 0 0x3 0x8 8 chs ;
: .good green ( good) 0 0x10 0x3 0x3 0xd 5 chs ;
: .fail red ( fail) 0 0xc 0x7 0x5 0xe 5 chs ;
: .boot nosay ( nores)  'ask  assign green
( remove) 0 0x4 0x11 0x3 0x9 0x4 0x1 7 chs
: .j26
( j26) 0 0x1e 0x1a 0x22 4 chs
( then) 0 0x6 0x4 0x14 0x2 5 chs
( press) 0 0x8 0x8 0x4 0x1 0x12 6 chs
( key) 0 0xb 0x4 0x24 4 chs ;
: .noboot nosay ( nores)  'ask  assign green
( install) 0 0xc 0xc 0x5 0x2 0x8 0x6 0x7 8 chs .j26 ;

( block 287 )


( block 288 )
( pf to flash)

( read/write) ( 18 ) ( bit flash)
     node 705 1364 load 1609 bin
     node 706 256 load 1610 bin
( read/write) ( 8 ) ( bit flash)
     node 705 1370 load 1611 bin
( erase flash)
     node 705 1352 load 1613 bin

( block 289 )


( block 290 )
( speedup spi boot) node 705 org 0 
: start 5 dup spi-exec ;
( 0x3 ) 1608 bin

( block 291 )


( block 292 )


( block 293 )


( block 294 )
( stream to file) named ( stream.bin)
: open ( bf-h) push push 0 32 ( exist) 2 0 0
pop pop swap fcreate ;
: change ( ac) for dup @  0x15555  or over !  1  +
next drop ;
: keep  0 fnam  w/o open dup push stream change
stream push 4 * pop 4 * pop fwr drop fclose
stream change ; keep

( block 295 )
( stream to file)
: open bf-h ( b is byte address of filename)
: change ac ( stream is made as pattern not number)
: keep ( convert stream to number and write it to a file, then change it back to pattern)

( block 296 )


( block 297 )


( block 298 )


( block 299 )


( block 300 )
( dc characterization code added march 2011.)

block 602 ( is code run in a node to measure power.)

blocks 604 ( thru) 636 ( are ide load blocks to set up various measurement conditions.)

( block 301 )


( block 302 )
( custom test code) node 609 org 0x0 
: t1 ( 0x0 ) begin begin begin begin
unext unext unext unext t1 ;
: t2 ( 0x2 ) begin begin begin
. unext unext unext t2 ;
: t3 ( 0x4 ) begin begin . . unext unext t3 ;
: t4 ( 0x6 ) begin . . . unext t4 ;
: t5 ( 0x8 ) begin begin begin begin
next next next next t5 ;
: t6 ( 0xd ) begin begin begin begin
. . . . next next next next t6 ;
: s++ ( 0x13 ) 0x15555 dup : s.. dup dup dup dup dup dup dup dup ; : s+- 0x15555 0x2aaaa s.. ;
: t7 ( 0x1c ) s++ : t78e begin begin begin drop unext unext unext t78e ; : t8 ( 0x1f ) s+- t78e ;
: t9 ( 0x21 ) io b! -1 !b begin . drop @b -until ;
: txx ( 0x28 ) s++ ( s+-)
: txxx begin ( . . .) - unext txxx ; ( 0x2a )
: temp ( 0x2 ) 0x3fffe ( 0x3 ) 0x3ffff 999 io b! push !b begin unext !b ; ( 0x31 )
: temps temp temps ; ( 0x33 )

( block 303 )
( this load block, and the following) ( 25 ) ( source/shadow pairs, are yours to do with as you please!)

( block 304 )
( set all high z for leakage test) talk

0 200 hook 0 io !
0 300 hook 0 io !
0 9 hook 0 io !
0 7 hook 0 io !
( serdes already in input just focus it)
0 701 hook focus
2 709 hook 0x155 io !

( block 305 )


( block 306 )
( set all weak pd for wpd test) talk

0 200 hook 0x15555 io !
0 300 hook 0x15555 io !
( 0 ) ( 9 ) ( hook) ( 0 ) ( io !)
( 0 ) ( 7 ) ( hook) ( 0 ) ( io !)
( serdes already in input just focus it)
( 0 ) ( 701 ) ( hook focus)
( 2 ) ( 709 ) ( hook) ( 0x155 ) ( io !)

( block 307 )


( block 308 )
( set all high for several tests) talk

0 200 hook 0x30003 io !
0 300 hook 0x30003 io !
0 9 hook 0x3ffff data !
0 7 hook 0x3ffff data !
( serdes already in input just focus it)
( 0 ) ( 701 ) ( hook focus)
2 709 hook 0xaa io !

( block 309 )


( block 310 )
( set all low for several tests) talk

0 200 hook 0x20002 io !
0 300 hook 0x20002 io !
0 9 hook 0x0 data !
0 7 hook 0x0 data !
( serdes already in input just focus it)
( 0 ) ( 701 ) ( hook focus)
2 709 hook 0x155 io !

( block 311 )


( block 312 )
( t04 all node access) talk

?rom pause upd pause
2 708 hook pause 2 707 hook pause
?ram pause upd pause
1 lit pause 2 lit pause 3 lit pause
+ pause +

( block 313 )


( block 314 )
( vt+- node) ( 217 ) compile talk 2 217 hook upd

: dak ( n a) 0x5bb2 over r! swap 0x155 or swap r! ;
: try ( n) up dak ;
: h 0x20000 io r! 0x0 try 100 ms 0 io r!
0 begin dup 0x200 or 0x200 and drop while
dup try 1 + io r@ 0x20000 and drop until then ;
: l 0x30000 io r! 511 try 100 ms 0 io r!
255 begin dup 0x100 or 0x100 and drop while
dup try -1 + io r@ - 0x20000 and drop until then ;

( block 315 )


( block 316 )
( vt+- node) ( 517 ) compile talk 0 517 hook upd

: dak ( n a) 0x5bb2 over r! swap 0x155 or swap r! ;
: try ( n) up dak ;
: h 0x20000 io r! 0x0 try 100 ms 0 io r!
0 begin dup 0x200 or 0x200 and drop while
dup try 1 + io r@ 0x20000 and drop until then ;
: l 0x30000 io r! 511 try 100 ms 0 io r!
255 begin dup 0x100 or 0x100 and drop while
dup try -1 + io r@ - 0x20000 and drop until then ;

( block 317 )


( block 318 )
( vt n7/8) compile talk
2 7 hook 0x0 io ! data lit ra! focus
2 8 hook 0x20000 io ! focus upd

: rd ( a-n @!p) 0x39b2 over r! r@ ;
: git ( -n) left rd ;
: go key? git 1 and drop if 0x30000 io r! go ;
 then 0x20000 io r! go ; go

( block 319 )


( block 320 )
( vt n9/8) compile talk
0 9 hook 0x0 io ! data lit ra! focus
0 8 hook 0x20000 io ! focus upd

: rd ( a-n @!p) 0x39b2 over r! r@ ;
: git ( -n) right rd ;
: go key? git 0x20000 and drop if 0x30000 io r! go ;
 then 0x20000 io r! go ; go

( block 321 )


( block 322 )
( t10 schmitt power) talk

( no boot) 0 709 hook upd 0 -hook
0 200 hook 0x15555 io ! upd
0 300 hook 0x15555 io ! upd
0 9 hook ( input) 0 io ! upd
0 7 hook ( output) 0x15555 io ! upd
( serdes to output)
0 701 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! upd
0 0x1 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! upd


( block 323 )


( block 324 )
( t11 suspended power) talk

( no boot) 0 709 hook upd 0 -hook
0 200 hook 0x15555 io ! pause
0 300 hook 0x15555 io ! pause
0 9 hook ( input) 0x15555 io ! 0x0 data ! pause
0 7 hook ( output) 0x15555 io ! 0x0 data ! pause
( serdes to output)
0 701 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! pause
0 0x1 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! upd pause
( susp boot-) 0x0 0x0 ( warm) 0xa9 /frame wos !frame

( block 325 )


( block 326 )
( study single node + boot power) talk

( no boot) 0 709 hook upd 0 -hook
0 200 hook 0x15555 io ! pause
0 300 hook 0x15555 io ! pause
0 9 hook ( input) 0x15555 io ! 0x0 data ! pause
0 7 hook ( output) 0x15555 io ! 0x0 data ! pause
( serdes to output)
0 701 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! pause
0 0x1 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! upd pause
1 608 hook upd 0 64 609 boot ?ram

( block 327 )


( block 328 )
( t12a boot power) talk

( no boot) 0 709 hook upd 0 -hook
0 200 hook 0x15555 io ! pause
0 300 hook 0x15555 io ! pause
0 9 hook ( input) 0x15555 io ! 0x0 data ! pause
0 7 hook ( output) 0x15555 io ! 0x0 data ! pause
( serdes to output)
0 701 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! pause
0 0x1 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! upd pause
1 608 hook upd 0 64 609 boot ?ram


( block 329 )


( block 330 )
( t12b boot pwr + drop same) talk

( no boot) 0 709 hook upd 0 -hook
0 200 hook 0x15555 io ! pause
0 300 hook 0x15555 io ! pause
0 9 hook ( input) 0x15555 io ! 0x0 data ! pause
0 7 hook ( output) 0x15555 io ! 0x0 data ! pause
( serdes to output)
0 701 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! pause
0 0x1 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! upd pause
1 608 hook upd 0 64 609 boot ?ram
( 19 ) 0x1c call

( block 331 )


( block 332 )
( t12c boot pwr + drop alternating) talk

( no boot) 0 709 hook upd 0 -hook
0 200 hook 0x15555 io ! pause
0 300 hook 0x15555 io ! pause
0 9 hook ( input) 0x15555 io ! 0x0 data ! pause
0 7 hook ( output) 0x15555 io ! 0x0 data ! pause
( serdes to output)
0 701 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! pause
0 0x1 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! upd pause
1 608 hook upd 0 64 609 boot ?ram
( 28 ) 0x1f call

( block 333 )


( block 334 )
( t12d boot pwr + greg test) talk

( no boot) 0 709 hook upd 0 -hook
0 200 hook 0x15555 io ! pause
0 300 hook 0x15555 io ! pause
0 9 hook ( input) 0x15555 io ! 0x0 data ! pause
0 7 hook ( output) 0x15555 io ! 0x0 data ! pause
( serdes to output)
0 701 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! pause
0 0x1 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! upd pause
1 608 hook upd 0 64 15 boot ?ram
14 call

( block 335 )


( block 336 )
( t12e boot pwr + unext) talk

( no boot) 0 709 hook upd 0 -hook
0 200 hook 0x15555 io ! pause
0 300 hook 0x15555 io ! pause
0 9 hook ( input) 0x15555 io ! 0x0 data ! pause
0 7 hook ( output) 0x15555 io ! 0x0 data ! pause
( serdes to output)
0 701 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! pause
0 0x1 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! upd pause
1 608 hook upd 0 64 609 boot ?ram
0 call

( block 337 )


( block 338 )
( sram test bd quiet i/o) talk

( no boot) 0 709 hook upd 0 -hook
0 200 hook 0x15555 io ! pause
0 300 hook 0x15555 io ! pause
0 8 hook ( all hi) 0x3557f io !
0 9 hook ( input) 0x15555 io ! 0x0 data ! pause
0 7 hook ( output) 0x15555 io ! 0x0 data ! pause
0 705 hook 0x3ffff io !
0 -hook

( block 339 )


( block 340 )
( study single node w/boot suspended) talk

( no boot) 0 709 hook upd 0 -hook
0 200 hook 0x15555 io ! pause
0 300 hook 0x15555 io ! pause
0 9 hook ( input) 0x15555 io ! 0x0 data ! pause
0 7 hook ( output) 0x15555 io ! 0x0 data ! pause
( serdes to output)
0 701 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! pause
0 0x1 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! upd pause
1 608 hook upd 0 64 609 boot ?ram
( run) ( 0 ) 0x15555 ( 0x3ffff ) lit dup dup dup 0x21 call
( susp boot-) 0x0 0x0 ( warm) 0xa9 /frame wos !frame

( block 341 )


( block 342 )
( 705 ) ( unext w/boot suspended) talk

( no boot) 0 709 hook upd 0 -hook
0 200 hook 0x15555 io ! pause
0 300 hook 0x15555 io ! pause
0 9 hook ( input) 0x15555 io ! 0x0 data ! pause
0 7 hook ( output) 0x15555 io ! 0x0 data ! pause
( serdes to output)
0 701 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! pause
0 0x1 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! upd pause
0 705 hook upd 0 64 609 boot ?ram
( run) 0 call
( susp boot-) 0x0 0x0 ( warm) 0xa9 /frame wos !frame

( block 343 )


( block 344 )
( instr timing code) node 610 org 0x0 
: set 0x3fffe 0x3ffff 999 io b! 1 a! ;
: t1 ( 0x7 ) set push !b begin unext !b ;
: t2 ( 0xa ) set push !b begin next !b ;
: t3 ( 0xe ) set push !b begin . unext !b ;
: t4 ( 0x11 ) set push !b begin . . . unext !b ;
: t5 ( 0x15 ) set push !b begin . . @ unext !b ;
: t6 ( 0x19 ) set push io a! !b begin . . @ unext !b ;
: t7 ( 0x1f ) set push !b begin . .. next !b ;
: t8 ( 0x24 ) set push !b begin . .. . .. next !b ;
: t9 ( 0x2a ) set push !b begin begin dup or push unext . . . . next 0x2 !b ; ( 0x31 )

( block 345 )


( block 346 )
( study instr timing) talk

( no boot) 0 709 hook upd 0 -hook
0 200 hook 0x15555 io ! pause
0 300 hook 0x15555 io ! pause
0 9 hook ( input) 0x15555 io ! 0x0 data ! pause
0 7 hook ( output) 0x15555 io ! 0x0 data ! pause
( serdes to output)
0 701 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! pause
0 0x1 hook focus 0x3fffe lit 0x3fffe data !
     0x20000 io ! upd pause
0 705 hook upd 0 64 610 boot ?ram


: t1  0x7  call ; : t2  0xa  call ;
: t3  0xe  call ; : t4  0x11  call ;
: t5  0x15  call ; : t6  0x19  call ;
: t7  0x1f  call ; : t8  0x24  call ;
: t9  0x2a  call ;

( block 347 )


( block 348 )


( block 349 )


( block 350 )


( block 351 )


( block 352 )


( block 353 )


( block 354 )


( block 355 )


( block 356 )
( mark mem test all nodes)
empty compile serial load panel talk 2 ( 0 ) path
:var tgt [0x1a1] :var tport [0x115] :var times
:var runs [0x3] :var greg [0x1822e] :var /max [0x1822e] :var /tot


: init 0x0  greg  ! 0  times  ! 0  runs  ! 0  /max  ! 0  /tot  ! 0  tgt  ! 0  tport  ! ; init


: xx  0  test 0 or if -1 + dup  /max  @ max  /max  !  greg  ! ( drop) rip 9876 54321 abort then drop ;


: -us ( a-a) dup @ paths @ or drop ;
: -end ( a-a) dup @ -1 or drop ;
: pt@ paths targets @ + ;
: /go pause  0  64 907 boot pfocus paths targets @ + ( ;)
: //go key?  1  + -us if -end if dup @ dup  tgt  ! over -1 + @ wall port dup  tport  ! ( pause) tfocus pause xx ( pause) creep //go ;  then then drop 1  runs  +! rip /go ;
: real : jj /go drop rip ; 776 list ( /go)

( block 357 )
( old code, not checked recently.)
: go ( entered with path hooked to initial adjacent node. boots it with package and makes it active.)
: //go ( entered with path tbl adr for the active node on stack.)

( block 358 )
( mark burn on one weak node)
empty compile serial load panel talk 2 ( 0 ) path
:var tgt [0x2c6] :var tport [0x175] :var times
:var runs [0x3] :var greg :var /max :var /tot

: init 0x0  greg  ! 0  times  ! 0  runs  ! 0  /max  ! 0  /tot  ! ; init 
: kk 0 64 907 boot pfocus left tfocus ( creep right tfocus)
: //run init pause
: /con key? 0 test 0 or if dup 1  times  +! -1 + dup  /max  @ max  /max  ! dup  greg  !  /tot  +! then  greg  ! 1  runs  +!  runs  @ ( 1000 ) ( 10 ) 2 mod dup and drop if /con ;  then pause /con ;
: /real kk 12345 ; 778 list ( /go)

( block 359 )
( old code, not checked recently.)
: go ( entered with path hooked to initial adjacent node. boots it with package and makes it active.)
: //go ( entered with path tbl adr for the active node on stack.)

( block 360 )
( polyforth virtual machine) reclaim ( sram cluster mk1) sram load ( serial) 38 fh 3 loads reclaim ( stack) node 106 org 0x39 278 load 14 fh 2 loads ( coprocs) 22 fh 4 loads ( bitsy) node 105 18 fh 2 loads ( coprocs) 30 fh 4 loads ( flash to sram) 86 fh 2 loads reclaim ( erase and burn flash) 288 load ( spi speedup) 290 load ( serial wires) node 102 org 0x20
: start @ !b start ; ( 0x21 ) 1709 bin ( ganglia) 6 fh load ( snorkel) 10 fh load ( spi) 44 fh load

( block 361 )
( this load block compiles the f18 code for all nodes in the polyforth vm.)

( block 362 )


( block 363 )


( block 364 )


( block 365 )


( block 366 )
( generate ganglia) node 700 org 0x20 reclaim ( rlud)  r--- --l- ---u -d--  2 fh load 1716 bin ( 0x40 ) node 701 org 0x20 reclaim ( rlud)  --l- r--- ---u -d--  2 fh load 1717 bin ( 0x40 ) node 600 org 0x20 reclaim ( rlud)  r--- --l- -d-- ---u  2 fh load 1714 bin ( 0x40 ) node 601 org 0x20 reclaim ( rlud)  --l- r--- -d-- ---u  2 fh load 1715 bin ( 0x40 )

( block 367 )
( background nodes are filled by default with) ( ganglia, routing code in) ( 0x20 ) ( to) ( 0x3f ) ( thus they) ( may support either ide or neural messaging) ( until node is programmed some other way.) ( routing directions are geographic.) ( coded direction rlud 0123) ( four bins hold node orientations...) ( 1716 ) ( 100 ) ( 1717 ) ( 101 ) ( 1714 ) ( 000) ( 1715 ) ( 001) ( routing note- step count is relative to the node first receiving one of these messages. if) ( all counts zero will deliver to its neighbor) ( in direction indicated by two lsb of path. a) ( turn to deliver to right neighbor of turner) is not expressible ( because whole field zero.) third run must never have count 8 or more!

( block 368 )
( - ganglion template) ( a whence b whither) ( msg is focus call path cin-1 cout-1 code) ( 0x20 ) ( org rlud r--- --l- ---u -d--)
: aim ( 0x24 ) ( p-pa) dup 3 and 0x20 or b! @b dup b! !b @p ; ( / pump)  leap
: whither ( 0x2a ) ( p) -4 . + aim !b ( path) !b ( cnts) @ dup push !b @ dup push !b
: payload ( 0x30 ) begin @ !b unext begin @b ! unext ;
: /8 ( 0x32 ) ( n-n) 2/ 2/ 2/ ;
: pump ( 0x33 ) then pop a! @ dup
: turn ( pp) 0x3c and if drop whither ;  then drop dup 0xfc0 and if drop /8 /8 dup turn ;  then drop aim ( cnts) @ push @ push payload ; ( 0x40 )

( block 369 )
( ganglia route messages much like chuck's 'sea' delivers exchanges of) ( 1 ) ( or more word out and) ( 1 ) ( or more word reply to arbitrary nodes with) ( source routing. message structure is...)  focus call ( to port)  always there  pump call  interganglion only  path ( see below)  inter only  reply count ( words-1)  inter only  payload count ( words-1)  inter only  payload  always there  reply  always there ( path has) ( 3 ) ( 6-bit runs low order taken first) ( run encoded nnnndd path has 3 runs,) ( 2-bit direction rlud 0123) ( 4-bit count 1-relative zero deliver immed) ( 3rd run must be lt) ( 8 ) ( example from 708 to 617 go down 1 and right 8) ( 8 0 1 3 packed as 807) in octal. ( when an exchange is finished all) ( ganglia are back where they were) ( on receipt of focusing call.)

( block 370 )
( - snorkel) reclaim node 108 org 0 
: mk! ( fp'm)
: /! ( an-a) ( 0x0 ) push dup - !b over - !b pop !b ;
: a+ ( 0x3 ) ( ap-ap+) push 1 . + 0x10000 over and if or 1 then pop . + ;
: +@ ( 0xb ) ( a-an) a+
: /@ ( 0xc ) ( a-an) dup !b over !b @b ;
: @w ( 0xe ) ( a-a'u) /@ 7 for 2* 2* unext push +@ pop or ;
: dma ( 0x14 ) ( x/r) a+ @w push +@ push +@ pop begin pop pop dup push over push push drop ex next pop drop drop drop ( func) +@ push ;
: x16 ( 0x20 ) ( x) dma /@ ! a+ ;
: r16 ( 0x23 ) ( x) dma @ /! a+ ;
: x18 ( 0x26 ) ( x) dma @w ! a+ ;
: r18 ( 0x29 ) ( x) dma @ dup push 7 push begin 2/ 2/ unext 3 and /! a+ pop /! a+ ;
: fin ( 0x33 ) ( x) dup /! ( +three) dup - 0x8000 mk!
: idle ( 0x37 ) ( begin) @b 2 dup dup or /@ ( until) push dup /! pop over @w a! ( func) +@ push ; ( 0x40 ) 1605 bin reclaim exit

( block 371 )
 to activate snorkel ( wait till)  mmptr ( zero then write addr of a) sequence/x ( to it and stim.) mmptr ( zeroed after stim and you may queue 2nd) x ( by writing and posting another stim.)  x ( has) ( 2 ) ( wd)  port address ( followed by one or more) function/arg groups. ( all x)
: must
: be ( in bottom 64k of memory!) function/arg group ( is) ( 1 ) ( word)  jump adr ( in snork followed by) args ( if any.) funcs ( are...)  x/r 16/18 ( count18, adr20) fin ( done-flg awaken?) ( if focusing call desired it must be first word in first transmit.)  nothing about this code depends on using ganglia ... can source ide or any other reasonable protocol including direct stream or ad hoc node to node transfer.

( block 372 )


( block 373 )


( block 374 )
( pf.16 stack) org 0x0 
: '1+ ( w-w) ( 0x0 ) 1 . + : mask ( w-w) ( 0x2 ) 0xffff and ;
: '2/ ( w-w) ( 0x4 ) 2* 2* 2/ 2/ 2/ mask ;
: popt ( p-pt) ( 0x6 ) dup '1+ over x@ ;
: 'au! ( pst-p43) ( 0x8 ) x!
: popst ( p-pst) ( 0x9 ) popt
: pops ( pt-pst) ( 0xa ) push popt pop ;
: pop43 ( pst-p43st) ( 0xc ) push push popst pop pop ;
: '1- ( w-w) ( 0xe ) -1 . + mask ; ( 0x11 ) here org 0x37 
: psht ( pt-p) ( 0x37 ) push '1- pop over ( x! ;) ( 0x839 ) ( org  *)
: pshs ( pst-pt) ( 0x11 ) push psht pop ;
: pshw ( pstw-ptw) ( 0x13 ) push pshs pop ;
: 'sp! ( ptp-pst) ( 0x15 ) pshs popst ;
: 'drop ( pst-p3s) ( 0x17 ) drop pops ;
: 'over ( pst-pts) ( 0x18 ) over pshw ;


: sco ( x3) ( 0x19 ) 2* -if
( code.sx x4) ( 0x1a ) 2* ( up)  0x145  -until -d-- ;
( code.sm x4) ( 0x1d )  then drop push ; ( 0x1e )

( 3 ) ( words to recover!) org 0x21

( block 375 )
( the stack node abuts the memory driver. note that it includes x@ and friends.)


: psht ( is placed so it falls into) x!


: 'name ( denotes) vm instructions

: others ( are internal words)

( the external data stack grows downward, using pre-dec writes post-inc reads.)
( the internal stack holds the vm)  stack pointer ( and cached) s ( and) t

( 16-bit words are) 00.nnnn.nnnn.nnnn.nnnn

( block 376 )
( - stack cont'd)
: 'dup ( pst-ptt) ( 0x21 ) dup pshw ;
: 'swap ( st-ts) ( 0x22 ) over push push drop pop pop ;
: '2* ( w-w) ( 0x24 ) 2* mask ;
: 'or ( pst-p3w) ( 0x25 ) over - and
: 'xor ( pst-p3w) ( 0x26 ) or pops ;
: 'and ( pst-p3w) ( 0x27 ) and pops ;
: 'neg ( n-n) ( 0x28 ) '1-
: 'inv ( w-w) ( 0x29 ) begin - mask ;
: 'zeq ( w-f) ( 0x2a ) until begin dup or ;
: 'zlt ( n-f) ( 0x2c ) 2* 2* -until dup or 'inv ;
: 'um+ ( uu-uc) ( 0x2e ) + 0x10000 over and if or 1 ;
: 'nop ( 0x33 ) then ( begin) ;
: 'qdup ( pst-pst/ptt) ( 0x34 ) ( until)
: '- ( pst-p3n) ( 0x34 ) 'neg
: '+ ( pst-p3n) ( 0x35 ) + mask pops ;
( 0x37 ) 1700 bin

( block 377 )
( notes-)
     ( the initial sp is reset by) cold
     ( code must fit before block 740's)  psht
     ( some optimizations are commented out)
( so as not to lose the code for use later when/if some code is put in rom.)

( block 378 )
( pf.16 bitsy) org 0x0 
: 'else : bx@ ( a-w) ( 0x0 ) @p !b !b . ( /) @p x@ ( /)
@p !b @b ; ( /)  !p . . . ( /)
: bx!- ( aw-a') ( 0x4 ) @p !b !b dup ( /) @p . . . ( /)
@p !b !b . ( /) @p x! ( /)
: dec ( a-a') ( 0x8 ) -1 . + ;
: @2tos ( a-) ( 0xa ) bx@
: bpshw ( w-) ( 0xb ) @p !b !b ; ( /)  @p pshw ( /)
: 'rp@ ( rip-rip) ( 0xd ) push over bpshw pop ;
: 'lit ( rip-rip') ( 0xf ) dup @2tos
: inc ( a-a') ( 0x10 ) 1 . + ;
: 'con ( rip-rip) ( 0x12 ) bx@
: 'var ( rip-rip) ( 0x13 ) dup bpshw
: 'exit ( rip-r'i'p') ( 0x14 ) drop push
: popi ( r.p-r'ip) ( 0x15 ) inc
: geti ( r.p-rip) ( 0x16 ) dup bx@ pop ;


: bpopw ( -w) ( 0x18 ) @p !b @b ; ( /)  !p pops ( /)
: 'tor ( rip-rip) ( 0x1a ) push bx!- bpopw pop ;
: 'r@ ( rip-rip) ( 0x1d ) over bpshw ;
: 'rfrom ( rip-rip) ( 0x1e ) push bpshw popi ;

( block 379 )
( the return stack pointer 'r', top of return stack 'i', and vm instruction pointer 'p' live on the stack of the bitsy node. in stack pictures . shows return stack on right.)



( block 380 )
( - bitsy cont'd)
: 'exe ( rip-rip) ( 0x20 ) bpopw
: xxt ( ripx-rip) ( 0x21 ) dup 2* 2* -if
( code ripx2) ( 0x23 ) 2* -if
( code.b ripx3) ( 0x24 ) 2* -if
( code.bx ripx4) ( 0x25 ) 2* ( up)  0x145  -until -d-- ;
( code.bm ripx4) ( 0x28 )  then drop push ;
( code.s ripx3) ( 0x29 )  then @p !b push . ( /) @p @p . . !b pop !b .. @p !b ;  .. ( /) sco ..
( hi rix2) ( 0x2e ) then drop push push bx!- pop pop ;
: run ( rip-rip) ( 0x31 ) dup bx@ push inc pop xxt run ;

: 'if ( rip-rip') ( 0x35 ) bpopw if drop inc ;
 then drop bx@ ;
: 'rx? ( 0x39 ) @ bpshw ;
: 'tx? ( 0x3a ) @p !b @b . ( /) !p . . @p ( /) ! @ !b ;
: 'rp! ( rip-rip) ( 0x3d ) push bx!- bpopw geti ;
( 0x40 ) 1703 bin

( block 381 )
( the bit-threaded code technique confines execution to the)  bitsy ( loop and a small number of code words. pseudo-instruction format is)

 xx.0aaa.aaaa.aaaa.aaaa ( high level call)
xx.100x.xxaa.aaaa.aaaa ( xt in stack node)
xx.1010.xxaa.aaaa.aaaa ( xt in stack up)
xx.1011.xxaa.aaaa.aaaa ( xt in stack down)
xx.110x.xxaa.aaaa.aaaa ( xt in bitsy)
xx.1110.xxaa.aaaa.aaaa ( xt in bitsy up)
xx.1111.xxaa.aaaa.aaaa ( xt in bitsy down)

( this version uses sco in stack node to decode all its instructions.)

7 word decode for stack node
( code.s rix3) ( 0x28 )  then 2* -if
( code.sx rix4) ( 0x29 ) @p !b !b . ( /) @b sco ( /) drop ; ( code.sm) ( 0x2c )  then drop 0x1a000 or !b ;

( block 382 )
( stack down bxxx) node 6 org 0 
: xqt ( 0x0 ) @b push ex
: idle ( 0x1 ) @p !b xqt ; ( /)  drop !p . . ( /) ( 0x3 )


: ''s ( 0x3 ) @p !b @p . ( /) pshs ( /) psht ( /)
!b @p !b ; ( /)  dup pops ; ( 0x8 )


: 43xp ( op) ( 0x8 ) @p !b !b . ( /) pop43
: pops; ( 0xa ) @p !b ; ( /)  pops ;
: 'ex@ ( pst-p3w) ( 0xc ) @p !b pops; ; ( /)  ex@
: 'ex! ( pst-p54) ( 0xe ) @p 43xp ; ( /)  ex!
: 'cx? ( pst-p5f) ( 0x10 ) @p 43xp ; ( /)  cx?
: 'mk! ( pst-p54) ( 0x12 ) @p 43xp ; ( /)  - ex!
: 'sus ( 0x14 ) @p !b ; ( /)  @b drop ; ( 0x16 ) 1701 bin

( block 383 )

: idle ( main program of coprocessor nodes. feeds owner instruction to give us the vm opcode and executes it.)
opcodes  must return to idle when done.
 port ( code for owner)  must ( end with return.)


: ex@ ( and friends cost) ( 10 ) ( words, two more than the) ( 8 ) ( which they took in the stack node.)
: 'mk! ( msk f) ( 0 ) ( inverts) ( 0 ) ( so ex! can do the work.)
: 'sus ( suspends vm waiting for stimulus.)

( block 384 )


( block 385 )


( block 386 )
( stack up axxx) node 206 org 0 
: xqt ( 0x0 ) @b push ex
: idle ( 0x1 ) @p !b xqt ; ( /)  drop !p . . ( /) ( 0x3 )



: start ( 0x3 ) up b! idle ;
: free ( 0x5 ) @p !b pop ; ( /)  . ;  ..

( 0x7 )  1702 bin exit 
: who ( 0x7 ) @p !b @b @p ( /) !p @p ; ( /) , 206  + !b ;

( block 387 )

: idle ( main program of coprocessor nodes. feeds owner instruction to give us the vm opcode and executes it.)
opcodes  must return to idle when done.
 port ( code for owner)  must ( end with return.)



( block 388 )


( block 389 )


( block 390 )
( bitsy down fxxx) node 5 org 0 
: xqt ( 0x0 ) @b push ex
: idle ( 0x1 ) @p !b xqt ; ( /)  drop !p . . ( /) ( 0x3 )


: 'next ( 0x3 ) @p !b @b . ( /) push dup !p . ( /)
push zif @p !b @p . ( /) drop inc ( /) dup bx@
!b @p !b ; ( /)  pop inc ; ( /)  then
pop @p !b @p ( /) dec ( /) pop bx@ ; ( /)  !b drop ; ( 0xf ) 1704 bin

( block 391 )

: idle ( main program of coprocessor nodes. feeds owner instruction to give us the vm opcode and executes it.)
opcodes  must return to idle when done.
 port ( code for owner)  must ( end with return.)


: 'next ( length is) ( 12 ) ( vs) ( 4 ) ( or) ( 5 ) ( in bitsy, argh.)

( block 392 )


( block 393 )


( block 394 )
( bitsy up exxx) node 205 org 0 
: xqt ( 0x0 ) @b push ex
: idle ( 0x1 ) @p !b xqt ; ( /)  drop !p . . ( /) ( 0x3 )


: start ( 0x3 ) up b! idle ;
: free ( 0x5 ) @p !b pop ; ( /)  . ;  ..

( 0x7 )  exit
: no-op ( 0x3 ) @p !b ;  .. ( /) ;  .. ( 0x5 )
: upop ( 0x5 ) @p !b ;  .. ( /) bpopw ( 0x7 )
: upsh ( 0x7 ) @p !b ;  .. ( /) bpshw ( 0x9 )
: uin ( 0x9 ) ( -n) @p !b @b ; ( /)  !p .. ( 0xb )
: uout ( 0xb ) ( n) @p !b !b ; ( /)  @p .. ( 0xd )
: uid ( 0xd ) upop uin 205 . + uout upsh no-op ; ( 0x14 ) 1705 bin

( block 395 )

: idle ( main program of coprocessor nodes. feeds owner instruction to give us the vm opcode and executes it.)
opcodes  must return to idle when done.
 port ( code for owner)  must ( end with return.)



( block 396 )


( block 397 )


( block 398 )
( serial transmit) node 100 org 0x0 
: !bit ( im-i) ( 0x0 ) over and
if ( 0 ) ( dumb) 0x25555 ( maxim) ( 0x35555 ) !b drop ;
 then ( 1 ) ( dumb) 0x35555 ( maxim) ( 0x25555 ) !b drop ;
: putc ( dc-d) ( 0x5 ) -
: putchar ( di-d) ( 0x6 ) 0xff or 2*
9 for ( 0xa ) ( 1-start, 8-data, 1-stop bit)
     1 !bit 2/ over for . unext
next ( 0xe ) drop ( weak-pulldown) ( 0x15555 ) ( !b) ;

( 0xf ) org 0x20 ( programmed with abandon)
: start io b! right a! 2400 ( est.) ( 115200 ) ( baud)
( stopbit state dumb) 0x25555 ( maxim) ( 0x35555 ) !b
: wait ( d-.d) ( 0x27 ) @ -if ( tx!) putchar wait ;
      then ( !io) up a! ! .. @ right a! wait ;


: send ( cd) ( 0x2f ) over putc send ;
: send/ ( d) ( 0x31 ) 0x40 begin dup push putc
     pop 1 . + 0x5f and end ( 0x3a )  1706 bin

( block 399 )
( notes-)
     tx ( is inverted for compatibility with the boot node conventions, i.e. mark hi, space lo, data1 lo, data0 hi, start hi, stop lo.)


: putchar ( takes a clean inverted octet and transmits it low bit first via p17.)


: wait ( suspends while waiting for inverted character or a new delay value.)

      the first terminal operation must set
the delay!
      send ( and) send/ ( test the bit timing using external loop-back.)

( block 400 )
( - receive) node 200 org 0x28 
: @bit ( cm-c) @b - over - and push and pop or ;
: getc ( d-dc) ( 0x2b ) dup begin drop @b -until
: getchar ( dx-dc) ( 0x2d ) over 2/ for . unext ( 1/2 bit) 8 for ( 1-start, 8-data, 1-stop bits)
     0x1ffff @bit 2/ over for . unext
next 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 0xff and ;


: baud ( n-dd) ( 0x3a ) if dup ;  then - push
( 0x83d ) begin @b . -until ( at start-bit of space) ( 0x3e ) begin @b - -until ( at 1-bit)
( 0x3f ) begin @b . zif then . -until ( at 0-bits)
( 0x41 ) begin @b - zif then . -until ( stop-bit)
pop - ( n) dup 2/ . + ( 1.5n) dup ;


: auto ( 0x46 ) a push up a! @ baud ! pop a! dup !
: idle ( d) ( 0x4c ) @b -if getchar -
     @b 2* - -if over ! then drop drop idle ;  then 0x200 and .. if auto ;  then drop idle ;

( 0x58 ) org 0x20 ( programmed with some abandon)
: start io b! 0x5555 !b right a! 2400 idle ; ( 0x27 ) 1707 bin

( block 401 )
( notes-)
     rx ( is inverted for compatibility with the boot node conventions, i.e. mark hi, space lo, data1 lo, data0 hi, start hi, stop lo. received characters may have one stop bit.)


: getchar ( called after seeing leading edge of start bit. returns clean inverted character. must be called before start bit begins!)


: baud ( space is 1...1'0010.0000'0)
     ( stop bits ---' .hex..20. '--- start)


: idle

( block 402 )
( - interface) node 104 org 0x20
( programmed with abandon)
: start io b! right a! ahead
: rx? ( 0x24 ) 0x400 and .. if ( avail) up a! @ then
: rtn ( w-) ( 0x29 ) 0xffff and right a! !

: idle ( 0x2d ) then @b 2* ..  ' rx?  -until
     ( not read) 2*  ' idle  -until
     ( write) @ 2* 2* 2/ 2/ .. -if
: tx! ( c-) ( 0x33 ) @b 0x1000 and if ( full) drop rtn ;
     ( room)  then left a! over ! rtn ;
: iox ( c-) ( 0x3a ) then left a! !
     up a! begin @ - -until - rtn ; ( 0x40 ) 1708 bin

( block 403 )
( notes-)
      idle ( is a polling loop waiting for)
 right ( reading -) rx? ( returns)  16-bit inv
     character ( from recv queue or) 0 ( if)
     ( queue is empty.)
 right ( writing - do) tx! ( for)  16-bit inv
     character ( or)  iox ( for)  16-bit pos
     bit delay ( input.)

      tx! ( returns the)  16-bit inv character ( when the xmit queue is full and) 0 ( otherwise.)

      iox ( suspends until it puts the)  16-bit pos bit delay ( in the xmit queue and again while it discards any) inv characters ( in the recv queue before the new) pos bit delay ( arrives.)

( block 404 )
( spi flash sst25wf080) reclaim node 705 org 0 
: entry ( 0x0 ) pop a! ( delay) @
: nxt ( 0x1 ) ( d-d) @ push ex . nxt ;
: null ( 0x3 ) ( d) dup !
: done ( 0x4 ) ( d) -++ !b await ;
: cmd ( 0x7 ) ( d) dup select
: out ( 0x8 ) ( d) @ for @ 2* 2* 8obits zif drop ( pop drop) ;  then 8obits drop next ;
: byte ( 0x10 ) ( d-dw) dup dup or
: +byte ( 0x11 ) ( dw-dw) 7 push begin begin --- !b --+ !b . @b -while drop - 2* - next ;  then drop 2* next ;
: bytin ( 0x1e ) ( d) @ for byte zif ! done ;  then +byte ! next done ;
: wout ( 0x25 ) ( d) @ push .. zif begin select 0x2b400 8obits drop  swap  then @ 2* 2* 8obits 8obits drop select dup begin drop @b -until drop next null ;
: slob ( 0x33 ) ( d-dw) dup dup or
: +slob ( 0x34 ) ( dw-dw) 7 push ibits ;
: slowin ( 0x37 ) ( d) @ for slob zif ! done ;  then +slob ! next done ; ( 0x3e ) 1606 bin reclaim

( block 405 )
( timing roughly) ( 53 ) ( ns 19.2 mhz read clock) ( clk low 16.5 ns 30. mhz so this is good for) ( all sst25wfxxx parts as well. with mk1 sram) ( we get) ( 555 ) ( us block read time.) ( registers b-io a-boss t-delay r-cmd. command) ( stream starts with dly and then funcs...)
: done ( deselect)  and end operation. 
: null ( does so after sending a dummy byte in.)
: cmd ( selects and pumps a command)
: out ( given nbyt-1 sends nbyt bytes to device.)
: bytin ( given nbyt-1 receives nbyt bytes from) ( the device)  and ends operation. 
: wout ( given nwds writes nwds 16-bit words to) ( the device in aai mode. used immed after) ( address, should be followed by wrdi rdsr.)
: slowin ( given nbyt-1 receives nbyt bytes from) ( the device. used for slow mmc.)

( block 406 )
( minimal spi) reclaim node 705 org 0 ( working before speed up)
: entry ( 0x0 ) pop a! ( delay) @
: nxt ( 0x1 ) ( d-d) @ push ex . nxt ;
: null ( 0x3 ) ( d) dup !
: done ( 0x4 ) ( d) -++ !b await ;
: cmd ( 0x7 ) ( d) dup select
: out ( 0x8 ) ( d) @ for @ 2* 2* 8obits zif drop ;  then 8obits drop next ;
: byte ( 0x10 ) ( d-dw) dup dup or
: +byte ( 0x11 ) ( dw-dw) 7 push ibits ;
: bytin ( 0x14 ) ( d) @ for byte zif ! done ;  then +byte ! next done ; ( 0x1b ) 1606 bin reclaim

( block 407 )
( minimal code but slow; timing roughly) ( 64 ) ( ns or 15.4 mhz read clock, low) ( 31 ) ( ns; write) ( 76 ) ( ns or 13.2 mhz. when delay is zero. addl delay about) ( 4 ) ( ns per count.) ( command stream starts with dly and then funcs)
: done ( deselect)  and end operation. 
: null ( does so after sending a dummy byte in.)
: cmd ( selects and pumps a command)
: out ( given nbyt-1 sends nbyt bytes to device.)
: bytin ( given nbyt-1 receives nbyt bytes from) ( the device)  and ends operation.

( block 408 )


( block 409 )


( block 410 )


( block 411 )


( block 412 )


( block 413 )


( block 414 )


( block 415 )


( block 416 )


( block 417 )


( block 418 )


( block 419 )


( block 420 )


( block 421 )


( block 422 )


( block 423 )


( block 424 )


( block 425 )


( block 426 )


( block 427 )


( block 428 )


( block 429 )


( block 430 )


( block 431 )


( block 432 )


( block 433 )


( block 434 )


( block 435 )


( block 436 )


( block 437 )


( block 438 )


( block 439 )


( block 440 )


( block 441 )


( block 442 )


( block 443 )


( block 444 )


( block 445 )


( block 446 )
( - sram loader nodes) ( wires) node 605 org 0 
: wire ( b! a!) @ dup !b for @ !b unext warm ; ( 0x4 ) 1711 bin ( sram loader node) ( 108 ) node 108 org 0x39 278 load org 0
: start ( 0x0 ) up a! left b! 0 @ dup push over x! begin 1 . + @ over x! next warm ; ( 0xd ) 1713 bin

( block 447 )
( minimal version of plumbing for sram boot from flash. wires are compiled only once and are) ( initialized with source port in a and dest) ( port in b.) ( message consists of word count n-1 followed by n words to be passed along.) ( node) ( 108 ) ( now loads the image received from) ( flash into sram.) ( 208 ) ( is just another wire) ( however, the generic sram interface code is) ( compiled at the usual place anyway, so this) ( bin can be used by both the streamer and the) ( ide)

( block 448 )
( - spi flash) ( 8 ) ( bits) node 705 org 0 host  :: resume nnc 2 * 0x8000 + block @ 0xfffff and
     18 8 */ 4 * lit ; target 
: wait ( dw-dw) ( 0x0 ) select dup begin drop @b -until drop select ;
: 2cmd ( dw-d) ( 0x4 ) select 8obits
: cmd ( dw-d) select
: !8 ( dw-d) 8obits drop ;
: set ( -d) ( 0x9 ) io b! ( fast) 5 ;
: fet ( ah al-d) ( 0xc ) push push set ( read) 0xc00 cmd pop !8 pop 8obits !8 ;
: 16ibits ( d-db) ( 0x12 ) dup 15 for
rbit ibit - next 0xffff and ;
: start ( 0x19 ) down a! 0 0x20000 fet
16ibits dup ! for 16ibits ! next
     resume fet 18ibits 0x1e000 . + - -if
: done io b! 20 20 -++ half warm ;  then
5 resume push spicmd spi-boot ;
( 0x34 ) 1710 bin

( block 449 )

: start ( 1st word read is count in words)

( block 450 )
( polyforth ide boot) host load loader load ( kill boots) 0 708 hook 0 -hook  :: s1+ ( nm-mn') swap  1  + ; ( custom routes) 2 fh load sram 4 + load ( select) pfp0 'pths ! pfp1 'pths 1 + ! s708 'pths 2 + ! ( vm build tools) 4 fh load 12 fh load ( sram) 6 fh load 1 ship :: !img ( n) push  fbuf  0 begin over 2@ swab over sm swap  2  + s1+ next drop drop ; :: !nuc  chr  @ 2/  1  + !img ; 1 108 hook !nuc unfoc 1 -hook ( rest) 470 load 2 ship panel upd ?ram

( block 451 )
( customize ide for polyforth development.)


: pf ( loads polyforth f18 code, nucleus in sram, and starts it up.)

[compile] ***no [compile] canonical [compile] opcodes***
 use the  'remote'  ones

( block 452 )
( - custom ide paths)
: pfp0 align create  708 707 to 607 207 to 206 205 to , -1
: pfp1 align create ( sram)  708 108 to 107 7 to 8 9 to , -1

( block 453 )
( paths) ( 0 ) ( and) ( 1 ) ( are customized for interactive devel and testing of polyforth.)
: pfp0 ( is not used by the loading procedures and is available for detailed application testing. if more paths are needed in testing, stuff new path vectors after) pf ( is loaded.)
: pfp1 ( is used after reset to load and start the sram cluster, then boot sram as needed.)

( block 454 )
( - sram user code from nodes 106, 108,) ( 207 )
: 2lit' ( nn-) swap lit' lit' ;
: sm ( wa-) 2lit'  0x39 ( x!)  call ;
: sem ( wap-) push 2lit' pop lit'  0x3a ( ex!)  call ;
: fm ( a-w) lit'  0x3c ( x@)  call
: get ( -w) upd  stak  @ rdrop ;
: fem ( ap-w) 2lit'  0x3d ( ex@)  call get ;
: 4lit' ( nnnn-) push push 2lit' pop pop 2lit' ;
: cxm ( wapw-f) 4lit'  0x3e ( cx?)  call get ;

( sram test code)
: fmem ( ap-...) 8 for push dup i fem
     s1+ pop next drop drop ;
: smem ( wapn-) for push over over i sem
     s1+ s1+ pop next drop drop drop ;
: n2x ( wapn-) 4lit'  0x42 ( n2x)  call ;
: nqx ( wapn-) 4lit'  0x4a ( nqx)  call ;



( block 455 )
( this tester code assumes the ide is hooked to one of the sram user nodes.)

( block 456 )
( - ph0 sram setup)

( kill boot nodes) ( 2 ) ( 2 ) ( hook) ( 2 ) ( -hook) ( 1 ) ( path)

( sram setup) sram 2 + load

( temporary) 108 +node 1713 /ram left /b

( block 457 )
( load sram cluster for booting pf nucleus)

( this is done with ide path) ( 1 ) ( from) ( 708 ) ( down to) ( 108 ) ( before any of the rest of the chip is set up.)

( after it's completed, the whole rest of the chip can be booted using the serpentine path 2. this relatively byzantine method is used instead of simply reloading the sram with a more regular path so that the methods will still work with external dram.)

( this block leaves path) ( 1 ) ( connected to sram for use by !pf)

( block 458 )


( block 459 )


( block 460 )
( install pf in flash) empty compile streamer load 0 fh loaded ! nores ( read pfdisk.blk) 2 fh load fbuf source ! 4607 len ! ( display nuc length) len @ 1 + 2 * 8 18 */ leng ! 0x8000 stream nip ers ( burn nucleus) stream 0x8000 swap burn ( generate boot stream) 4 fh load

( block 461 )
( load this block to install polyforth for flash booting. just follow instructions.) ( burns nucleus to flash starting at 32k then) ( generates and burns full chip boot stream.)

( block 462 )
( - read pf nucleus) :var ft :var chr [0x2400]
: a-b ( a-b) 2* 2* ;
: b-a ( b-a)  3  + 2/ 2/ ;
: fbuf ( -a)  nnc 2 * 0x8000 + block a-b  ;
: +pf  0 fnam b-a  r/o fopen if  ft  ! ;  then drop abort ;
: -pf  ft  @  0  + if fclose 0 then  ft  ! ;
: @nuc +pf  fbuf  9216  ft  @ frd  chr  ! -pf ; named ( pf/pfdisk.blk) @nuc

( block 463 )


( block 464 )
( - burn pf boot stream)
empty ( 1st pass) compile streamer load
framer load ( the stream) 2 fh load

empty ( 2nd pass) compile streamer load
framer load ( the stream) 2 fh load

0 fh loaded !
( write stream into flash)
( 0 ) ( stream nip ers)
( display stream length) strlen leng ! stream 0 swap 18burn

( block 465 )
( pf stream)

( two passes required to calculate address)
( to resume booting from after loading sram)
( and compile it into node) ( 705 )

( block 466 )
( -- generate pf stream)

( speedup)
     0 0 3 1608 /root

( default) entire course
( sram driver) sram 2 + load ( flash to sram) 2 fh load frame adjust ( resume point) fresh ( residual) sram 4 + load s705 course ( rest of chip) 470 load ( retain asynch boot) 708 +node 0xaa /p frame

( block 467 )


( block 468 )
( --- load polyforth nucleus)
: /nwire ( in out) /b /a 0 4  1711  /part 0 /p ; 705 +node 1710 /ram 0x19 /p 605 +node down left /nwire 606 +node left right /nwire 607 +node right left /nwire 608 +node left up /nwire 508 +node up down /nwire 408 +node down up /nwire 308 +node up down /nwire 208 +node down up /nwire 108 +node 1713 /ram left /b 0 /p

( block 469 )


( block 470 )
( pf load descriptors)
: l, ( nn) dup +node 100 /mod 1 and 2* swap 1 and + 1714 + push 32 32 pop /part ( warm) 0xa9 /p ;
: ganglia nns for i -1 + n-nn l, next ; ( sea of) ganglia ( snorkel) 108 +node 1605 /ram left /b 0x37 /p ( sram cluster mk1) sram 2 + load ( virtual machine) 2 fh load ( serial terminal) 4 fh load ( additional i/o) 6 fh load

( block 471 )
( this block describes entire chip's loading for polyforth boot environment.) ( suitable for use with ide loader, streamer,) ( and softsim.) ( all nodes not otherwise programmed are loaded with ganglia for ad hoc routing.) ( the sram cluster is invoked here for complete documentation although it has been loaded) ( earlier and is excluded from the path used by the main stream.)

( block 472 )
( - virtual machine)

( buds) 205 +node 1705 /ram up /b 1 /p
     5 +node 1704 /ram down /b 1 /p
     206 +node 1702 /ram up /b right ( 1 ) /p
     6 +node 1701 /ram down /b 1 /p

( bitsy) 105 +node 1703 /ram
     0xffe0 0x15555 ( 'cold) 1 3 /stack
     left /b right /a 0x31 /p

( stack) 106 +node 1700 /ram
     0xffff 0 0 3 /stack
     right /b left /p

( block 473 )


( block 474 )
( - serial terminal)


: /wire ( io) 0x20 1  1709  /part /b /a  0x20  /p ;

104 +node 1708 /ram 0x20 /p
103 +node left right /wire
102 +node right left /wire
101 +node left right /wire
100 +node 1706 /ram 0x20 /p

204 +node left up /wire
203 +node right left /wire
202 +node left right /wire
201 +node right left /wire
200 +node 1707 /ram 0x20 /p

( block 475 )


( block 476 )
( - additional i/o) ( spi) 705 +node 1606 /ram io /b 0xa9 /p

( block 477 )


( block 478 )


( block 479 )


( block 480 )
( g144a12 ats test components)

( pkg) ( 2000 ) ( to) ( 2017 ) 482 18 loads
( pkg) ( 2100 ) ( to) ( 2117 ) 518 18 loads
( pkg) ( 2200 ) ( to) ( 2208 ) 554 9 loads

( ats/ide parts) ( 1200 ) ( to) ( 1206 ) 630 7 loads

( steven mem-random xxxx) ( 576 ) ( 1 ) ( loads)
( 1400 ) ( to) ( 1400 ) ( 648 ) ( 1 ) ( loads)

( block 481 )


( block 482 )
( 2000 ) ( port tests)
( creeper) reclaim node 0 1344 load org 0x1b 
: release ( 0x1b ) @p ! ; ( /)  ; ( /)
: bit ( 0x1d ) ( n-nn) @p ! dup dup ( /) @p !p .. ( /)
! @ or ;
: walk ( 0x20 ) ( n) 17 for bit if pop !b pop
release ;  then drop 2* next drop ;
( 0x28 ) org 4 : ftst a 0x1ff and 0x13400 or
: tst ( 0x8 ) ( cport) dup a! !
0x15554 dup walk dup - walk release dup or !b ;
: trd ( 0xf ) leap ( tr) : td ( 0x10 ) @p tst ;  -d--
: tdr ( 0x12 ) td : tr ( 0x13 ) then @p tst ;  r---
: tdl ( 0x15 ) td : tl ( 0x16 ) @p tst ;  --l-
: tru ( 0x18 ) tr : tu ( 0x19 ) @p tst ;  ---u
( 0x1b )  2000 bin

( block 483 )
( port tests)
: bit ( send and receive 1 bit pattern via port)
: walk ( test with pattern shifted left) ( 18 ) ( times)
: tst ( focus neighbor with a call then)
( walk with) ( 1 ) ( bit set and) ( 1 ) ( bit clear)
( shifting left on the test node)
: release ( causes node under test to return .)
( error code) ( 0 ) ( for success ,)
( loop index for failure)
parameter ( is ignored)

tests ( on single neighbor and on pairs)
 address 0x4 ( tests the) tfocused ( neighbor)
0x13 ( tests the) right ( neighbor)
0x10 ( tests the) down ( neighbor)
0x16 ( tests the) left ( neighbor)
0x19 ( tests the) up ( neighbor)
0x15 ( tests the) down ( and) left ( neighbors)
0x12 ( tests the) down ( and) right ( neighbors)
0x18 ( tests the) right ( and) up ( neighbors)
0xf ( tests the) right ( and) down ( neighbors)

( block 484 )
( 2001 ) ( port tests with 2*)
( creeper) reclaim node 0 1344 load org 0x1b 
: release ( 0x1b ) @p ! ; ( /)  ; ( /)
: bit ( 0x1d ) ( n-nn) @p ! dup dup ( /) @p 2* !p .. ( /)
! 2* @ or ;
: walk ( 0x21 ) ( n) 17 for bit if pop !b pop
release ;  then drop 2* next drop ;
( 0x2a ) org 4 : ftst a 0x1ff and 0x13400 or
: tst ( 0x8 ) ( cport) dup a! !
0x15554 dup walk dup - walk release dup or !b ;
: trd ( 0xf ) leap ( tr)
: td ( 0x10 ) @p tst ;  -d--
: tdr ( 0x12 ) td : tr ( 0x13 ) then @p tst ;  r---
: tdl ( 0x15 ) td : tl ( 0x16 ) @p tst ;  --l-
: tru ( 0x18 ) tr : tu ( 0x19 ) @p tst ;  ---u
( 0x1b )  2001 bin

( block 485 )
( port tests)
: bit ( send and receive 1 bit pattern via port)
: walk ( test with pattern shifted left) ( 18 ) ( times)
: tst ( focus neighbor with a call then)
( walk with) ( 1 ) ( bit set and) ( 1 ) ( bit clear)
: release ( causes node under test to return .)
( error code) ( 0 ) ( for success ,)
( loop index for failure)
parameter ( is ignored)

tests ( on single neighbor and on pairs)
 address 0x4 ( tests the) tfocused ( neighbor)
0x13 ( tests the) right ( neighbor)
0x10 ( tests the) down ( neighbor)
0x16 ( tests the) left ( neighbor)
0x19 ( tests the) up ( neighbor)
0x15 ( tests the) down ( and) left ( neighbors)
0x12 ( tests the) down ( and) right ( neighbors)
0x18 ( tests the) right ( and) up ( neighbors)
0xf ( tests the) right ( and) down ( neighbors)

( block 486 )
( 2002 ) ( extensive ram test jeff)
( creeper) reclaim node 0 1344 load org 0x28 
: err  org 4 
: test ( n1) @p ! @p dup ( ') 0x3f push dup dup
! @p ! ( ') or dup a! .
@p ! ( ') begin dup !+ unext .. ( 0xb ) ( erased)
for

0x19999 @p ! dup ( ') @p ! @ .
! @p ! . ( ') !b @p !
@ or if ( 0x12 ) pop err ;  then ( 0x13 ) ( test1)
0xcccc dup ! @p ( ') @ !b dup dup
! @ or if ( 0x18 ) pop err ;  then ( 0x19 ) ( 0 test2)
@p ! . ( ') or ! . ( erased)

drop @p ! @p ( ') dup ( 0 0) - ( 0x3ffff ) ! 0x3e
! @p ! ( ') @+ !b push ( 0x0 )
@ - if ( 0x21 ) pop err ;  then ( 0x22 ) ( test3)
drop @p ! ( ') begin @+ !b unext . ( 0x0 )
0x3e for @ if pop pop
: err ( 0x28 ) 1 + !b ;  then ( 0x2a ) ( test4)
drop next
@p ! . . ( ') dup !+ . next ( erased)
dup dup or !b ; ( 0x30 ) 2002 bin

( block 487 )
( test tests neighbor's memory)

( tests the tfocused node node's ram.)
apocryphal documentation follows

( 19999 cccc test shorts to bits two bits away)
( 3ffff) ( 0x0 ) ( test shorts to bits one bit away)
( tests for shorts between two addresses)
( by reading) ( 64 ) ( words after each) ( 0x3ffff ) ( !)


( block 488 )
( 2003 ) ( testing t and s)
( creeper) reclaim node 0 1344 load org 0x20 
: echo ( 0x20 ) ( n-n) @p ! dup .. ( /) @p - dup .. ( /)
! @p ! .. ( /) drop !p .. ( /) - @ or ; org 4 
: test ( 0x4 ) ( n) 17 for dup echo
if pop 1 . + !b ;  then drop 2* next
dup or !b ; ( 0xe ) 2003 bin

( block 489 )
( testing t and s)

( intended to isolate testing to t and s)
( non-zero return value identifies bad bit)

address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success ,)
( loop index for failure)

( block 490 )
( 2004 ) ( testing t and r)
( creeper) reclaim node 0 1344 load org 0x20 
: echo ( 0x20 ) ( n-n) @p ! dup .. ( /) @p - push .. ( /)
! @p ! .. ( /) pop !p .. ( /) - @ or ; org 4 
: test ( 0x4 ) ( n) 17 for dup echo
if pop 1 . + !b ;  then drop 2* next
dup or !b ; ( 0xe ) 2004 bin

( block 491 )
( testing t and s)

( intended to isolate testing to t and r)
( non-zero return value identifies bad bit)

address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success ,)
( loop index for failure)

( block 492 )
( 2005 ) ( testing stack registers)
( creeper) reclaim node 0 1344 load org 6 
: put ( n) @p ! ! ; ( /)  @p .. ( /)
: get ( -n) @p ! @ ; ( /)  !p .. ( /)
: stack ( 0xa ) 1 9 for dup put 2* next
9 for 2/ get over or if pop 1 . + !b
pop ;  then drop next ; ( 0x18 ) org 4 
: start ( n) stack dup or !b ; ( 0x6 ) 2005 bin

( block 493 )
( testing stack registers)

( fill the stack registers with unique)
( numbers and read them back. error code)
( identifies the register that failed the test.)

address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success ,)
( loop index for failure)

( block 494 )
( 2006 ) ( testing return stack registers)
( creeper) reclaim node 0 1344 load ( 0x4 )  ahead
: !error ( n) 1 !b ;
: put ( 0x7 ) ( n) @p ! ! ; ( /)  @p push .. ( /)
: get ( 0x9 ) ( -n) @p ! @ ; ( /)  pop !p .. ( /)
: fill ( 0xb ) ( n-n) 8 for - dup put next ;
: check ( 0x11 ) ( n-f) leap - then fill -
9 for - get over or .. if !error pop ;
 then drop next ;
: test ( n) then 0 check 0x15555 check
( ..) 0x19999 check 0x33333 check
( ..) dup or !b ;
( 0x26 ) 2006 bin

( block 495 )
( testing return stack registers)

( fill neighbor return stack with alternating)
( inverted patterns , then read back and verify each pattern ; relies on)  s ( and) t ( of uut)
( and instructions) @p !p push pop ( in the port)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success ,) ( 1 ) ( for failure)

( comment) - ( after) fill ( to force failure)

( block 496 )
( 2007 ) ( mark ram test) ( 200 ) ( node)
( creeper) reclaim node 0 1344 load  ahead
: store @p ! ;  .. ( /) !+ .. ( /)
: fetch ( -n) @p ! @ ; ( /)  @+ !b drop .. ( /)
: /neighbor 4 for @p ! unext ;
: /stack ( 0xc ) 0x15555 ( 0x2aaaa ) dup - over over over
over over over over over over .. ( 0x11 ) ;


: go ( entry) ( 0x12 ) then /neighbor /stack
: testmem ( 0x14 ) 3 ( 65535 ) for
@p ! drop .. ( /) dup or a! .. ( /)
0x3f for store next 0x3f for fetch or if
     pop pop 3 ( 65535 ) or 1 . + !b ;
 then drop next next
( good) 0x0 ( 0x12345 ) !b ; ( 0x29 ) 2007 bin

( block 497 )
( worst case ram test looking for store failures when driving weak inverter high.) this test preserves b, a, and p.


: store ( makes target store next value in next wd)
: fetch ( makes target return next word in ram)
: /stack ( executed in either node sets stack to alternating) ( 0x15555 ) ( and) ( 0x2aaaa ) ( with) ( 0x15555 ) ( on top.)
: /neighbor ( feeds) /stack ( to target node. doesn't pass the last word - return.)


: go ( sets both nodes' stacks that way then begins the) testmem
: testmem ( runs test cycles, must do at least 2. each cycle switches polarity) ( 0x15555 ) ( or) ( 0x2aaaa ) ( for first word stored, then stores alternating values into all ram in target. reads back and compares. if all cycles run ok, returns zero status. otherwise returns the) ( 1 ) ( relative cycle number in which the failure occurred.)

( block 498 )
( 2008 ) ( mark r d stack test)
( creeper) reclaim node 0 1344 load  ahead
: store dup ! dup ! dup ! ! ;
: fetch ( -n) @p ! @ ; ( /)  !b .. ( /)
: /neighbor @p ! ! .. @p ..
3 for @p ! unext ;  ..
: /stack dup - over .. ( /) over over ( -)
over .. ( /) over over over .. ( /) over .. ( /) ;
: t-stk ( 0x14 )
dup /neighbor /stack ( 0x16 )
( 0xfffe ) 8 for
@p .. push push push .. store
fetch drop @p .. pop pop pop .. store

9 for fetch or .. if pop pop 0xffff and pop drop !b ;  then drop
next next ;
 then ( 0x2b )  org 0x2b 
: full ( 0x2b ) 0x2aaaa t-stk dup or t-stk 0x33333 t-stk 0x19999 t-stk dup or t-stk ( 0x0 ) dup or !b ;
( 0x36 ) 2008 bin

( block 499 )
( testing return and data stacks registers)
( also mulitple overs pops and pushes in the port)

( fill neighbor return stack with alternating)
( inverted patterns , then push to return stack then pop to data stack then read back and verify each pattern ; relies on)  b s t r r-stack ( and) d-stack ( of uut)
( and instructions) @p !b over push pop ( in the port)

 address 0x2b 
: full ( tests the)  tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success , next count for failure)

( comment) - ( in)  /stack ( after)  over ( to force failure)

( block 500 )
( 2009 ) ( +* a shift test)
( creeper) reclaim node 0 1344 load  ahead
: !error ( n) 1 !b ;
: init ( s) @p ! ! ; ( /)  @p .. ( /)
: check ( an-a) over or if !error pop pop ;
 then drop ;
: step ( tan-t'a') push ..
@p ! ! .. ( /) @p a! @p .. ( /)
! @p ! . ( /) +* !p a !p ( /) @ @ pop check ;
: start then
1 init 0 0x15555 0x2aaaa step 0x15555 step
( ......) 0 0x19999 0x2cccc step 0x16666 step
2 init 0 0x15555 0xaaaa step 0x25555 step
( ......) 0 0x19999 0xcccc step 0x26666 step
dup or !b ;
( 0x35 ) 2009 bin

( block 501 )
( testing a shifts by)  +*

( tests the) ( 4 ) ( combinations of shifting 1/0)
( from t for add/notadd behavior of +* . the)
( 0x19999 ) ( group checks the double shift error seen previously ; relies on) s ( and) t ( of uut)
( and instructions) @p !p +* a a! ( in the port)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success ,) ( 1 ) ( for failure)

( replace pattern before) step ( with) 0
( to force failure)

( block 502 )
( 2010 ) ( t s a and r data path tests)
( creeper) reclaim node 0 1344 load  ahead
: check or if pop !b pop ;  then drop ;
: -t- ( n) dup @p ! .. ( /) @p !p .. ( /) ! @ ( 2*) check ;
: -s- ( n) dup @p ! dup ( /) @p @p !p !p ( /)
! ! @ drop @ ( 2*) check ;
: t-a ( n) dup @p ! .. ( /) @p a! a !p ( /)
! @ ( 2*) check ;
: t-r ( n) dup @p ! .. ( /) @p push pop !p ( /)
! @ ( 2*) check ;
: start then ( 0x19 ) 0x3ffff dup - 0x2aaaa
dup - 0x33333 dup - 0x6666 dup - dup dup drop
256 for drop -t- ( 0x24 ) -s- ( 0x25 )
( ............) t-a ( 0x26 ) t-r ( 0x27 ) next dup or !b ; ( 0x29 ) 2010 bin

( block 503 )
( testing t s a and r data paths)

( does) ( 32 ) ( reps of) ( 8 ) ( patterns between t and)
( the other registers; relies on instructions)
 @p !p a! a push pop ( in the port)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success, address after)
( test for failure)

( uncomment) 2* ( in each test to force failure)

( block 504 )
( 2011 ) ( gpio pin test)
( creeper) reclaim node 0 1344 load  ahead
: !it ( n) ( 0x5 ) @p drop !p ;
: its ( n-n) ( 0x6 ) 0 and ;
: ++ ( 0x8 ) -1 : !io its ! ; : -- 0x2aaaa !io ;
: 500ns ( n) ( 0xe ) 199 for unext ;
: .hi ( -n) ( 0x11 ) 15 for @ its if
drop pop ;  then drop next dup dup or ;
: .lo ( 0x18 ) for @ 0x2aaaa and its while drop next
dup dup or ;  then drop pop ;
: start ( n) ( 0x20 ) then !it io a!
++ 500ns ( wpd) 0x15555 !io 8191 .lo
-16 -- and 500ns ++ .hi or 500ns
2* -- 2* 2* 2* 15 .lo or !b ;
( 0x34 ) 2011 bin

( block 505 )
( drive test of a single gpio pin whose control bits are nonzero in the argument.)

( while testing a pin any other pins are set at high impedance so we can prove all three drive transistors work for this pin and detect any opens. other tests look for shorts between pins)

( block 506 )
( 2012 ) ( mark d stack test)
( creeper) reclaim node 0 1344 load  ahead
: fetch ( -n) @p ! @ ; ( //)  !b .. ( /)
: /neighbor @p ! ! .. @p ..
3 for @p ! unext ;  ..
: /stack ( 0xc ) dup - over .. ( /) over over
over .. ( /) over over over .. ( /) over ( -) . .. ( /) ;
: d-stack ( 0x11 ) 0x8 for dup - /neighbor /stack ( 0x16 ) next
12 ( 0x0 ) for drop fetch or if pop pop 0xffff and ( !b) pop ( and) drop !b ;  then
next ;
( 0x21 ) org 0x2a  then
: full ( 0x2a ) 0x2aaaa d-stack dup or d-stack 0x33333 d-stack 0x19999 d-stack dup or d-stack
!b ; ( 0x35 ) 2012 bin

( block 507 )
( testing data stack registers)
( also overs in the port)

( fill neighbor return stack with alternating)
( inverted patterns , then read back and verify each pattern ; relies on)  b s t ( and) d-stack ( of uut)
( and instructions) @p !b over ( in the port)

 address 0x2a 
: full ( tests the)  tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success , next count for failure)

( comment) - ( in)  /stack ( after)  over ( to force failure)

( block 508 )
( 2013 ) ( io data path tests)
( creeper) reclaim node 0 1344 load  ahead
: check ( nn) or if pop !b pop ;  then drop ;
: t-io ( mn-m) 0x15555 or dup @p ( /) @p ! @ !p ( /)
! ! @ or over and over check ;
: start ( m) then ( 0xe ) if 0 for
io @p ! .. ( /) @p a! .. ( /) !
dup t-io ( 0x16 ) 0 t-io ( 0x18 ) next then dup or !b ; ( 0x1a ) 2013 bin

( block 509 )
( testing io data path)

( checks that the masked bits return their)
( inverse ; relies on)  a ( of uut)
( and instructions) @p !p ! @ ( in the port)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is a mask for the io bits)
( to be tested . error code) ( 0 ) ( for success,)
( test's return address for failure)

( include unwritable bits in the mask)
( to force failure)

( block 510 )
( 2014 ) ( set/clear carry test)
( creeper) reclaim node 0 1344 load

org 0x2a ( test tools)
: +c ( 0x2a ) ( n-c) a 0x200 or !
: +@ ( 0x2d ) ( n-c) @p ! dup . ( /) . . . @p ( /)
( ..) ( 0x2f ) ! @p ! . ( /) @p . + !p ( /) ! @ a ! ;
: ?t ( 0x33 ) ( c) or if pop !b pop then drop ; ( 0x36 )

org 0x4 ( test start)
( 0x4 ) ( post args)  push 0x20000 0x0 begin
( 0x7 ) ( clr nxt) dup +c ( ign was) drop ..
( 0x9 ) ( set nxt) over +c ( tst clr) over ?t
( 0xb ) ( set nxt) over +c ( tst set) 0x1 ?t
( 0xe ) ( clr nxt) dup +c ( tst set) 0x1 ?t
( 0x11 ) ( clr nxt) dup +c ( tst clr) over ?t
( 0x13 ) ( nop nxt) over +@ ( see nop) over ?t
( 0x15 ) ( set nxt) over +c ( tst clr) over ?t
( 0x17 ) ( nop nxt) dup +@ ( see nop) over ?t
( 0x19 ) ( clr nxt) dup +c ( tst set) 0x1 ?t
( 0x1c ) next ( pass) !b drop ;
( 0x1e ) 2014 bin

( block 511 )
( test)  p9 ( control of carry)

( verify that neighbor carry can be set or)
( cleared under control of p9 and that carry is preserved when p9 is zero.)

( depends upon uut) p9 cry s ( and) t ( as well as)
( uut) jump @p !p . + ( in port.)
( test starts at) ( 0x4 ) ( with loop count input.)
( 12 ) ( words of ram are unused.)
( error code is) ?t ( return address.)
( verify by defeating any) ?t ( parameter.)


: +@ ( calculate n+n in test node, returning c)
( then clear tested's p9.)
: +c ( set p9 in test node prior to add.)
: ?t ( match result to expected and abort with)
( call address as return code in case of error.)  note ( that loop count will clear high)  r ( bits.)

( block 512 )
( 2015 ) ( mark @p test)
( creeper) reclaim node 0 1344 load ( 0x4 )  ahead

: seq ( -n) ( 0x5 ) 63 .. a push 6 a!
if dup -1 . + ! pop a! ;
 then drop 63 ! pop a! ( @p!bunext;) 0x5b75 ;
: init ( 0x11 ) @p ! @p .. ( /) @p a! .. ( /)  , 1  !
63 for seq @p ! ! .. ( /) @p !+ .. ( /) next
@p ! a .. ( /) @p push .. ( /)
! @p ! @p ( /) @p push .. ( /)  , 63
 ! @p ! ; ( /)  dup or push ; ( /)
: /@p ( n) ( 0x21 ) then init
63 for @ seq ( -) or .. if pop !b ;
 then drop next dup or !b ;
( 0x2a ) 2015 bin

( block 513 )
( testing @p)

( does) ( 64 ) ( reps of @p on target covering all ram addresses; relies on target port instructions;)  @p a! !+ dup or push ;
( relies on target ram instructions;)
 @p !b unext ;

address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success, target address)
( for failure)

( uncomment) - ( to force failure)

( block 514 )
( 2016 ) ( test i-ad and r-ad data paths)
( creeper) reclaim node 2 1344 load

( test start)
( 0x4 ) ( @p;)  0x5500 63 for ..
( 0x7 ) pop dup push dup @p ! ! .. ( /) @p dup a! @p ( 0xa ) over or @p .. ( /) ! b! @b !p ( /)
( 0xc ) over ! ! @ ( -) or .. if pop 0x40 or !b ;
( 0x12 )  then drop next
( 0x13 ) a @p ! .. ( /) @p b! .. ( /) ! .. ( dup or !b ;)
( 0x16 ) ( call) 0x12000 63 for ..
( 0x19 ) dup ! 1 @p ( /) !p .. ( /) ! . + dup
( 0x1d ) @ ( -) or 0x3f and if pop 0x80 or !b ;
( 0x23 )  then drop next ( dup or !b ;)
( 0x24 ) ( ex) ( 0x12040 ) dup 63 for ..
( 0x26 ) @p ! ! @p ( /) @p push ex ( /)  , 1
( 0x29 )  @p ! . + ( /) !p .. ( /) @ over ( -) or 0x3f
( 0x2d ) and if pop drop 0xc0 or !b ;
( 0x31 )  then drop dup .. next dup or !b ;

( 0x34 ) 2016 bin

( block 515 )
( test 8,5-0 of)  i ( and) r ( to adrs bus)

( verify adrs drivers for above bits in uut.)
( 1. using) a ( set)  @p ; n ( in ram, where) n ( is)
( -- loc of same word. chk ram via)  b ( and)
( -- return error code) [compile] 40+n ( if fail.)
( 2. for)  n ( of) [compile] 0-3f ( store) call-n ( /) !p .. ( into)
( -- port and read back and confirm that data)
( -- have the same low order) ( 6 ) ( bits as the next -- call we are to send. return error code)
( --) [compile] 80+n ( if fail.)
( 3. same as test) ( 2 ) ( using) ex ( instead of) call
( -- return error code) [compile] c0+n ( if fail.)

( test starts at) ( 0x4 ) ( with ignored input.)
( depends upon uut)  a b r s t ( and) ram ( as well as uut) call ex ;  @p !p . push dup a! b! ! @b ( in ram or port.)

( failure is forced by uncommenting)  - ( in)
( each test)

( block 516 )
( 2017 ) ( rom checksum)
( creeper) reclaim node 0 1344 load 
: start ( n) ( 0x4 ) 0 63 for pop dup push 0x80 . +
@p .. ( /) @p a! @ !p ( /) ! ! @ or next
or if 1 then !b ;
( 0x11 ) 2017 bin

( block 517 )
( rom check sums)

( does an xor checksum of the) ( 64 ) ( target node rom locations ; relies on instructions)
 @p !p a! a ( in the port)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is expected checksum)
( error code) ( 0 ) ( for success,) ( 1 ) ( for failure)

 0 test ( to force failure)

( block 518 )
( 2100 ) ( parallel port pin test)
( creeper) reclaim node 0 1344 load  ahead
: return ( n) pop dup b! push !b ;
: chk ( nn) ( 0x7 ) or
if pop pop drop pop drop return ;
 then drop ;
: write ( n) ( 0xc ) ( out) 0x15555 !b ! ;
: 50ns ( -n) ( 0xe ) 18 ( 33 ) for unext ( ;)
: sample ( -n) ( 0x11 ) ( in) 0x14555 !b .. @ ( out) 0x15555 !b ;
: 300ns ( -n) ( 0x15 ) ( 118 ) 87 for unext sample ;
: once ( n-n') ( 0x18 )
dup write 50ns 0 chk ( 0x1c ) 300ns over chk ( 0x1e )
0 write 50ns over chk ( 0x22 ) 300ns 0 chk ( 0x25 ) 2* ;
: start ( n) ( 0x26 ) then
0 data a! io b! write 300ns 0 chk ( 0x2e )
1 17 for once next drop !b dup or return ;
( 0x35 ) 2100 bin

( block 519 )
( parallel port pin test)

( walking ones test of parallel port pins in)
( nodes) ( 7 ) ( and) ( 9 ) ( , detects opens shorts and weak drive transistors .)

address 0x4 ( tests active node given arg which is ending io value.) note purpose is to control wr bit setting and if the bit does not work in either node the test will fail in one of em.
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( test's return address for failure)

( force an 'open pad' failure by running)
( the test on node) ( 9 ) ( of a chip with sram)
( connected)

( force a 'short' failure by temporarily)
( connecting a pin to power ground or a)
( neighbor pin)

( block 520 )
( 2101 ) ( mark @b !b test)
( creeper) reclaim node 0 1344 load  ahead
: /t ( 0x5 ) ( n) dup - .. ( /) @p ! ! ; ( /)  @p .. ( /)
: /b! ( 0x8 ) ( n) @p ! ! ; ( /)  @p b! .. ( /)
: /!b ( 0xa ) ( n) @p ! ! ; ( /)  @p !b .. ( /)
: /@b ( 0xc ) ( -n) @p ! @ ; ( /)  @b !p .. ( /)
: end @p ! a . ( /) @p b! .. ( /) ! !b ;
: init ( 0x11 ) then @p ! @p .. ( /) dup or a! .  , 63
( 0x14 )  @p ! ! .. ( /) ( 0x15 ) @p push .. ( 0x16 ) ( /)
@p ! .. ( /) ( 0x17 ) begin a - !+ unext .. ( 0x18 ) ( / ;)
1 dup ( 0x3e ) 0x3f for over . + /t dup /b! dup /!b next ( ;)
: chk-a ( 0x21 ) 1 dup 0x3f for over . + /t dup /b! dup /@b or .. if pop -1064 . + - !b pop drop ;  then drop next
: b-adr 0 end ;
( 0x32 ) 2101 bin

( block 521 )
( b-adr-data test; b-reg adr paths to ram and data path from t to ram and ram to t using b-reg)

( uses !+ to fill ram with -1 to -40)
( next uses b to change ram to) ( 0 ) ( to 3f)
( next checks to see if ram successfully changed ; relies on instructions)
 @p ( /) @p b! ( /) @b !p ( /) @p push ( /) dup or a! ( /)
a - !+ unext ( / in the port)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( address +) ( 1000 ) ( of failure for failure)

( uncomment) ( 0x3e ) ( and comment) 0x3f ( in)
: init ( to force failure)

( block 522 )
( 2102 ) ( mark t to b reg test)
( creeper) reclaim node 0 1344 load ( ahead) ( 0x12 ) org 0x14 
: end ( 0x14 ) @p ! a . ( /) @p b! .. ( /) ! !b ;
: /t ( 0x17 ) ( n) dup - .. ( /) @p ! ! .. ( /) @p .. ( /) ;
: /b! ( 0x1b ) ( n) @p ! ! .. ( /) @p b! .. ( /) ;
: /!b ( 0x1e ) ( n) @p ! ! .. ( /) @p !b .. ( /) ;
: /@b ( 0x21 ) ( -n) @p ! @ .. ( /) @b !p .. ( /) ;
: chk-a ( 0x24 ) 0x3f and dup dup /t /b! /@b or ( -) .. if drop 1000 . + end pop pop pop ;  then ;
: 2chk dup dup chk-a drop drop - chk-a drop drop chk-a ; ( 0x36 ) org 0x4 
: init ( then) @p ! .. ( /) dup or a! .. ( /)
0x3f .. ( /) ( 0x8 ) @p ! ! .. ( /) ( 0x9 ) @p push .. ( 0xa ) ( /) @p ! .. ( /) ( 0xb ) begin a !+ unext .. ( 0xc ) ( /)
: b-reg ( 0xc ) dup or 2chk 0xaa 2chk 0x33 2chk 0x19 2chk
( 0x14 ) ( end ;)
 2102 bin

( block 523 )
( b-reg testing t to b-reg)

( uses !+ to fill ram with) ( 0x0 ) ( to) ( 0x3f )
( next puts) ( 0x0 ) ( on t and -1 on s)
( next puts the) ( 0x0 ) ( into b and does a @b with -1 on t)
( next checks if t contains) ( 0x0 )
( then does this for) ( 0x3f ) ( ,) ( 0x0 ) ( and other numbers ; relies on instructions)
 @p ( /) @p b! ( /) @b !p ( /) @p push ( /) dup or a! ( /)
( /) a !+ unext ( / in the port)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( address +) ( 1000 ) ( of failure for failure)

( uncomment - in)
: chk-a ( to force failure)

( block 524 )
( 2103 ) ( mark port to i-reg test)
( creeper) reclaim node 0 1344 load org 0x1a 
: chk ( 0x1a ) or if pop 1000 !b ;  then ;
: rets @p ! a . ( /) @p dup push . ( /)
( /) ! @p ! @p ( /) dup dup or . ( /) push push . . ( /) !
: init ( 0x24 ) 0x15555 dup - over over ( -) over over
( . 2/ .) over .. @p ! ! . ( /) @p a! @p @p ( /)
.. ! ! @p . ( /) @p @p . . ( /) ! ( .) ! ! ;
: code ( 0x2d ) @p - dup . ( /) begin a! !p drop unext ( /) - over ! ! @ push ( /) ! pop ; ( ; - @p dup)

: -code ( 0x32 ) @p dup - dup ( /) a! - @p dup ( /) push ! ! ! pop ! ; ( / ; !p drop unext)

( 0x36 ) org 0x4 
: i-reg ( 0x4 ) rets ( ;) code over chk drop
( 0x408 ) .. ( /) @p ! @ . ( /) a !p !p .. ( /)
( 0xa ) - chk drop @ - chk ( / end first check)
( 0xd ) rets .. ( /) @p ! @p . ( /) pop pop drop . ( /) push .. ( /) ! dup dup -code
( 0x13 ) ( /) @p ! @ ( .) .. ( /) !p !p !p .. ( /)
chk drop @ chk drop @ chk ( end second check)
!b ; ( 0x1a ) 2103 bin

( block 525 )
( port testing port to i-reg)

( uses the instruction /)  a! !p drop unext ( /)
( first the inverse instruction is sent then the instruction then the inverse instruction again)  note ( the inverse of)  a! ( is) ;
( next the inverse of instruction /)  a! - @p dup ( is used, except for the) a! ( /)
 note ( the pre and post instructions begin with)  ; ( and don,t effect the stack)
( after each triplet the stack is checked;)
( relies on instructions)
 @p dup push . ( /) dup dup or . ( /) push push .. ( /) @p a! @p @p ( /) @p @p . . ( /) a !p !p . ( /)
pop pop drop . ( /) push .. ( /)
( in the port)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( 1000 ) ( for failure)

( uncomment)  2/ ( in)
: init ( to force failure)

( block 526 )
( 2104 ) ( mark port to i-reg-bit-short test)
( creeper) reclaim node 0 1344 load ( 0x13 ) org 0x17 
: chk ( 0x17 ) or if pop pop 1000 ( 0x1000 ) !b ;  then drop ;
: init ( 0x1c ) 0x3807 dup 2* dup 2* dup dup
2* dup dup 2* dup dup
.. @p ! @p . ( /) @p @p @p . ( /)  , 0x12345 ( . 2/ .)  ! ! ! ;
: read ( 0x25 ) ( /) @p ! @ . ( /) !p !p !p . ( /) @ @ ;


: code ( 0x28 ) ( /) @p ; ( /)  and @b and @p ( /)
: -code ( 0x2a ) ( /) @p ; ( /)  @b and @b + ( /)


: run ( 0x2c ) -code ! ( .) ! ! ( .) code ! ( .) ! ! ( .)
-code ! ( .) ! ! ( .) ;


( 0x32 ) org 0x4 
: i-reg ( 0x4 ) init run read 0x12345 chk 0x10020 chk 0x1502a chk
dup or !b ; ( 0xe ) 2104 bin ( 0x9813 )

( block 527 )
( i-reg-bits testing port to i-reg for)
( shorted adjacent bits)

( uses the instructions /)  and @b and + ( /)
( and) @b and @b + ( checked;)
( relies on instructions)
@p dup push . ( /) dup dup or . ( /) push push .. ( /) @p a! @p @p ( /) @p @p . . ( /) a !p !p . ( /)
pop pop drop . ( /) push .. ( /)
( in the port)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( 1000 ) ( for failure)

( uncomment)  2/ ( in)
: init ( to force failure)

( block 528 )
( 2105 ) ( mark port to i-reg-bit-short test)
( creeper) reclaim node 0 1344 load org 0x1a 
: chk ( 0x1a ) or if pop pop 1000 ( 0x1000 ) !b ;  then drop ;
: init ( 0x1f )
dup or - dup 2* dup 2* dup 2* dup 2* dup 2* dup 2* ( /)
.. ( /) @p ! a . ( /) @p push @p @p ( /)
( /) ! ! ! @p ( /) @p @p @p @p ( /) ! ( . 2/ .) ! ! ! ! ;

: 3code ( 0x29 ) ( /) @p dup dup . ( /) - - - . ( / !p !p !p ;)
: run ( 0x2b ) push ! - ! @ @ @ pop !
.. ( /) @p ! @ . ( /) !p !p !p . ( /) @ @ ;

( 0x31 ) org 0x4 
: i-reg ( 0x4 ) init 3code 0x3ffc0 chk 0x3ffe0 chk 0xf chk 0x3fff8 chk 0x3fffc chk 0x1 ( -) chk

dup or !b ; ( 0x13 ) 2105 bin

( block 529 )
( i-reg-bits testing port to i-reg for)
( shorted adjacent bits)

( uses the instructions /)  - - - . ( /) !p !p !p ; ( / relies on instructions)
( /)  !p !p !p . ( /) @p @p @p @p ( /) @p push @p @p ( / . in the port)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( 1000 ) ( for failure)

( uncomment)  2/ ( in)
: init ( to force failure)

( block 530 )
( 2106 ) ( mark port to i-reg-bit-short test)
( creeper) reclaim node 0 1344 load org 0x18 
: chk ( 0x18 ) or if pop pop 1000 !b ;  then drop ;
: init ( 0x1d ) dup or - dup 2* dup 2* dup 2*
dup 2* dup 2* dup 2* dup 2* dup 2* dup 2*
.. ( /) @p ! a . ( /) @p dup push . ( /)
.. ( /) ! @p ! . ( /) push @p a! @p ( /)
( 0x27 ) ! ! @p . ( /) @p @p @p @p ( /) ! ( . 2/ .) ! ! ! ! ;

: 2code ( 0x2b ) ( /) @p - dup . ( /) !p - a! . ( / - !p ; ;)
: run ( 0x2d ) - over push push ! @ pop ! @ pop ! @
.. ( /) @p ! @ . .. ( /) a !p !p . ( /) @ .. ;

( 0x35 ) org 0x4 
: i-reg ( 0x4 ) init 2code 0x3ff00 chk 0x3f chk 0x7f chk 0x3ffe0 chk 0xf chk
dup or !b ; ( 0x11 ) 2106 bin

( block 531 )
( i-reg-bits testing port to i-reg for)
( shorted adjacent bits)

( uses the instructions)
( /)  !p - a! . ( /) - !p ;  ; ( /)
( relies on instructions)
( / /)  @p dup push . ( /) push @p a! @p ( /)
( /) @p @p @p @p ( /) a !p !p . ( /)
( in the port)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( 1000 ) ( for failure)

( uncomment)  2/ ( in)
: init ( to force failure)

( block 532 )
( 2107 ) ( mark port to i-reg-bit-short test)
( creeper) reclaim node 0 1344 load ( 0x18 ) org 0x17 
: chk ( 0x17 ) or if pop pop 1000 ( 0x1000 ) !b ;  then drop ;
: init ( 0x1c )
dup or - dup 2* dup 2* dup 2* dup 2* ( /)
.. ( /) @p ! a . ( /) @p dup push . ( /)
( /) ! @p ! . ( /) push @p a! . ( /)
( 0x23 ) ! @p ! . ( /) @p @p @p @p ( / . 2/ .) ! ! ! ! ;

: 1code ( 0x27 ) ( /) @p - dup . ( /) - a! - . ( / !p ; !p ;)
: run ( 0x29 ) ! @ ( ;) push dup - ! ! pop @
.. ( /) @p ! @ . ( /) !p a !p . ( /) @ ;
: 0code ( 0x2f ) ( /) @p - dup . ( /) a! - . . ( / ; !p c c)
: 0run ( 0x31 ) - over ! ! !
.. ( /) @p ! @ . ( /) a !p !p !p ( /) @ @ ;

( 0x36 ) org 0x4 
: i-reg ( 0x4 ) init 1code 0x1 chk 0x3fff8 chk 3 chk 0x3ffff chk
( 0xe ) init 0code 0x3fffc chk 0x1 chk 0x3ffff chk
dup or !b ; ( 0x17 ) 2107 bin

( block 533 )
( i-reg-bits testing port to i-reg for)
( shorted adjacent bits)

( uses the instructions)
( /)  a! - . . ( /) ;  !p c c ( /)
( /) - a! - . ( /) !p ;  !p ; ( /)
 @p dup push . ( /) dup dup or .
( relies on instructions)
( /) a !p !p !p ( /) !p a !p . ( /) @p @p @p @p
( /) push @p a! . ( /) @p dup push . ( /)
( in the port)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( 1000 ) ( for failure)

( uncomment)  2/ ( in)
: init ( to force failure)

( block 534 )
( 2108 ) ( mark port to i-reg-bit-short test)
( creeper) reclaim node 0 1344 load org 0x15 
: chk ( 0x15 ) or if pop pop 1000 ( 0x1000 ) !b ;  then drop ;
: init ( 0x1a )
dup or - dup 2* dup 2* dup 2* dup 2* ( /)
.. ( /) @p ! a . ( /) @p dup push . ( /)
( /) ! @p ! . ( /) push @p a! . ( /)
( 0x21 ) ! @p ! . ( /) @p @p @p @p ( /) ! ( . 2/ .) ! ! ! ;

: +code ( 0x25 ) ( /) @p - dup . ( /) a! a! a! . ( / ; ; ; ;)
: +run ( 0x27 ) - over ! ! !
.. ( /) @p ! @ . ( /) a !p !p . ( /) @ ;

( 0x2c ) org 0x4 
: i-reg ( 0x4 ) init +code 0x3fff8 chk 0x3fffc chk
( 0xa ) dup or !b ; ( 0xb ) 2108 bin

( block 535 )
( i-reg-bits testing port to i-reg for)
( shorted adjacent bits)

( uses the instructions)
( /)  a! a! a! . ( / ; ; ; ; /)
( relies on instructions)
( /) @p dup push . ( /) push @p a! . ( /)
( /) @p @p @p @p ( /) a !p !p . ( /)
( in the port)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( 1000 ) ( for failure)

( uncomment)  2/ ( in)
: init ( to force failure)

( block 536 )
( 2109 ) ( mark port to i-reg-bit-short test)
( creeper) reclaim node 0 1344 load org 0x15 
: chk ( 0x15 ) or if pop pop 1000 !b ;  then drop ;
: init ( 0x1a ) dup or - dup 2* dup 2* dup 2*
dup 2* dup 2* dup 2* dup 2* dup 2* ( /)
.. ( /) @p ! a . ( /) @p dup push . ( /)
( /) ! @p ! . ( /) push @p a! @p ( /)
( 0x23 ) ! ! @p . ( /) @p @p @p @p ( /) ! ( . 2/ .) ! ! ! ! ;

: -code ( 0x27 ) ( /) @p ; ( /)  @p @p @p ; ( /)
: +code ( 0x29 ) ( /) @p ; ( /)  a! a! a! . ( / ; ; ; ;)
: -run ( 0x2b ) +code ! -code ! ( .) ! ! ! ( .) +code !
.. ( /) @p ! @ . ( /) a !p !p !p . ( /) @ @ ;

( 0x33 ) org 0x4 
: i-reg ( 0x4 ) init -run 0x3ff80 chk 0x3ffc0 chk 0x3fffc chk
dup or !b ; ( 0xd ) 2109 bin

( block 537 )
( i-reg-bits testing port to i-reg for)
( shorted adjacent bits)

( uses the instructions)
( /)  @p @p @p ; ( /)  a! a! a! . ( /) ;  ;  ;  ; ( /)
( relies on instructions)
( /)  @p dup push . ( /) push @p a! @p ( /)
( /) @p @p @p @p ( /) a !p !p !p . ( /)
( /)
( in the port)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( 1000 ) ( for failure)

( uncomment)  2/ ( in)
: init ( to force failure)

( block 538 )
( 2110 ) ( mark prp-call test)
( creeper) reclaim node 0 1344 load ( 0xd ) ( 0xc ) org 0x9 
: p-r-p dup 0x1 . + 0x7e for
: init ( 0x2 ) ( 0x3 ) dup ( 3) push over a
( 0x3 ) ( .) ( 0x2 ) ( a) pop ( 3) a push dup push 0x1 . +
( 0x3 ) ( .) ( 0x2 ) ( a) ( 0x4 ) dup a! - ( 0x3f ) 0x7f and
( 0x3 ) ( .) ( 0x2 ) ( a) ( 0x3b ) dup push 0x13000 or pop
( 0x3 ) ( .) ( 0x2 ) ( a) ( 0x1303b ) ( 0x3b ) pop ( 0x3 ) ( .) ( 0x2 ) ( a) ( 0x3b ) ( 0x3 )
a ( 0x4 ) pop a! ( 0x4 ) push
( /) .. @p ! ! . ( //) @p @p @p @p ( /)
( /) ! ! ! @p ( //) @p .. ( /) ! !
8 for @p ! unext
( /) ( 0x2 ) a! @p !+ . ( /) !b pop !b . ( /)
( a) push !+ @p .. ( /) ; ( /)

: forcefail !+ dup .. ( /) ( 0x3b ) a! ( 0x3b ) ( . 2/ .) @p @p .. !b pop !b . ( /) pop dup push ;
 !+ !+ push .. ( /)


: calls ( 0x2a ) ( 0x3 ) pop ( 0x4 ) over ( 0x3 ) 0x11000 or ! ( ? @ ; ?)
( /) .. @p ! @ .. ( //) !p .. a
( chk) or if pop pop 1000 !b ;  then drop

next ; ( 0x35 ) org 0x4 
: p-r 0x0 p-r-p 0x200 p-r-p dup or !b ;
( 0x9 ) 2110 bin

( block 539 )
( prp-call testing p to r to p using)  call ( and) ; ( also test)  jump ( from port to ram.) ; ( returns to port and to ram)

( uses the instructions in ram)
( /)  pop dup push ; ( /)  call ( /) ; ( /)

( to insure failure on fail, fills ram with)
( /)  !b pop !b . ( /)

( relies on instructions in the port)
( /) a! @p !+ . ( /) push !+ @p .. ( /)
( /) !+ dup .. ( /) a! @p @p .. ( /)
( /) !+ !+ push .. ( /)


 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( 1000 ) ( for failure)

( uncomment)  2/ ( in)
: forcefail ( to force failure)
( uncomment)  @ ; ( in)
: calls ( and removing)  for next ( structure)
( might help debuging chip.)

( block 540 )
( 2111 ) ( mark prp-ex test)
( creeper) reclaim node 0 1344 load org 0xd 
: p-r-p dup 0x1 . + 0x7e for
: init ( 0x2 ) ( 0x3 ) dup ( 3) push over a
( 0x3 ) ( .) ( 0x2 ) ( a) pop ( 3) a push dup push 0x1 . +
( 0x3 ) ( .) ( 0x2 ) ( a) ( 0x4 ) dup a! - 0x7f and
( 0x3 ) ( .) ( 0x2 ) ( a) ( 0x3b ) pop ( 0x3 ) ( .) ( 0x2 ) ( a) ( 0x3b ) ( 0x3 )
a ( 0x4 ) pop a! ( 0x4 ) push
( /) .. @p ! ! . ( //) @p @p @p @p ( /) ! ! !

10 for @p ! unext
( /) ( 0x2 ) a! @p !+ . ( /) !b pop !b . ( /)
( a) push @p @p .. ( /) ; ( /)  ex .. ( /)
!+ !+ dup dup .. ( /) ( 0x3b ) a! ( 0x3b ) push @p @p ( /)
( /) !b pop !b . ( /) pop dup ( . .) push ( .) ; ( /)

: forcefail !+ !+ .. ( / . 2/ .) push drop .. ( /)


: calls ( 0x2b ) ( 0x3 ) pop ( 0x4 ) over ( 0x3 ) 0x11000 or ! ( ? ; ?)
( /) a .. @p ! @ .. ( //) !p ..
( chk) or if pop pop 1000 !b ;  then drop
next ; ( 0x36 ) org 0x4 
: p-r 0 p-r-p 0x200 p-r-p dup or !b ;
( 0x9 ) 2111 bin

( block 541 )
( prp-ex testing p to r to p using)  ex ( and) ;
( also test)  jump ( from port to ram.) ; ( returns to port and to ram)

( uses the instructions in ram)
( /)  pop dup push ; ( /)  ex .. ( /) ; ( /)
( to insure failure on fail, fills ram with)
( /)  !b pop !b . ( /)
( relies on instructions in the port)
( /) a! @p !+ . ( /) push @p @p .. ( /)
( /) !+ !+ dup dup .. ( /) a! push @p @p ( /)
( /) !+ !+ .. ( /) push drop .. ( /)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( 1000 ) ( for failure)

( uncomment)  2/ ( in)
: forcefail ( to force failure)
( uncomment)  @ ; ( in)
: calls ( and removing)  for next ( structure)
( might help debuging chip.)

( block 542 )
( 2112 ) ( serdes 001 slave test)
( creeper) reclaim node 1 1344 load  ahead
: s-lis ( 0x5 ) ( rip) -1 !b .. cold ;
: lis ( 0x8 ) io a! 0x15555 ! data a! 0x3fffe dup ! ;
: m-lis ( arg) ( 0xf ) then a push lis pop a! .. 0 !b ; ( 0x14 )


: ran ( n-n) ( 0x14 ) -if 2* 0x2cd81 or ;  then 2* ;
: rcv ( -n) ( 0x18 ) 0x3fffe @ ( nip) over or or ;
: dly ( 0x1b ) 50 for unext ;
: one ( 0x1e ) up a! 0 rcv dup for
ran dup push rcv or over - and or pop next
drop dly
data a! 0x31416 or dup ! io a! 0x20000 !
up a! ! dly lis warm ;

( 0x36 ) 2112 bin

( block 543 )
( basic serdes test. this package is loaded into node 001 and location) ( 5 ) ( executed, returning negative status to rip the creeper out and placing the node in its cold configuration to execute anything node) ( 701 ) ( sends it. the location) ( 4 ) ( entry point is used in node) ( 701 ) ( on the way to 001 to place) ( 701 ) ( in listen mode first.)


: s-lis ( is used from node) ( 101 ) ( to start 001 listening for instructions from node 701.)
: one ( is called by master thru serdes to run the test. receives count, nominally 250,000, and then receives one more than that words of data. compares each word with prn sequence generated off the initial count. ors all error bits together, then xors that result with) ( 31416 ) ( and returns two copies after turning line around. finally goes back to receive and warm so it's rdy for the next test.)

( block 544 )
( 2113 ) ( serdes) ( 701 ) ( master test)
( creeper) reclaim node 1 1344 load  ahead


: ran ( n-n) ( 0x5 ) -if 2* 0x2cd81 or ;  then 2* ;
: dly ( 0x9 ) ( 10 ) 12 for unext ;
: lis ( 0xc ) io a! 0x15555 ! data a! 0x3fffe dup ! ;
: go ( arg) ( 0x13 ) then data a! io 0x1201e
! a! up 0x20000 ( .) ! a! dup ! dup for
     dly ran dup ! next drop
( result) . .. . .. lis dly dly lis up a! @ @
0x31416 or over 0x31416 or over - and or
dup 2/ over - and or 0x1ffff and .. !b ;

( 0x31 ) 2113 bin exit

( block 545 )
( basic serdes test. single package used in two modes on path) ( 1 ) ( for the two nodes.)


: s-lis ( is used from node) ( 101 ) ( to start 001 listening for instructions from node 701.)

( block 546 )
( 2114 ) ( basic analog checks)
( creeper) reclaim node 0 1344 load


: !dac ( 0x4 ) ( n) io a! ! dup dup or !b ;
: ladc ( 0x7 ) ( n) io a! ! ldata
: .adc ( 0xa ) a! ! @ dup 1000 for unext ..
( ----) ( 0xe ) ! @ - 1 . + . + 0x1ffff and !b ;
: uadc ( 0x13 ) ( n) io a! ! data .adc ;

( 0x17 ) 2114 bin exit


: !dac ( 0x19 ) ( n) dup @p ! dup ( /) @p a! @p . ( /)
( ----) ( 0x1b ) io ! ! @p ( /) ! . . . ( /) ! or !b ;

( block 547 )
( basic analog control)

( this code is intended to run in the active)
( node, not the target node.)


: !dac ( sets dac value into io and returns zero.)
: ladc ( sets up dac and io then reads back raw)
( adc value when used in a left analog node.)
: uadc ( does the same for an up analog node.)

( block 548 )
( 2115 ) ( mark 2* test)
( creeper) reclaim node 0 1344 load org 0x13 
: t! ( n) @p ! ! ; ( //)  @p .. ( /)
: t2* @p ! ; ( //)  2* .. ( /)
: t@ ( -n) @p ! @ ; ( //)  !p .. ( /)
: t2*3 @p ! .. ( //) 2* 2* 2* .. ( /)
@p ! @ ; ( //)  dup !p .. ( /)
: chk over or .. if pop pop pop 1000 !b ;  then drop ;
: h2* dup t! 18 for
dup . + t2* t@ dup t! chk
next ;
: h2*3 dup t! 6 for
dup . + dup . + dup . + t2*3 chk next ;
: forcefail ( 0x36 )  org 0x4 
: tst-2* ( 0x4 ) 0x15555 h2* 0x1 h2* - ( 0x3ffff ) h2*3 ( 0x0 ) h2*3 0x15555 h2*3 0x33333 h2*3 0x71c7 h2*3 0x1 h2*3 !b ;
( 0x13 ) 2115 bin

( block 549 )
( tst-2* testing 2*)


( relies on instructions in the port)
 @p . . . ( /) 2* . . . ( /) !p . . . ( /) 2* 2* 2* . ( /)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( 1000 ) ( for failure)

( first comment) dup ( in)
: h2*3 ( to force failure)
( then comment) dup ( in)
: h2* ( to force failure)

( block 550 )
( 2116 ) ( mark 2/ test)
( creeper) reclaim node 0 1344 load ( 0x13 ) org 0x19 
: t2/ ( n-n) dup . + @p ( //) @p 2/ !p .. ( /) ! dup ! over @ ;
: t2/3 ( n-n) dup . + dup . +
.. ( /) dup . + @p ( //) @p .. ( /)
( /) ! dup ! @p ( //) 2/ 2/ 2/ !p ( /)
( /) ! over @ ;
: chk or .. if pop pop pop 1000 !b ;  then drop ;
: h2/ 12 for dup t2/ chk next ;
: h2/3 3 for dup t2/3 chk next ; ( 0x36 ) org 0x4 
: tst-2/ ( 0x4 ) 0xf h2/ 0x5 h2/ 0x3 h2/ 0xc h2/ 0xf h2/3 0x5 h2/3 0x3 h2/3 0xc h2/3 0x7 h2/3 0x9 h2/3 dup or !b ;
( 0x19 ) 2116 bin

( block 551 )
( tst-2/ testing 2/)


( relies on instructions in the port)
 @p 2/ !p . ( /) @p . . . ( /) 2/ 2/ 2/ !p ( /)


 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( 1000 ) ( for failure)

( first comment) dup ( in)
: h2/ ( to force failure)
( then comment) dup ( in)
: h2/3 ( to force failure)

( block 552 )
( 2117 ) ( mark 2/ test)
( creeper) reclaim node 0 1344 load org 0x22 
: t2/ ( n-n) dup . + @p ( //) @p 2/ !p .. ( /) ! ! @ ;
: t2/3 ( n-n) dup . + dup . +
.. ( /) dup . + @p ( //) @p .. ( /)
( /) ! ! @p .. ( //) 2/ 2/ 2/ !p ( /)
( /) ! @ ;
: chk or .. if pop pop pop 1000 !b ;  then drop ;
: h2/ dup t2/ chk ;
: h2/3 dup t2/3 chk ; ( 0x36 ) org 0x4 
: tst-2/b ( 0x4 ) 0x30000 h2/ 0x3aaaa h2/ 0x35555 h2/ 0x3fffe h2/ 0x33333 h2/ 0x3cccc h2/
0x3c000 h2/3 0x3eaaa h2/3 0x3d555 h2/3 0x3fff8 h2/3 0x3f333 h2/3 0x3cccc h2/3 0x3c0f0 h2/3 0x3c1c3 h2/3 dup or !b ;
( 0x21 ) 2117 bin

( block 553 )
( tst-2/b testing 2/)


( relies on instructions in the port)
 @p 2/ !p . ( /) @p . . . ( /) 2/ 2/ 2/ !p ( /)


 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( 1000 ) ( for failure)

( first comment) dup ( in)
: h2/ ( to force failure)
( then comment) dup ( in)
: h2/3 ( to force failure)

( block 554 )
( 2200 ) ( tst+ mark testing +)
( creeper) reclaim node 0 1344 load org 0x2a

: chk or if pop pop 1000 !b ;  then drop ;
: t+ ( nnn-n) push ..
( /) @p ! ! @p ( //) @p ( . - .) .. ( //) @p . + !p ( /)
( /) ! ! @ pop chk ;
( 0x35 ) org 0x4

: tst+ 0x15555 dup dup 0x2aaaa t+
dup dup - 0x3ffff t+ - dup - dup 0x2aaaa 0x3ffff t+ dup - 0x3ffff t+
dup or - dup dup 0x3fffe t+ 0x2aaaa 0xcccc 0x37776 t+ 0x19999 0x15555 0x2eeee t+ 0x33333 0x8888 0x3bbbb t+
dup or !b ;
( 0x27 ) 2200 bin

( block 555 )
( tst+ mark testing +)


( relies on)  s ( and) t ( of uut)
( relies on instructions in the port)
( /) @p .. ( /) @p . + !p ( /)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( 1000 ) ( for failure)

( fail mode;)
( uncomment) - ( in)
: t+ ( to force failure)



( block 556 )
( 2201 ) ( mark r d stack test v2)
( creeper) reclaim node 0 1344 load org 0xe 
: store dup ! dup ! dup ! ! ;
: fetch ( -n) @p ! @ ; ( /)  !b .. ( /)
: /neighbor @p ! ! .. @p ..
3 for @p ! unext ;  ..
: /stack dup - over .. ( /) over over ( . - .)
over .. ( /) over over over .. ( /) over .. ( /) ;
: t-stk ( 0x1d )
dup /neighbor /stack ( 0x1f )
( 0xfffe ) 8 for
@p .. push push push .. store
fetch drop @p .. pop pop pop .. store

11 for fetch or .. if pop pop - 10 . + !b pop ;  then drop
next drop fetch drop next ;
( 0x35 ) org 0x4 
: full ( 0x4 ) 0x2aaaa t-stk dup or ( 0x0 ) t-stk 0x33333 t-stk 0x19999 t-stk dup or !b ;
( 0xd ) 2201 bin

( block 557 )
( rdstk mark testing return and data stacks registers)
( also mulitple overs pops and pushes in the port)

( fill neighbor return stack with alternating)
( inverted patterns , then push to return stack then pop to data stack then read back and verify each pattern ; relies on)  b s t r r-stack ( and) d-stack ( of uut)
( and instructions)
( /) !b .. ( /) @p .. dup - over .. ( /)
( /) over over over .. ( /) over .. ( /)
( /) push push push .. ( /) pop pop pop .. ( /)
( /) @p .. ( /) !b .. ( /) over push pop .. ( /)
( in the port)


: full ( tests the)  tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success , next count for failure)

( uncomment) - ( in)
: /stack ( after) over ( to force failure)

( block 558 )
( 2202 ) ( mark d stack test v2)
( creeper) reclaim node 0 1344 load org 0x18 
: fetch ( -n) @p ! @ ; ( //)  !b .. ( /)
: /neighbor @p ! ! .. @p ..
3 for @p ! unext ;  ..
: /stack ( 0x1f ) dup - over .. ( /) over over
over .. ( /) over over over .. ( /) over .. ( /) ;
: d-stack ( 0x24 ) 0x8 for dup ( . - .) /neighbor /stack ( .) 11 for fetch or if pop pop - 10 . + !b pop ;  then drop
next next ;
( 0x33 ) org 0x4 
: full ( 0x4 ) 0x2aaaa d-stack dup or ( 0x0 ) d-stack 0x15555 d-stack dup or - ( 0x3ffff ) d-stack 0x33333 d-stack 0x19999 d-stack 0xcccc d-stack 0x26666 d-stack dup dup or
!b ; ( 0x16 ) 2202 bin


( block 559 )
( stk mark testing data stack registers)
( also overs in the port)

( fill neighbor return stack with alternating)
( inverted patterns , then read back and verify each pattern ; relies on)  b s t ( and) d-stack ( of uut)
( and instructions)
( /) dup - over .. ( /) over over over .. ( /)
( /) over .. ( /) @p .. ( /) !b .. ( /)
( in the port)


: full ( tests the)  tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success , next count for failure)

( uncomment) - ( in)
: d-stack ( after) dup ( to force failure)

( block 560 )
( 2203 ) ( mark test + v2)
( creeper) reclaim node 0 1344 load org 0x18

: h+ over over ( . - .) . + push
: t+ ( nn-n) @p ! ! @p ( //) @p .. ( //) @p . + !p ( /) ! ! @
pop over ( chk) or if pop pop 1000 !b ;  then drop ;

: first ( x) leap 0x23225 . + dup
: xstr @p drop !p ; : x then 0x0 ; ( 0x2a )
: sec ( y) leap 0x1f9a9 . + dup
: ystr @p drop !p ; : y then 0x0 ;
: thr ( z) leap 0x1be29 . + dup
: zstr @p drop !p ; : z then 0x0 ;

( 0x36 ) org 0x4

: tst+ dup or ( 0x3ffff ) 0x3ff for first h+ sec over h+ thr h+ x - h+ over h+ z - h+ - y h+ dup h+ h+ next dup or !b ;
( 0x18 ) 2203 bin

( block 561 )
( tst+b mark testing +)


( relies on)  s t ( and) d-stack ( of uut)
( relies on instructions in the port /)
@p .. ( /) @p . + !p ( /)

 address 0x4 ( tests the) tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success,)
( 1000 ) ( for failure)

( uncomment) - ( in)
: h+ ( to force failure)


( block 562 )
( 2204 ) ( mark testing and)
( creeper) reclaim node 0 1344 load org 0x1e 
: chk ( nn) or if pop pop pop 0x1000 !b ;  then ( drop) ;
: tand ( nn-n) @p ! ! .. ( //) @p @p and !p ( /) ! @ ;
: ttand over over ( . - .) and push tand pop chk ;
: first ( x) leap 0x23225 . + dup
: xstr @p drop !p ; : x then 0x0 ;
: sec ( y) leap 0x1f9a9 . + dup
: ystr @p drop !p ; : y then 0x0 ;
( 0x35 ) org 0x4 
: tstand ( 0x3ffff ) 0x100 for first sec ttand x - y ttand x y - ttand x - y - ttand y - x ttand y x - ttand y - x - ttand next dup or !b ;
( 0x1d ) 2204 bin



( block 563 )
( tst-and mark testing and)

( relies on)  s t ( and) d-stack ( of uut)
( relies on instructions)
( /) @p @p and !p ( /)
( in the port)


: full ( tests the)  tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success ,)  1000 ( for failure)

( uncomment)  - ( in)
: ttand ( after) over ( to force failure)

( block 564 )
( 2205 ) ( mark test and)
( creeper) reclaim node 0 1344 load org 0x25 
: chk ( nn) or if pop pop 0x1000 !b ;  then ;
: tand ( nn-n) @p ! ! .. ( //) @p @p and !p .. ( /) ! @ ;

: tand3 ( nnnn-n) @p ! ! .. ( //) @p @p @p @p ( /)
( /) ! ! ! @p ( //) and and and !p .. ( /) ! @ ;
: tsa tand chk ;
: tsa3 tand3 chk ;
( 0x36 ) org 0x4 
: tstand ( 0 ) 0x2222 0x17777 0x2aaaa 0x3faff 0x33333 tsa3 0x30a5c 0x3ffff over tsa 0x30a5c - 0x3ffff over tsa 0xa00 0x3ff00 0xfff 0x3ffff 0x3fa55 tsa3 - tsa 0x15555 tsa dup 0x2aaaa tsa 0x15555 0x2aaaa tsa !b ;
( 0x25 ) 2205 bin



( block 565 )
( tst-andb mark testing and)


( relies on)  s t ( and) d-stack ( of uut)
( relies on instructions)
( /) @p @p and !p .. ( /) @p @p @p @p ( /)
( /) and and and !p ( /)
( /)
( in the port)


: full ( tests the)  tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success ,)  1000 ( for failure)

( first fail mode;)
( uncomment)  and ( in)
: tand ( to force failure)

( second fail mode;)
( uncomment) and ( in)
: tand3 ( to force failure)


( block 566 )
( 2206 ) ( mark testing or)
( creeper) reclaim node 0 1344 load org 0x1e 
: chk ( nn) or if pop pop pop 0x1000 !b ;  then ;
: tor ( nn-n) @p ! ! .. ( //) @p @p or !p ( /) ! @ ;
: ttor over over ( . - .) or push tor pop chk ;
: first ( x) leap 0x23225 . + dup
: xstr @p drop !p ; : x then 0x0 ;
: sec ( y) leap 0x1f9a9 . + dup
: ystr @p drop !p ; : y then 0x0 ;
( 0x35 ) org 0x4 
: tst-or ( 0x3ffff ) 0x100 for first sec ttor x - y ttor x y - ttor x - y - ttor y - x ttor y x - ttor y - x - ttor next dup or !b ;
( 0x1d ) 2206 bin



( block 567 )
( tst-or mark testing and)

( relies on)  s t ( and) d-stack ( of uut)
( relies on instructions)
( /) @p @p and !p ( /)
( in the port)


: full ( tests the)  tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success ,)  1000 ( for failure)

( uncomment)  - ( in)
: ttand ( after) over ( to force failure)

( block 568 )
( 2207 ) ( mark test or v2)
( creeper) reclaim node 0 1344 load org 0x25 
: chk ( nn) or if pop pop pop 0x1000 !b ;  then ;
: tor ( nn-n) @p ! ! .. ( //) @p @p or ( . - .) !p .. ( /) ! @ ;

: tor3 ( nnnn-n) @p ! ! .. ( //) @p @p @p @p ( /)
( /) ! ! ! @p ( //) or or or ( . - .) !p .. ( /) ! @ ;
: tso tor chk ;
: tso3 tor3 chk ;
( 0x36 ) org 0x4 
: tstor 0x3e372 0x35fa9 0x3f57f 0x25733 0x11e97 tso3 0x3f555 0x3ff00 0xfff 0x3ffff 0x3fa55 tso3 0x15555 0x3ffff over - tso 0x2aaaa 0x3ffff over - tso dup or dup - dup tso dup or - dup dup - tso 0x15555 over - over - tso !b ;
( 0x25 ) 2207 bin



( block 569 )
( tst-orb mark testing and)


( relies on)  s t ( and) d-stack ( of uut)
( relies on instructions)
( /) @p @p and !p .. ( /) @p @p @p @p ( /)
( /) and and and !p ( /)
( /)
( in the port)


: full ( tests the)  tfocused ( neighbor)
 parameter ( is ignored)
( error code) ( 0 ) ( for success ,)  1000 ( for failure)

( first fail mode;)
( uncomment)  and ( in)
: tand ( to force failure)

( second fail mode;)
( uncomment) and ( in)
: tand3 ( to force failure)


( block 570 )
( 2208 ) ( mark test -)
( creeper) reclaim node 0 1344 load org 0x26 
: chk ( nn) ! @ or if pop pop 0x1000 !b ;  then ;
: t- ( n-n) @p ! .. ( //) @p - !p .. ( /) chk ;
: t-2 ( n-n) dup @p ! .. ( //) @p - - !p .. ( /) chk ;

: t-3 ( n-n) @p ! ! @p ( //) @p .. ( /)
( //) - - - !p .. ( /) chk ;
( 0x36 ) org 0x4 
: tstor 0x1c8d 0x3e372 t- 0x2aaaa 0x15555 t- 0x15555 0x2aaaa t- 0x3ffff dup dup or t- dup dup or 0x3ffff t-
dup dup or t-2 0x3ffff t-2 0x2aaaa t-2 0x15555 t-2 0x3ffff dup dup or t-3 0x2aaaa 0x15555 t-3 !b ;
( 0x26 ) 2208 bin



( block 571 )
( tst- mark testing)  -


( relies on) s t ( and) d-stack ( of uut)
( relies on instructions)
( /) @p - !p .. ( /) @p - - !p .. ( /)
( /) @p .. ( /) - - - !p .. ( /)

( in the port)

( tests the)  tfocused ( neighbor)
 parameter ( is ignored)
( error code)  0 ( for success ,) 1000 ( for failure)

( first fail mode;)
( uncomment)  - ( in)
: t- ( to force failure)

( second fail mode;)
( uncomment) - ( in)
: t-2 ( to force failure)

( second fail mode;)
( uncomment) - ( in)
: t-3 ( to force failure)

( block 572 )


( block 573 )


( block 574 )


( block 575 )


( block 576 )


( block 577 )


( block 578 )


( block 579 )


( block 580 )


( block 581 )


( block 582 )


( block 583 )


( block 584 )


( block 585 )


( block 586 )


( block 587 )


( block 588 )


( block 589 )


( block 590 )


( block 591 )


( block 592 )


( block 593 )


( block 594 )


( block 595 )


( block 596 )


( block 597 )


( block 598 )


( block 599 )


( block 600 )
( res for more ats test pkgs ---)

( block 601 )


( block 602 )


( block 603 )


( block 604 )


( block 605 )


( block 606 )


( block 607 )


( block 608 )


( block 609 )


( block 610 )


( block 611 )


( block 612 )


( block 613 )


( block 614 )


( block 615 )


( block 616 )


( block 617 )


( block 618 )


( block 619 )


( block 620 )


( block 621 )


( block 622 )


( block 623 )


( block 624 )


( block 625 )


( block 626 )


( block 627 )


( block 628 )


( block 629 )


( block 630 )
( 1900 ) ( ats analog)
reclaim node 717 org 0 
: sam ( n-k) ( 0x0 ) io b! data a! @b - 0x1ff and or
!b dup ! @ 1000 for unext dup ! @ - . + ;
: vdd ( 0xc ) 0x2000 sam ; : vss ( 0xe ) 0x6000 sam ;
: vpin ( 0x10 ) 0x0 sam ;
: u* ( nn-hl) ( 0x12 ) dup a! dup or 17 for +* unext
push drop pop a ;
: m/ ( dn-q) --u/mod push drop pop ;
: mv ( -n) ( 0x19 ) vss vdd over - . + push
vpin - . + -if dup or then 1800 u* pop m/ ;
: !mv ( n) ( 0x23 ) io b! 511 u* -1800 m/ 0x155 or !b ;
( 0x2b ) 1900 bin

( block 631 )
( ide mode code.)
: mv ( returns approx pad voltage in mv using contemporaneous cal values from our own rails assuming said rails at) ( 0 ) ( and 1800. no linearization. dac output remains unchanged.)
: !mv ( sets dac output to a voltage in mv. this is most bogus since no linearization is done; the actual voltage will be much higher than what we are setting.)

( block 632 )
( 1901 ) ( ats sync boot master)
reclaim node 300 org 0 
: dly ( 0x0 ) ( b) !b 40 ( 31 ) for unext ;
: 1bt ( 0x3 ) ( wb-w') dup dly 0x10000 or dly ;
: 18o ( 0x6 ) ( w) 0x30000 dly 8 for begin
( 0xa ) -if ( 1-) 0x30003 1bt  swap : rise
( 0xd ) 2* -if ( 1+) 0x20003 1bt 2* *next drop ;
( 0x12 ) ( .)  then ( 0+) 0x20002 1bt 2* *next drop ;
( 0x16 ) ( .)  then ( 0-) 0x30002 1bt rise ;

: off ( 0x19 ) io b! 0x20002 dly 0x10001 !b ;
( 0x1f ) 1901 bin

( block 633 )
( this code is loaded into tb001 test chip node) ( 300 ) ( to boot node) ( 300 ) ( of the uut. the ide uses)  18o ( to form a boot stream to load the link)
( routine into the remote node. once remote)
( is started ide sets the local pins to low)
( tri-state and weak-low before loading the)
( link code into the local node and starting it. at this time both of these nodes remain off of the grid until both the test and uut chip have been reset.)

( block 634 )
( 1902 ) ( boot frame for master testing)
reclaim node 300 org 0
host :: 3- 0xfffffffd + ; target


: frame ser-exec -d--  , 0 
: portex @p !b . . ( /)  , 0x30000 ( /)
( 0x5 ) here here 3- org , 2 org
( 0x5 ) 1902 bin

( block 635 )
( boot frame which commands uut node) ( 0x200 ) ( to set its pin 200.17 high.)

( block 636 )
( 1903 ) ( boot frame for master testing)
reclaim node 300 org 0
host :: 3- 0xfffffffd + ; target


: frame ser-exec -d--  , 0 
: portex @p !b . . ( /)  , 0x20000 ( /)
( 0x5 ) here here 3- org , 2 org
( 0x5 )
org 0x20 
: misc ---u @p - !p ; 1903 bin

( block 637 )
( boot frame which commands uut node) ( 0x200 ) ( to set its pin 200.17 low.)

( block 638 )
( 1904 ) ( ats sync bridge)
reclaim node 300 ( 3 ) org 8
host :: hd- ( -3 ) -8 + ; target


: dly ( 0x8 ) ( b) !b 40 for unext ; ( 88ns)
: 1bt ( 0xb ) ( wb-w') dup dly 0x10000 or dly ;
: zro ( 0xe ) 0x10001 dly ; : wpd ( 0x10 ) 0x10001 !b ;
: 18o ( 0x12 ) ( w) zro 17 for begin
( 0x15 ) -if 0x30003 1bt 2* *next drop wpd ;
( 0x1a )  then 0x30002 1bt 2* next drop wpd ;


: 18i ( 0x1e ) ( x) drop dup or !b 17 for
( 0x21 ) ( ..) begin @b -until
( 0x22 ) ( ..) begin @b - -until
( 0x23 ) ( ..) - 2 and 2/ a 2* or a! next
( 0x27 ) a up a! !


: idl ( 0x2a ) 0x165 ( --lu) a! . @ @b -if drop 18i ;
( 0x2e )  then zro drop 18o idl ;

: ent ( 0x31 ) io b! wpd begin @b - -until idl ;
( 0x36 ) here here hd- ( 0 ) org 5 
: frame ent ,  dly org
( 0x36 ) 1904 bin

( block 639 )
 shadow out of date.
( this code is loaded into nodes) ( 300 ) ( of both)
( the test and uut chips of the tb001 board.)
( the transmitter controls the clock and data is sampled on the falling edge. the clock is set to low tri-state and data to weak-low one half bit time from the end of word. the code idles reading from a neighbor and the clock pin.)
( data from the neighbor are transmitted and)
( receive data are writen to the neighbor. no)
( attempt is made to be able to terminate either of these serial linked nodes except reset.)
( terminating the remote node would require)
( an enhanced protocol. also we see no need)
( to impliment flow control at this time. on)
( entry the code waits for the clock to drop)
( to facilitate transition from the old boot)
( protocol.)
 origin moved to 5 so boot frame header can be laid down without affecting slot 2 jumps.

( block 640 )
( 1905 ) ( uut bridge debug)
reclaim node 300 ( 3 ) org 8
host :: hd- ( -3 ) -8 + ; target


: dly ( 0x8 ) ( b) !b ( 40 ) 400 for unext ; ( 88ns)
: 1bt ( 0xb ) ( wb-w') dup dly 0x10000 or dly ;
: zro ( 0xe ) 0x10001 dly ;
: wpd ( 0x10 ) 0x10001 !b ;
: 18o ( 0x12 ) ( w) zro 17 for begin
( 0x15 ) -if 0x30003 1bt 2* *next drop wpd ;
( 0x1a )  then 0x30002 1bt 2* next drop wpd ;
: 18i ( 0x1e ) ( x) drop dup or !b 17 for
( 0x21 ) ( ..) begin @b -until
( 0x22 ) ( ..) begin @b - -until
( 0x23 ) ( ..) - 2 and 2/ a 2* or a! next
( 0x27 ) a ( up a! !) ( 1 ) ( and) ( 2 ) ( or !b) zro 12345 . + 18o


: idl ( 0x2b ) 0x165 ( --lu) a! ..
( 0x2d ) @ @b -if drop 18i ;  then
( 0x2f ) zro drop 18o ( idl ;)

: ent ( 0x31 ) io b! wpd
begin @b - -until idl ;
( 0x36 ) here here hd- ( 0 ) org 5 
: frame ent ,  dly org
( 0x36 ) 1905 bin

( block 641 )
 shadow out of date.
( this code is loaded into nodes) ( 300 ) ( of both)
( the test and uut chips of the tb001 board.)
( the transmitter controls the clock and data is sampled on the falling edge. the clock is set to low tri-state and data to weak-low one half bit time from the end of word. the code idles reading from a neighbor and the clock pin.)
( data from the neighbor are transmitted and)
( receive data are writen to the neighbor. no)
( attempt is made to be able to terminate either of these serial linked nodes except reset.)
( terminating the remote node would require)
( an enhanced protocol. also we see no need)
( to impliment flow control at this time. on)
( entry the code waits for the clock to drop)
( to facilitate transition from the old boot)
( protocol.)
 origin moved to 5 so boot frame header can be laid down without affecting slot 2 jumps.

( block 642 )
( 1906 ) ( tester bridge debug)
reclaim node 300 ( 3 ) org 8
host :: hd- ( -3 ) -8 + ; target 
: dly ( 0x8 ) ( b) !b ( 40 ) 400 for unext ; ( 88ns)
: 1bt ( 0xb ) ( wb-w') dup dly 0x10000 or dly ;
: zro ( 0xe ) 0x10001 dly ;
: wpd ( 0x10 ) 0x10001 !b ;
: 18o ( 0x12 ) ( w) io b! zro 17 for begin
( 0x17 ) -if 0x30003 1bt 2* *next drop wpd ;
( 0x1c )  then 0x30002 1bt 2* next drop wpd ;
: 18i ( 0x20 ) ( x) drop dup or !b 17 for
( 0x23 ) ( ..) begin @b -until
( 0x24 ) ( ..) begin @b - -until
( 0x25 ) ( ..) - 2 and 2/ a 2* or a! next
( 0x2a ) a ( up a! !) ;
: joe ( 0x2b ) ( w) 18o 18i ;
: idl ( 0x2d ) 0x165 ( --lu) a! ..
( 0x2f ) @ @b -if drop 18i ;  then
( 0x31 ) zro drop 18o ( idl ;)

: ent ( 0x33 ) io b! 0x10001 !b
begin @b - -until ( idl) ;
( 0x3a ) here here hd- ( 0 ) org 5 
: frame ent ,  dly org
( 0x3a ) 1906 bin

( block 643 )
 shadow out of date.
( this code is loaded into nodes) ( 300 ) ( of both)
( the test and uut chips of the tb001 board.)
( the transmitter controls the clock and data is sampled on the falling edge. the clock is set to low tri-state and data to weak-low one half bit time from the end of word. the code idles reading from a neighbor and the clock pin.)
( data from the neighbor are transmitted and)
( receive data are writen to the neighbor. no)
( attempt is made to be able to terminate either of these serial linked nodes except reset.)
( terminating the remote node would require)
( an enhanced protocol. also we see no need)
( to impliment flow control at this time. on)
( entry the code waits for the clock to drop)
( to facilitate transition from the old boot)
( protocol.)
 origin moved to 5 so boot frame header can be laid down without affecting slot 2 jumps.

( block 644 )


( block 645 )


( block 646 )


( block 647 )


( block 648 )
( 1400 ) ( ats cs master0 n108)
reclaim node 108 ( 742 ) ( load) ( 0xaa ) org 0 
: sam ( n-k) ( 0x0 )
( 0x1 )  1400 bin

( block 649 )
( code for node) ( 108 ) ( in ats.)


( block 650 )
( 1401 ) ( ats cs wire)
reclaim node 109 org 0 
: sam ( n-k) ( 0x0 )
( 0x2b )  1401 bin

( block 651 )


( block 652 )
( 1402 ) ( ats cs digital)
reclaim node 717 org 0 
: sam ( n-k) ( 0x0 )
( 0x2b )  1402 bin

( block 653 )
( pf mode code for digital nodes.)

( block 654 )
( 1403 ) ( ats cs analog)
reclaim node 717 org 0 
: sam ( n-k) ( 0x0 ) io b! data a! @b - 0x1ff and or
!b dup ! @ 1000 for unext dup ! @ - . + ;
: vdd ( 0xc ) 0x2000 sam ; : vss ( 0xe ) 0x6000 sam ;
: vpin ( 0x10 ) 0x0 sam ;
: u* ( nn-hl) ( 0x12 ) dup a! dup or 17 for +* unext
push drop pop a ;
: m/ ( dn-q) --u/mod push drop pop ;
: mv ( -n) ( 0x19 ) vss vdd over - . + push
vpin - . + -if dup or then 1800 u* pop m/ ;
: !mv ( n) ( 0x23 ) io b! 511 u* -1800 m/ 0x155 or !b ;
( 0x2b ) 1403 bin

( block 655 )
( pf mode code.)
: mv ( returns approx pad voltage in mv using contemporaneous cal values from our own rails assuming said rails at) ( 0 ) ( and 1800. no linearization. dac output remains unchanged.)
: !mv ( sets dac output to a voltage in mv. this is most bogus since no linearization is done; the actual voltage will be much higher than what we are setting.)

( block 656 )


( block 657 )


( block 658 )
( xxxx smtm mem-random converted)
reclaim node 0 0  org  3
: rnd ( n-n') ( 0x0 ) -if 2* 0x2cd81 or ;  then 2* ;
: run ( 0x4 ) @p @p a! dup ( /)  , 0x12155 , 0xa9 ( /)
 @ 0xb a! .. or 0x3 0x3fff8 .. rnd dup ! and ..
push 0x8 begin 2* . . unext and if or ahead
 swap  then run ; ( 0x14 )  . .. . ..
: go ( 0x16 ) then @ over a! @p ( /) @p dup push dup
a ! ! 0xe push dup ! begin @p ! . unext ( /-)
( 0x1c ) push dup push dup push dup push dup
( 0x1e ) push dup push dup push push pop dup
( 0x20 ) pop pop pop pop pop pop pop pop 0x3f dup
( 0x24 ) push push or dup a! or or or or or or or . ( 0x28 ) begin dup !+ . unext begin @+ or . unext
( 0x2a ) @p a! ! . ( -/) a ! @ or if warm ;  then
: migrate 0x1557f !b 0x1556a . 0x1f for . . . unext
( 0x34 ) !b 0x4 @p . ( /) @p dup 2/ . ( /)
( 0x37 ) a ! ! 0x43 push begin @p !+ . unext ( /-)
( 0x3b )  , 0x3f  2* a! push begin @p !+ . unext
( 0x3e ) @p push ; ( -/)  ! warm ;
( 0x40 ) ( xxxx bin)

( block 659 )
( this is steven's)
( g144-smtm-self-tet-mem-random)

( block 660 )
( tb001 ide pretest) empty serial load

( customize) -canon 660 orgn !
a-com sport ! a-bps bps ! !nam


: mv ( -n)  0x19  call 0x3f lit' ra! !a 0x3f r@ ;
: !mv ( n) lit'  0x23  call ;
: +a ( nn) 2 swap hook 0 64 1900 boot ;


: !vdc ( mv)  709  +a !mv ; : vdc ( -mv)  709  +a mv ;
: !vdi ( mv)  713  +a !mv ; : vdi ( -mv)  713  +a mv ;
: !vda ( mv)  717  +a !mv ; : vda ( -mv)  717  +a mv ;
: !bus ( mv)  117  +a !mv ; : bus ( -mv)  117  +a mv ;
: drain 2  617  hook 0xaa io r! 0x155 io r! ;
: set ( n nn) 2 swap hook  2  +  0x10000  * io r! ;
: rst ( n)  417  set ;
: 1.8 ( n)  715  set ; : 1.475 ( n)  517  set ;
: hivd  1  1.8  0  1.475 ; : lovd  1  1.475  0  1.8 ;
: novd  0  1.8  0  1.475 drain ;

( functions) 662 4 loads
( automate) talk pre

( block 661 )
( these defns are used in ide on ats master to simulate actions later run by polyforth.)


: !vdx ( and) vdx ( drive and read uut power bus)  x ( in nonlinear millivolts.)
: !bus ( and) bus ( do the same with analog bus.)
: rst ( sets uut reset line low if)  n 0 ( or high) 1 
: drain ( used only when no power enabled to short out the supply rails briefly.)
: rst ( controls uut reset line)  0 ( is low.)
: 1.8 ( and) 1.475 ( control power supplies)  1 ( enables) 0 ( disables.)
: hivd lovd ( and) novd ( select high, low, and zero voltage power supply to uut.)

( block 662 )
( - pre powerup tests) 662 list

( preliminary tests) :var vval [0x1]
:var vcop [0x1] :var vcsh [0x1] :var viop [0x1] :var vish [0x1] :var vaop [0x1] :var vash [0x1]


: init 0  vcop  ! 0  vcsh  ! 0  viop  ! 0  vish  !
0  vaop  ! 0  vash  ! 0  vval  ! pause
: -pwr 0 rst 0 !vdc 0 !vdi 0 !vda novd ;

exit ( test procedure...)
: - no chip in socket
: - 'compile'
: - '280 load talk'
: - insert chip
: - 'pre'
: - will stop here if pretests fail
: - else runs creeper tests in 250
: -  always say  -pwr  before removing chip!!!

( block 663 )

: -pwr ( removes all power from uut socket and leaves it) safe ( for inserting or removing chip. puts chip in reset, disables both power supplies, removes drive from power rail test dacs, and drains the rails.)
: ?open ( checks each supply rail for enough loading to believe there's a chip in the socket.)

( block 664 )
( - power opens and shorts)
: sam ( -n) mv mv + mv + mv + 2/ 2/ ;
: -sam ( x-mv) drop sam ;
: lt ( nn-t) less if drop drop 1 ;
 then drop drop 0 ;
: -sht ( n.mv.mv-t) max 2* swap lt ;


: ?cop  75  !vdc sam ( dup)  500  lt  vcop  ! 0 !mv ;
: ?iop  75  !vdi sam ( dup)  500  lt  viop  ! 0 !mv ;
: ?aop  75  !vda sam ( dup)  850  lt  vaop  ! 0 !mv ;
: ?open ?cop pause ?iop pause ?aop pause ;


: ?csht  75  !vdc sam vdi -sam vda -sam
-sht  vcsh  ! 0 !vdc ;
: ?isht  75  !vdi sam vdc -sam vda -sam
-sht  vish  ! 0 !vdi ;
: ?asht  75  !vda sam vdi -sam vdc -sam
-sht  vash  ! 0 !vda ;
: ?short ?csht pause ?isht pause ?asht pause ;

( block 665 )


( block 666 )
( - results)
: chs ( ...n) for emit next ;
: ?good ( -t)  vcop  @  vcsh  @ and  viop  @ and  vish  @ and  vaop  @ and  vash  @ and ;
: .pf ?good drop if
green 42 36 3 3 chs space ;
 then red 42 12 7 5 14 5 chs space ;
: .pok blu  vval  @ 0 + drop if .pf ;
 then silver 11 8 22 19 4 chs space ;

( block 667 )

: .pok ( shows how to make a blue word display variable text strings.)

( block 668 )
( - port bridge)


: !sync 0  300  hook 0 64  1901  boot  0x19  call ;


: pt@ ( a-n) @ 0x15555 or ;
: frame ( a nd) nn-n 2* 32768 + block + dup 2 + pt@ 3 + for dup pt@ lit' 6 call  1  + next drop ;
: !hitst 0  1902  frame ;
: !lotst 0  1903  frame ;
: !his 5  1904 ( 1905 )  frame ;


: !ours ( off)  0x19  call 0 64  1904  boot
( ent)  0x30  call ( testing) 0x0  400  hook focus ;


: setup ?good drop if -pwr !sync hivd 1 rst
 300  node ( !hitst) !his !ours then ;


: pre  662  list pause init
?open ?short 1  vval  ! 123 pause
?good drop if setup
2 -hook 1 -hook 0 -hook drop pause
 670  load ;  then ;

( block 669 )
( set up port bridge.)


: first ( we load sync boot master in our) ( 300 ) ( done by) !sync
: second ( we load bridge in uut node) ( 300 ) ( using) frame ( which sends a boot frame starting at location)  a ( compiled for bin) nd's ( ram)
: third ( we load bridge into our node) ( 300 )


: setup ( does all this and loads new ide for the bridged 2-chip system.)
: pre ( runs full set of pre-tests)

( block 670 )
( tb001 ide creepers) empty serial load

( customize) -canon 670 orgn !
a-com sport ! a-bps bps ! !nam
( functions) 674 5 loads

( test status is)

( details) :var ph [0x3] :var id [0x7d2] :var tgt [0x3e8] :var pos [0x9a]
( -------) :var ans :var rval [0x988a]
( -------) :var nrun [0x3345] :var vval [0x1]


: init 0  tgt  ! 0  pos  ! 0  nrun  ! 0  id  ! 0  rval  ! 0  ans  ! 0  vval  ! -1  ph  ! ;
( runner) 684 9 loads 672 load ( 670 ) ( list)


: run 670 list !p0 !p1 init pause
     -buses 0 1000 hook 0 -hook ana0 ( ;)
0  ph  ! 0 path z t911 t917 ta00 t913
1  ph  ! 1 path z !p1a
2  ph  ! 1 path z !p1 ser70 !p1b ser07 !p1
3  ph  ! lovd 0 path 2007 runall 2002 runall
1  vval  ! -pwr ; run

( block 671 )
( ide environment to run ide and creepers in the uut. path) ( 2 ) ( reaches right side controls. paths) ( 0 ) ( and) ( 1 ) ( are mutually exclusive reaching into the uut.)


: !vdx ( and) vdx ( drive and read uut power bus)  x ( in nonlinear millivolts.)
: !bus ( and) bus ( do the same with analog bus.)
: rst ( sets uut reset line low if)  n 0 ( or high) 1 
: drain ( used only when no power enabled to short out the supply rails briefly.)
: rst ( controls uut reset line)  0 ( is low.)
: 1.8 ( and) 1.475 ( control power supplies)  1 ( enables) 0 ( disables.)
: hivd lovd ( and) novd ( select high, low, and zero voltage power supply to uut.)

 needing special runners - 913 911

( block 672 )
( - all tests)


: z ( lov-ram)  2007  runall
( port)  2000  runall ( port2*)  2001  runall
( ram)  2002  runall ( t,s)  2003  runall
( t,r)  2004  runall ( stack)  2005  runall
( return)  2006  runall ( ms-rdst)  2008  runall
( shifta)  2009  runall ( tsar-data)  2010  runall
( ms-stk)  2012  runall ( carry)  2014  runall
( ms-@p)  2015  runall ( i,r-ad)  2016  runall
( @b!b)  2101  runall ( b-reg)  2102  runall
( i-reg)  2103  runall ( i-reg)  2104  runall
( i-reg)  2105  runall ( i-reg)  2106  runall
( i-reg)  2107  runall ( i-reg)  2108  runall
( i-reg)  2109  runall ( prp-call)  2110  runall
( prp-ex)  2111  runall ( tst-2*)  2115  runall
( tst-2/)  2116  runall ( tst-2/b)  2117  runall
( tst+)  2200  runall ( rdstkv2)  2201  runall
( dstkv2)  2202  runall ( +v2)  2203  runall
( and)  2204  runall ( andv2)  2205  runall
( or)  2206  runall ( orv2)  2207  runall
( -)  2208  runall
;

( block 673 )


( block 674 )
( - multichip ide)
: mwall ( nn-i)  1000  mod swap  1000  mod
over over or drop if swall ;
 then drop drop ( up) 3 ; ' mwall 'wall !


: uup0 align create  , 708 , 707 , 706 , 705 , 704 , 703 , 702 , 701 , 700 , 600 , 500 , 400
, 1400 , 1500 , 1600
, 1700 , 1701 , 1702 , 1703 , 1704 , 1705
, 1706 , 1707 , 1708 , 1709 , 1710 , 1711
, 1712 , 1713 , 1714 , 1715 , 1716 , 1717
, 1617 , 1616 , 1615 , 1614 , 1613 , 1612
, 1611 , 1610 , 1609 , 1608 , 1607 , 1606
, 1605 , 1604 , 1603 , 1602 , 1601
, 1501 , 1502 , 1503 , 1504 , 1505 , 1506
, 1507 , 1508 , 1509 , 1510 , 1511 , 1512
, 1513 , 1514 , 1515 , 1516 , 1517
, 1417 , 1416 , 1415 , 1414 , 1413 , 1412
, 1411 , 1410 , 1409 , 1408 , 1407 , 1406
, 1405 , 1404 , 1403 , 1402 , 1401
, 1301 , 1302 , 1303 , 1304 , 1305 , 1306
, 1307 , 1308 , 1309 , 1310 , 1311 , 1312
, 1313 , 1314 , 1315 , 1316 , 1317


( block 675 )

: mwall ( discards chip id portion of node number and in the special case of two consecutive nodes of same number forces up port to be the wall between them. thus a path going from) ( 400 ) ( to) ( 1400 ) ( uses up to make the connection via the) ( 300 ) ( to) ( 300 ) ( sync bridge.)


: uup0 ( is the primary path for pass/fail testing in the uut. it reaches all nodes but the bridge in) ( 300 )
: uup1 ( is secondary path which passes thru most of the ports skipped by uup1. it does not include nodes 000) ( 100 ) ( 200 ) ( and leaves) ( 4 ) ( ports that have not been exercised.)
: up1a ( is a quick path that is substituted for path) ( 1 ) ( to catch the four remaining ports.)

when all three have been done, only node 300 and its right and down ports have not been exercised.

( block 676 )
( -- paths 0,1)
, 1217 , 1216 , 1215 , 1214 , 1213 , 1212
, 1211 , 1210 , 1209 , 1208 , 1207 , 1206
, 1205 , 1204 , 1203 , 1202 , 1201 , 1200
, 1100 , 1101 , 1102 , 1103 , 1104 , 1105
, 1106 , 1107 , 1108 , 1109 , 1110 , 1111
, 1112 , 1113 , 1114 , 1115 , 1116 , 1117
, 1017 , 1016 , 1015 , 1014 , 1013 , 1012
, 1011 , 1010 , 1009 , 1008 , 1007 , 1006
, 1005 , 1004 , 1003 , 1002 , 1001 , 1000 , -1


: uup1 align create  , 708 , 707 , 706 , 705 , 704 , 703 , 702 , 701 , 700 , 600 , 500 , 400
, 1400 , 1500 , 1600 , 1700
, 1701 , 1601 , 1501 , 1401 , 1301 , 1201
, 1101 , 1001 , 1002 , 1102 , 1202 , 1302
, 1402 , 1502 , 1602 , 1702
, 1703 , 1603 , 1503 , 1403 , 1303 , 1203
, 1103 , 1003 , 1004 , 1104 , 1204 , 1304
, 1404 , 1504 , 1604 , 1704


( block 677 )


( block 678 )
( -- paths 1)
, 1705 , 1605 , 1505 , 1405 , 1305 , 1205
, 1105 , 1005 , 1006 , 1106 , 1206 , 1306
, 1406 , 1506 , 1606 , 1706
, 1707 , 1607 , 1507 , 1407 , 1307 , 1207
, 1107 , 1007 , 1008 , 1108 , 1208 , 1308
, 1408 , 1508 , 1608 , 1708
, 1709 , 1609 , 1509 , 1409 , 1309 , 1209
, 1109 , 1009 , 1010 , 1110 , 1210 , 1310
, 1410 , 1510 , 1610 , 1710
, 1711 , 1611 , 1511 , 1411 , 1311 , 1211
, 1111 , 1011 , 1012 , 1112 , 1212 , 1312
, 1412 , 1512 , 1612 , 1712
, 1713 , 1613 , 1513 , 1413 , 1313 , 1213
, 1113 , 1013 , 1014 , 1114 , 1214 , 1314
, 1414 , 1514 , 1614 , 1714
, 1715 , 1615 , 1515 , 1415 , 1315 , 1215
, 1115 , 1015 , 1016 , 1116 , 1216 , 1316
, 1416 , 1516 , 1616 , 1716
, 1717 , 1617 , 1517 , 1417 , 1317 , 1217
, 1117 , 1017 , -1

( block 679 )


( block 680 )
( -- paths 1a)

: up1a align create  , 708 , 707 , 706 , 705 , 704 , 703 , 702 , 701 , 700 , 600 , 500 , 400
, 1400 , 1401 , 1501 , 1500 , 1600 , 1601
, 1602 , 1502 , 1402 , 1302 , 1202
, 1201 , 1200 , 1100 , 1000 , -1


: up1b align create  , 708 , 707 , 706 , 705 , 704 , 703 , 702 , 701 , 700 , 600 , 500 , 400
, 1400 , 1401 , 1301 , 1201 , 1101 , 1001
, 1002 , 1102 , 1202 , 1302 , 1402 , 1502
, 1602 , 1702 , 1701 , 1700 , -1


: !p0 uup0  'pths  ! ;
: !p1 uup1  'pths  1 + ! ;
: !p1a up1a  'pths  1 + ! ;
: !p1b up1b  'pths  1 + ! ;

( block 681 )

: path1a ( catches the port walls that are left)
( after using paths) ( 0 ) ( and 1.)
: path1b ( reverses path) ( 1 ) ( swapping serdes roles.)

( block 682 )
( - control lines)


: mv ( -n)  0x19  call 0x3f lit' ra! !a 0x3f r@ ;
: !mv ( n) lit'  0x23  call ;
: +a ( nn) 2 swap hook 0 64 1900 boot ;


: !vdc ( mv)  709  +a !mv ; : vdc ( -mv)  709  +a mv ;
: !vdi ( mv)  713  +a !mv ; : vdi ( -mv)  713  +a mv ;
: !vda ( mv)  717  +a !mv ; : vda ( -mv)  717  +a mv ;
: !bus ( mv)  117  +a !mv ; : bus ( -mv)  117  +a mv ;
: drain 2  617  hook 0xaa io r! 0x155 io r! ;
: set ( n nn) 2 swap hook  2  +  0x10000  * io r! ;
: rst ( n)  417  set ;
: 1.8 ( n)  715  set ; : 1.475 ( n)  517  set ;
: hivd  1  1.8  0  1.475 ; : lovd  1  1.475  0  1.8 ;
: novd  0  1.8  0  1.475 drain ;


: -pwr 0 rst 0 !vdc 0 !vdi 0 !vda novd drain ;

( block 683 )
( these defns control and interrogate the uut.)
: !vdx ( and) vdx ( drive and read uut power bus)  x ( in nonlinear millivolts.)
: !bus ( and) bus ( do the same with analog bus.)
: rst ( sets uut reset line low if)  n 0 ( or high) 1 
: drain ( used only when no power enabled to short out the supply rails briefly.)
: rst ( controls uut reset line)  0 ( is low.)
: 1.8 ( and) 1.475 ( control power supplies)  1 ( enables) 0 ( disables.)
: hivd lovd ( and) novd ( select high, low, and zero voltage power supply to uut.)

( block 684 )
( - all-nodes runner)


: pt@ ( -a) paths  pos  @ + ;
: active ( -nn) pt@ @ ;
: nxt ( -nn) pt@ 1 + @ ;
: -us ( nn-nn) dup paths @ or drop ;
: -end ( nn-nn) dup -1 or drop ;

:var 'arg [0x10199629]
: -try ( n-t) 1  nrun  +! test dup  ans  ! 0 or drop ;
: ecch ( fail) 0xbad 0xbad rip 1  vval  ! abort ;
: pass  'arg  xqt -try if ecch then ;


: /all ( n)  id  ! targets @  pos  ! pause
0 64  id  @ boot ( ?ram) pfocus ( punchout ;)
: hike key? active nxt -us if -end if
dup  tgt  ! ( pause) wall port tfocus pass
creep 1  pos  +! hike ;
 then then drop drop rip ;
: /zero  'arg  assign 0 ;
: runall ( n) /zero /all rip ;

( block 685 )

: tgt ( current target node)
: pos ( posn of current active node in path)
: nrun ( number of tests run on current chip)
: id ( puka number for test being run)
: ans ( most recent answer from a test)


: pt@ ( addresses path table for active node.)
: active ( returns active node no. yxx format)
: nxt ( returns next target node in path.)
: -us ( true if node given is not current boot)
: -end ( true if node given is not end path marker)
: -pass ( runs current test, true if failed)


: runall ( runs the test whose puka number is given on all nodes using the selected path. this path must be empty, selecting a node adjacent to the boot in use.)
: hike ( starts with active node selected. runs test against next node then creeps into it and repeats. aborts on test fail. returns with path ripped and ready to load new test after all remaining nodes in path have been tested ok.)

( block 686 )
( - incremental runner)


: some ( n)  id  ! targets @  pos  ! pause
0 64  id  @ boot ( ?ram) pfocus ;
: adv active nxt -us if -end if dup  tgt  !
( pause) wall port tfocus creep 1  pos  +! ;
 then then ecch ;
: kreep ( nn) begin key? active dup  tgt  !
over or drop while adv end then drop ;
: uno ( nn) kreep 0 pass ;

( block 687 )
( runner components for tests that do not apply to all nodes and for tests that work on the active rather than the target node.)


: some ( starts work on current path given test in given bin.)
: adv ( steps to the next node in path.)
: kreep ( advances to make the given node active.)
: uno ( kreeps if necessary to the given node and runs the test there.)

( usage...)  906 some
1500 kreep 1 pass 1600 uno rip

( block 688 )
( - build table of valid io w/r bits)
: iom  nns aray 0x201ff 0 iom nns fill 
: iom! ( nm) push nn-n iom dup @ pop or swap ! ;
: c0, ( n) 0x1e00 iom! ; : l0, ( n) 0x1800 iom! ;
: u0, ( n) 0x600 iom! ; : !l ( nn) over l0, iom! ;
: !u ( nn) over u0, iom! ; : l1, ( n) 0x20000 !l ;
: u1, : us, : u18, ( n) 0x20000 !u ;
: l2, ( n) 0x20003 !l ; : u2, ( n) 0x20003 !u ;
: u4, ( n) 0x2003f !u ; : la, ( nn) l1, l1, ;
: ua, ( nn) u1, u1, ;

( single) 100 l1, 317 l1, 417 l1, 500 l1, 600 l1, ( serdes) 1 us, 701 us, ( spi) 705 u4,
( async) 708 u2, ( 1wire) 200 l1, ( sync) 300 l2,
( parallel) 7 u18, 8 u4, 9 u18,
( analog) 709 715 ua, 713 715 ua, 717 715 ua,
117 217 la, 617 517 la,
( no pins) 0 c0, 2 u0, 3 u0, 4 u0, 5 u0, 6 u0,
10 u0, 11 u0, 12 u0, 13 u0, 14 u0, 15 u0,
16 u0, 17 c0, 400 l0, 700 c0, 702 u0, 703 u0, 704 u0, 706 u0, 707 u0, 710 u0,
711 u0, 712 u0, 714 u0, 716 u0,

( block 689 )
( notes-)

( this took the bulk of the code from softsim)

( block 690 )
( - build table of rom checksums)
: sums  nns aray 0 0 sums nns fill 
: !sum ( n) dup push 2* 0x8000 + block 0x80 + 0x0
     63 for over i + @ or -next
     pop sums ! drop ;
: !sums  nns -1 +  for i !sum -next ; !sums


( block 691 )


( block 692 )
( - results)
: chs ( ...n) for emit next ;
: .pf  ans  @ 0 + drop if
red 42 12 7 5 14 5 chs space ;
 then green 42 36 3 3 chs space ;
: .pok blu  vval  @ 0 + drop if .pf ;
 then silver 11 8 22 19 4 chs space ;


: -buses 0 1009 hook ( ou) 0x15555 io r! 0x0 data r!
0 1007 hook ( in) 0x14555 io r! 0x0 data r! ;

( block 693 )

: .pok ( shows how to make a blue word display variable text strings.)


: -buses ( quiets test chip parallel buses by setting) ( 7 ) ( to read and) ( 9 ) ( to write. this facilitates later creeper test using path 0. easily burns hundreds of ma if not done due to cross coupling of output mode buses on powerup.)

( block 694 )
( - runner for) ( 911 ) ( pin test)


: atest ( arg-ans) 1  nrun  +! test dup  rval  ! ;
: within ( nlh-t) push less drop pop if drop 0 and ;  then less if drop -1 +or ;  then drop 0 and ;
: pinok ( ans) 16 /mod 16 /mod 24 180 within
push 4 12 within push 4 12 within pop and
pop and ( ;) drop if ;  then 2011  ans  ! ecch ;


: p17 0x30000 ;
: p5 0x30 ; : p3 0xc ; : p1 0x3 ;
: a911 ( p) atest pinok ;
: n911 ( np) swap kreep a911 ;
: t911 0 path 2011 some
 1500  p17 n911  1600  p17 n911
 1705  p1 n911  p3  a911  p5  a911
( 1k pullup)  p17  atest  0x7000  +or pinok
( no-caps) ( 1708 ) ( p17 n911 p1 a911)
 1715  p17 n911  1517  p17 n911  1417  p17 n911
 1317  p17 n911  1217  p17 n911 rip ;

( block 695 )


( block 696 )
( - runner for) ( 917 ) ( rom checksum)


: /917  'arg  assign  tgt  @ 1000 mod nn-n sums @ ;
: t917 /917 2017 /all rip ;
: /913  'arg  assign  tgt  @ 1000 mod nn-n iom @ ;
: t913 /913 2013 /all rip ;


: na00 ( np) swap kreep -try if ecch then ;
: ta00 0 path 2100 some
 1009  0x14555 na00  1007  0x14555 na00 rip
1 path 2100 some
 1007  0x14555 na00  1009  0x15555 na00 rip 0 path ;

( block 697 )

: t917 ( needs arg of expected xor checksum value.)
: t913 ( needs arg of io latch bit mask.)
: ta00 ( needs arg of state to leave in io at end.)

( block 698 )
( - runner for) ( 2113 ) ( serdes test)


: /many  'arg  assign 250000 ;
: stest ( arg-ans) /many pass ;


: ser70 1 path  2112  some /zero
 1701  kreep pass
 1001  kreep 0  5  vtest drop
1 path  2113  some  1701  kreep stest rip ;


: ser07 1 path  2112  some /zero
 1001  kreep pass
 1701  kreep 0  5  vtest drop
1 path  2113  some  1001  kreep stest rip ;

( block 699 )


( block 700 )
( - runner for) ( 2114 ) ( analog test)

:var 'side [0x10199a03]
: tops  'side  assign  0x13  ;
: rights  'side  assign  0x7  ;
: stest ( arg-ans) /many pass ;
: atest ( arg.ent-ans) 1  nrun  +! vtest dup  rval  ! ;
: !da ( n)  0x4  atest drop ;
: @ad ( n-n) 0x155 or  'side  xqt atest ;
: @vdd ( -n)  0x2000  @ad ; : @vss ( -n)  0x6000  @ad ;
: @off ( -n)  0x4000  @ad ; : @pad ( -n)  0x0  @ad ;


: a? ( nlhk) push within if drop pop drop ;  then
pop  ans  ! ecch ;
: /vlo 13000 14700 ; : /vhi 8250 9350 ;
: aok ( nn) kreep pause @off 0 1  1  a?
@vdd /vhi  2  a?
@vss /vlo  3  a?  0xaa  @ad /vhi  4  a?
@pad /vlo  5  a? 1800 !bus 0 path
@pad /vhi  6  a? 0 !bus 0 path ;
: ana0 0 path  2114  some
tops  1709  aok  1713  aok  1717  aok
rights  1617  aok  1117  aok rip ;

( block 701 )


( block 702 )


( block 703 )


( block 704 )


( block 705 )


( block 706 )


( block 707 )


( block 708 )
( selftest a chip, port on stack) empty stp !

compile serial load -canon :var usb [0x3]
stp @ dup sport ! usb ! a-bps bps ! !nam
( functions) 674 4 loads ( exit)

( test status is)

( details) :var ph [0x3] :var id [0x391] :var tgt [0x2bd] :var pos [0x7]
( -------) :var ans :var rval
( -------) :var nrun [0x2d00] :var vval [0x1]


: init 0  tgt  ! 0  pos  ! 0  nrun  ! 0  id  ! 0  rval  ! 0  ans  ! 0  vval  ! -1  ph  ! ; init
( runner) 684 7 loads 672 load 710 load


: run  708  list init pause talk
     2pa  'pths  2 + !
     2 708 hook 2 -hook !p0 !p1 !p2 ( ;)
0  ph  ! 0 path z t917 t913
1  ph  ! 1 path z t917 t913
2  ph  ! 2 path z t917 t913 !p1a
3  ph  ! 1 path z t917 t913
1  vval  ! ; run

( block 709 )
( this code runs selected creeper tests directly on a chip using the ide. use with a-com/c-com or a literal port number.)


: tgt ( current target node)
: pos ( posn of current active node in path)
: nrun ( number of tests run on current chip)
: id ( puka number for test being run)
: ans ( most recent answer from a test)

( block 710 )
( - paths)
: line ( ncd) swap push swap
     begin dup , over + -next drop drop ;
: count ( nc-ncd) dup  100  mod  0  + if
( horz) swap drop  1  ; ( vert)  then drop  100  /  100  ;
: to ( nn) over negate + -if
( back) negate count negate line ;
( forw)  then count line ;


: stp2 align create  708 717 to 617 600 to
500 517 to 417 400 to 300 317 to 217 200 to
100 117 to 17 0 to , -1 
: stp1 align create  708 8 to 7 707 to
706 6 to 5 705 to 704 4 to 3 703 to
702 2 to 1 701 to 700 0 to , -1 
: stp1a align create  708 701 to , -1 
: stp0 align create  708 8 to 9 709 to 710 10 to 11 711 to 712 12 to 13 713 to 714 14 to
15 715 to 716 16 to 17 717 to , -1


: !p0 stp0  'pths  ! ; : !p1 stp1  'pths  1 + ! ;
: !p1a stp1a  'pths  1 + ! ;
: !p2 stp2  'pths  2 + ! ;

( block 711 )

: line ncd ( comma nodes into a table starting at node) n ( for) c ( nodes incrementing by) d

: /left ( extend line toward the left)
: /right ( extend line toward the right)
: /up ( extend line upward)
: /down ( extend line downward)
: path ( make a default path table that)
( covers the whole chip)

( block 712 )
( ats target test given host port) empty stp !

compile serial load -canon :var usb [0x3]
stp @ dup sport ! usb ! a-bps bps ! !nam
( functions) 674 4 loads ( exit)

( test status is)

( details) :var ph [0xffffffff] :var id :var tgt :var pos
( -------) :var ans :var rval
( -------) :var nrun :var vval


: init 0  tgt  ! 0  pos  ! 0  nrun  ! 0  id  ! 0  rval  ! 0  ans  ! 0  vval  ! -1  ph  ! ; init
( runner) 684 7 loads 672 load 710 load
714 3 loads


: run  712  list init pause talk
( ..) 2pa  'pths  2 + ! 2 708 hook 2 -hook
( ..) !p0 !p1 !p2 setup ( ;)
0  ph  ! 0 path z t917 t913
1  ph  ! 1 path z t917 t913 !p1a
2  ph  ! 1 path z t917 t913 !p1
3  ph  ! serht serth talk 1  vval  ! ; run

( block 713 )
( this code runs selected creeper tests directly on a chip using the ide. use with a-com/c-com or a literal port number.)


: tgt ( current target node)
: pos ( posn of current active node in path)
: nrun ( number of tests run on current chip)
: id ( puka number for test being run)
: ans ( most recent answer from a test)

( block 714 )
( - paths)
: atp2 align create
 708 700 to 600 300 to , -1

: atp0 align create  708 408 to 407 400 to
1400 1700 to 1701 1717 to 1617 1601 to
1501 1517 to 1417 1401 to 1301 1317 to
1217 1200 to 1100 1117 to 1017 1000 to , -1 
: atp1 align create  708 408 to 407 400 to
1400 1700 to 1701 1001 to 1002 1702 to
1703 1003 to 1004 1704 to 1705 1005 to
1006 1706 to 1707 1007 to 1008 1708 to
1709 1009 to 1010 1710 to 1711 1011 to
1012 1712 to 1713 1013 to 1014 1714 to
1715 1015 to 1016 1716 to 1717 1017 to , -1 
: atp1a align create  708 408 to 407 400 to
1400 1401 to 1501 1500 to 1600 1602 to
1502 1202 to 1201 1200 to 1100 1000 to , -1


: !p0 atp0  'pths  ! ; : !p1 atp1  'pths  1 + ! ;
: !p1a atp1a  'pths  1 + ! ;
: !p2 atp2  'pths  2 + ! ;

( block 715 )
( these paths are used by host chip to test the target chip via sync node 300.)


: atp2 ( runs from) ( 708 ) ( to the) ( 700 ) ( corner and down to) ( 500 ) ( which controls target reset, accessing) ( 701 ) ( for)  serdes ( testing along the way. includes) ( 300 ) ( so it may be used to boot both chips' 300.)
: atp0 atp1 ( and) atp1a ( steer clear of path two on their way to node 300's up port where they duplicate the paths used on tb001 for ats testing)

( block 716 )
( - build port bridge)
: set ( n nn) 2 swap hook  2  +  0x10000  * io r! ;
: rst ( n)  500  set ;


: !sync 2  300  hook 0 64  1901  boot  0x19  call ;


: pt@ ( a-n) @ 0x15555 or ;
: frame ( a nd) nn-n 2* 32768 + block + dup 2 + pt@ 3 + for dup pt@ lit' 6 call  1  + next drop ;
: !hitst 0  1902  frame ;
: !lotst 0  1903  frame ;
: !his 5  1904 ( 1905 )  frame ;


: !ours ( off)  0x19  call 0 64  1904  boot ( ent)  0x30  call ;

: setup 0 rst !sync 1 rst
2  300  hook ( !hitst) !his !ours 2 -hook
( testing) 0x0  400  hook focus ( ;)
2 -hook 1 -hook 0 -hook ;

( block 717 )

: setup ( resets target chip and sets up the port bridge for ide and creeper use.)


: first ( we load sync boot master in our) ( 300 ) ( done by) !sync
: second !his ( loads bridge in uut node) ( 300 ) ( using) frame ( which sends a boot frame starting at location)  a ( compiled for bin) nd's ( ram)
: third !ours ( loads bridge into our node) ( 300 )


: setup ( does all this and leaves ide set to node) ( 400 ) ( which may talk to) ( 1400 ) ( through its up port for testing of the bridged 2-chip system.)

( block 718 )
( - runner for) ( 2113 ) ( serdes test)


: /many  'arg  assign 250000 ;
: stest ( arg-ans) /many pass ;


: serht 2 path  2112  some /zero
( ..)  701  kreep pass rip
1 path  2112  some /zero
( ..)  1001  kreep 0  5  vtest drop
2 path  2113  some  701  kreep stest rip ;


: serth 1 path  2112  some /zero
( ..)  1001  kreep pass rip
2 path  2112  some /zero
( ..)  701  kreep 0  5  vtest drop
1 path  2113  some  1001  kreep stest rip ;

( block 719 )

: serht ( transmits 250k words from host) ( 701 ) ( into tgt 001 with success feedback.)

( block 720 )
( g144a12 automated testing system)
copyright c 2010-2011  greenarrays, inc.
 see db007 for ats documentation

 480 ( load block for f18 test code)
     ( compiled for bins) ( 900 ) ( and up)
482 ( f18 test code and documentation)
560 ( f18 ats master code ide mode)
576 ( test compilation of steven's mem-random)
580 ( pf ats f18 code)
660 ( load block for tb001 ats ide pretest)
670 ( load block for tb001 ats ide creepers)
706 ( load block for creeper control scripts)

( block 721 )


( block 722 )


( block 723 )


( block 724 )


( block 725 )


( block 726 )


( block 727 )


( block 728 )


( block 729 )


( block 730 )


( block 731 )


( block 732 )


( block 733 )


( block 734 )


( block 735 )


( block 736 )


( block 737 )


( block 738 )


( block 739 )


( block 740 )


( block 741 )


( block 742 )


( block 743 )


( block 744 )


( block 745 )


( block 746 )


( block 747 )


( block 748 )


( block 749 )


( block 750 )


( block 751 )


( block 752 )


( block 753 )


( block 754 )


( block 755 )


( block 756 )


( block 757 )


( block 758 )


( block 759 )


( block 760 )


( block 761 )


( block 762 )


( block 763 )


( block 764 )


( block 765 )


( block 766 )


( block 767 )


( block 768 )


( block 769 )


( block 770 )


( block 771 )


( block 772 )


( block 773 )


( block 774 )


( block 775 )


( block 776 )


( block 777 )


( block 778 )


( block 779 )


( block 780 )


( block 781 )


( block 782 )


( block 783 )


( block 784 )


( block 785 )


( block 786 )


( block 787 )


( block 788 )


( block 789 )


( block 790 )


( block 791 )


( block 792 )


( block 793 )


( block 794 )


( block 795 )


( block 796 )


( block 797 )


( block 798 )


( block 799 )


( block 800 )


( block 801 )


( block 802 )


( block 803 )


( block 804 )


( block 805 )


( block 806 )


( block 807 )


( block 808 )


( block 809 )


( block 810 )


( block 811 )


( block 812 )


( block 813 )


( block 814 )


( block 815 )


( block 816 )


( block 817 )


( block 818 )


( block 819 )


( block 820 )


( block 821 )


( block 822 )


( block 823 )


( block 824 )


( block 825 )


( block 826 )


( block 827 )


( block 828 )


( block 829 )


( block 830 )


( block 831 )


( block 832 )


( block 833 )


( block 834 )


( block 835 )


( block 836 )


( block 837 )


( block 838 )


( block 839 )


( block 840 )
( uncommitted/user code)

( block 841 )
( this index page of) ( 120 ) ( blocks is available for user code.)

( any code delivered in this area is provided to facilitate working with examples presented in the user's guide. it may be deleted if you no longer have use for it.)

( when deleting examples here, be sure to remove references in load blocks such as 200.)

( block 842 )
( pwm demo) node 600 org 0


: pol ( 0x0 ) @b 0x2000 ( dw) and if
( ...) ( 0x3 ) ( ...) down b! @b push ex

: rtn ( 0x6 ) ( ...) io b! then ( 0x8 ) drop

( cyc ie-) 0x1ffff and over . + -if
( ...) ( 0xc ) ( ...) 0x20000 !b pol ;
( ...) ( 0xf )  then 0x10000 ( 0x0 ) !b pol ;


: upd ( 0x12 ) ( xex-) drop push drop 0x100
( ...) ( 0x14 ) pop pop ( iex-) rtn ; ( 0x16 )

( block 843 )
( pwm demo for host node) ( 600 )


: pol ( checks for ide inputs and calls) down
( when noticed.)
: rtn ( is the return point from a) down ( call)
( and is used by)  upd ( as an re-entry point.)
: cyc ( begins the actual pwm code.)
: upd ( is the ide entry point for initial)
( start or output update.)

( block 844 )
( demo ide boot) empty compile serial load

( customize) -canon 0 fh orgn !
a-com sport ! a-bps bps ! !nam


: seed ( n) 0x13 r! 0x12 call upd ;


: run talk 0 600 hook 0 64 600 boot
     upd ?ram panel 0 lit 0x18000 seed ;

( block 845 )
( configure ide for demo testing.)

[compile] ***no [compile] canonical [compile] opcodes***
use the  'remote'  ones


: seed ( loads pwm 'rate' and re-/runs cycle.)
: run ( selects node) ( 600 ) ( target, loads the pwm)
( into it and starts it with a default value.)

( block 846 )
( loader template) host load loader load ( using default ide paths) ( kill boots) 0 708 hook 0 -hook ( setup application) 600 +node 600 /ram 0 1 /stack 0x12 /p ( visit whole chip) 2 ship panel upd ?ram

( block 847 )


( block 848 )
( framer template) empty compile streamer load framer load ( default) entire course ( setup application) 600 +node 600 /ram 0 1 /stack 0x12 /p ( make boot) frame ( feedback) 0 fh loaded ! nores strlen leng ! ( erase flash) stream ers ( flash) stream 0 swap 18burn

( block 849 )


( block 850 )


( block 851 )


( block 852 )


( block 853 )


( block 854 )


( block 855 )


( block 856 )


( block 857 )


( block 858 )


( block 859 )


( block 860 )


( block 861 )


( block 862 )


( block 863 )


( block 864 )


( block 865 )


( block 866 )


( block 867 )


( block 868 )


( block 869 )


( block 870 )


( block 871 )


( block 872 )


( block 873 )


( block 874 )


( block 875 )


( block 876 )


( block 877 )


( block 878 )


( block 879 )


( block 880 )


( block 881 )


( block 882 )


( block 883 )


( block 884 )


( block 885 )


( block 886 )


( block 887 )


( block 888 )


( block 889 )


( block 890 )


( block 891 )


( block 892 )


( block 893 )


( block 894 )


( block 895 )


( block 896 )


( block 897 )


( block 898 )


( block 899 )


( block 900 )


( block 901 )


( block 902 )


( block 903 )


( block 904 )


( block 905 )


( block 906 )


( block 907 )


( block 908 )


( block 909 )


( block 910 )


( block 911 )


( block 912 )


( block 913 )


( block 914 )


( block 915 )


( block 916 )


( block 917 )


( block 918 )


( block 919 )


( block 920 )


( block 921 )


( block 922 )


( block 923 )


( block 924 )


( block 925 )


( block 926 )


( block 927 )


( block 928 )


( block 929 )


( block 930 )


( block 931 )


( block 932 )


( block 933 )


( block 934 )


( block 935 )


( block 936 )


( block 937 )


( block 938 )


( block 939 )


( block 940 )


( block 941 )


( block 942 )


( block 943 )


( block 944 )


( block 945 )


( block 946 )


( block 947 )


( block 948 )


( block 949 )


( block 950 )


( block 951 )


( block 952 )


( block 953 )


( block 954 )


( block 955 )


( block 956 )


( block 957 )


( block 958 )


( block 959 )


( block 960 )
( uncommitted/user code)

( block 961 )
( this index page of) ( 120 ) ( blocks is available for user code.)

( any code delivered in this area is provided to facilitate working with examples presented in the user's guide. it may be deleted if you no longer have use for it.)

( when deleting examples here, be sure to remove references in load blocks such as 200.)

( block 962 )


( block 963 )


( block 964 )


( block 965 )


( block 966 )


( block 967 )


( block 968 )


( block 969 )


( block 970 )


( block 971 )


( block 972 )


( block 973 )


( block 974 )


( block 975 )


( block 976 )


( block 977 )


( block 978 )


( block 979 )


( block 980 )


( block 981 )


( block 982 )


( block 983 )


( block 984 )


( block 985 )


( block 986 )


( block 987 )


( block 988 )


( block 989 )


( block 990 )


( block 991 )


( block 992 )


( block 993 )


( block 994 )


( block 995 )


( block 996 )


( block 997 )


( block 998 )


( block 999 )


( block 1000 )


( block 1001 )


( block 1002 )


( block 1003 )


( block 1004 )


( block 1005 )


( block 1006 )


( block 1007 )


( block 1008 )


( block 1009 )


( block 1010 )


( block 1011 )


( block 1012 )


( block 1013 )


( block 1014 )


( block 1015 )


( block 1016 )


( block 1017 )


( block 1018 )


( block 1019 )


( block 1020 )


( block 1021 )


( block 1022 )


( block 1023 )


( block 1024 )


( block 1025 )


( block 1026 )


( block 1027 )


( block 1028 )


( block 1029 )


( block 1030 )


( block 1031 )


( block 1032 )


( block 1033 )


( block 1034 )


( block 1035 )


( block 1036 )


( block 1037 )


( block 1038 )


( block 1039 )


( block 1040 )


( block 1041 )


( block 1042 )


( block 1043 )


( block 1044 )


( block 1045 )


( block 1046 )


( block 1047 )


( block 1048 )


( block 1049 )


( block 1050 )


( block 1051 )


( block 1052 )


( block 1053 )


( block 1054 )


( block 1055 )


( block 1056 )


( block 1057 )


( block 1058 )


( block 1059 )


( block 1060 )


( block 1061 )


( block 1062 )


( block 1063 )


( block 1064 )


( block 1065 )


( block 1066 )


( block 1067 )


( block 1068 )


( block 1069 )


( block 1070 )


( block 1071 )


( block 1072 )


( block 1073 )


( block 1074 )


( block 1075 )


( block 1076 )


( block 1077 )


( block 1078 )


( block 1079 )


( block 1080 )
( compile 16-bit eforth virtual machine)
reclaim ( sram cluster mk1) sram load ( user) node 108 org 0x39 278 load 1817 bin
( boot flash-sram pipe) 1170 2 loads ( e4vm16 siobus wires) 1120 load
     ( tx plug) node 100 1124 load
     ( rx plug) node 200 1126 2 loads
     ( 1-pin plug) node 500 1130 load
     ( 1-pin plug) node 600 1130 load 1813 bin ( flash plug) node 704 1132 load
( e4vm16 stack) node 106
     ( sram+) org 0x39 278 load
     1082 2 loads ( +buds) 1086 4 loads
( e4vm16 bitsy +buds) 1094 8 loads
( e4vm16 starter) node 207 ( sram+) org 0x39 278 load ' -d-- ' ---u 0x8a00 1114 load
( e4vm16 flash-sram pipe) ( 1110 ) ( load)
( erase and burn flash) 288 load
( spi speedup) 290 load

( block 1081 )


( block 1082 )
( - e4vm16 stack 8xxx-9xxx)
( 'x@) org 0x3c 
: 'au@ ( a-w) ( 0x3c )  org 0x0 
: '1+ ( w-w) ( 0x0 ) 1 . + : mask ( w-w) ( 0x2 ) 0xffff and ;
: '2/ ( w-w) ( 0x4 ) 2* 2* 2/ 2/ 2/ mask ;
: popt ( p-pt) ( 0x6 ) dup '1+ over x@ ;
: 'au! ( pst-p43) ( 0x8 ) x!
: popst ( p-pst) ( 0x9 ) popt
: pops ( pt-pst) ( 0xa ) push popt pop ;
: pop43 ( pst-p43st) ( 0xc ) push push popst pop pop ;
: '1- ( w-w) ( 0xe ) -1 . + mask ; here ( 'x!-2) org 0x37 
: psht ( pt-p) ( 0x37 ) push '1- pop over ( x! ;) ( 0x839 ) ( org  *)
: pshs ( pst-pt) ( 0x11 ) push psht pop ;
: pshw ( pstw-ptw) ( 0x13 ) push pshs pop ;
: 'sp@ ( pst-ptp) ( 0x15 ) pshs psht dup pops ;
: 'sp! ( ptp-pst) ( 0x18 ) pshs popst ;


: 'drop ( pst-p3s) ( 0x1a ) drop pops ;
: 'dup ( pst-ptt) ( 0x1b ) dup pshw ;
: 'over ( pst-pts) ( 0x1c ) over pshw ;
: 'swap ( st-ts) ( 0x1d ) over push push drop pop pop ;
: 'or ( pst-p3w) ( 0x1f ) over - and
: 'xor ( pst-p3w) ( 0x20 ) or pops ;
: 'and ( pst-p3w) ( 0x21 ) and pops ;

( block 1083 )
( notes-)
     ( the e4th stack node must abut the memory driver to have fast bidirectional access to)
( external memory.)
     ( the code must not overwrite the sram user code compiled at) 0x39
      psht ( is placed so it falls into) x!
     ( names beginning with ' are e4vm code words. others are internal words)
     ( e4th's external data stack grows down)
( with pre-dec writes and post-inc reads.)
     ( the stack-node's stack keeps the e4th)
 stack pointer ( and cached) s ( and) t
     ( 16-bit words are) 00.nnnn.nnnn.nnnn.nnnn

( block 1084 )
( --- more stack)
: 'um+ ( uu-uc) ( 0x22 ) + 0x10000 over and if or 1 ;
: 'nop ( 0x27 ) then ;
: 'zlt ( n-f) ( 0x28 ) 2* 2* -if dup or ..
: 'inv ( w-w) ( 0x2a ) - mask ; ( 0x2b )  then dup or ;

( 0x2c ) ( must be at or before) org 0x32
( bitsy left slot2 call reaches) ( 0x30 ) ( -) ( 0x37 )
: c.s* ( code0* prix3) ( 0x32 ) 2* -if
( code01* prix4) ( 0x33 ) 2* -if -d-- ;  then ---u ;
( code00* prix4) ( 0x36 )  then drop push ;

( 0x37 ) exit ( started by ide)
: start 0xffe0 0x0 dup ( sp.s.t)
     ( memory) right b! ( bitsy) --l- ; ( 0x3d )

( block 1085 )
( notes-)
     ( the initial sp is reset by) cold
     ( code must fit before)  psht

( block 1086 )
( -- stack up bud axxx) node 206 org 0x20 
: start @p b! ahead  ' , ---u 
: xqt ( 0x22 ) @b push ex
: cmd ( 0x23 ) then @p !b ( ...) xqt ; ( /)  drop !p .. ( /)

( 0x25 )

( block 1087 )


( block 1088 )


( block 1089 )


( block 1090 )
( -- stack down bud bxxx) node 6 org 0x20 
: start @p b! ahead  ' , -d-- 
: xqt ( 0x22 ) @b push ex
: cmd ( 0x23 ) then @p !b ( ...) xqt ; ( /)  drop !p .. ( /)


: .ex! ( pst-p54) ( 0x25 ) @p @p @p ( reversed!)
     ( /) pops ; ( ')  ex! ( ') pop43 ( /) !b !b !b ;
: .ex@ ( pst-p3w) ( 0x2a ) @p @p .. ( reversed!)
     ( /) pops ; ( ')  ex@ ( /) !b !b ;
: .cx? ( pst-p5f) ( 0x2e ) @p @p @p ( reversed!)
     ( /) pops ; ( ')  cx? ( ') pop43 ( /) !b !b !b ;


: '+ ( pst-p3n) ( 0x33 ) @p @p .. ( reversed!)
     ( /) pops ; ( ')  + mask ( /) !b !b ;
: '2* ( w-w) ( 0x37 ) @p !b ; ( /)  2* mask ; ( /) ( 0x39 )

( block 1091 )


( block 1092 )


( block 1093 )


( block 1094 )
( - e4vm16 bitsy cxxx) node 105 org 0x0 
: inc ( a-a) ( 0x0 ) 1 . + ;
: bpshw ( w-) ( 0x2 ) @p !b !b ; ( /)  @p pshw ( /)
: 'rp@ ( pri-pri) ( 0x4 ) push over bpshw pop ;
: 'else : bx@ ( a-w) ( 0x6 ) @p !b !b . ( /) @p x@ ( /)
: gett ( -w) @p !b @b ; ( /)  !p .. ( /)
: 'rfrom ( pri-pri) ( 0xa ) push bpshw
: popr ( p.i-pri) ( 0xb ) inc
: getr ( p.i-pri) ( 0xc ) dup bx@ pop ;
: 'exit ( pri-pri) ( 0xe ) drop push popr ;
: bpops ( -w) ( 0xf ) @p !b @b ; ( /)  !p pops ( /)
: bx! ( wa-) ( 0x11 ) @p !b !b . ( /) @p push @p . ( /)
     !b @p !b ; ( /)  pop x! ( /)
: pshr ( aw-a) ( 0x15 ) over bx!
: dec ( a-a) ( 0x16 ) -1 . + ;
: 'tor ( pri-pri) ( 0x18 ) push pshr bpops pop ;
: 'rp! ( pri-pri) ( 0x1b ) push pshr bpops getr ;
: 'if ( pri-pri) ( 0x1e ) bpops if drop inc ;
      then drop bx@ ;
: 'con ( pri-pri) ( 0x22 ) bx@
: 'var ( pri-pri) ( 0x23 ) dup bpshw 'exit ; ( 0x25 )

( block 1095 )
( notes-)
     ( the bitsy node keeps the return-stack)
( pointer, top-of-return-stack)  r ( and the interpreter pointer on its stack.)
     ( memory access gets done only through the stack node.)

( block 1096 )
( --- more bitsy)
( 0x25 ) ( must be at or before) org 0x28
      begin drop ;
: 'exe ( pri-pri) ( 0x29 ) bpops
: ?exe ( pri?-pri) ( 0x2a ) until
: xxt ( prix-pri) ( 0x2b ) dup 2* 2* -if
( code prix2) ( 0x2d ) 2* -if
( code1* prix3) ( 0x2e ) 2* -if
( code11* prix4) ( 0x2f ) 2* -if -d-- ;  then ---u ;
( code101 prix4) ( 0x32 )  then 2* -if r--- ;
( code100 prix5) ( 0x34 )  then drop push ;
( code0* prix3) ( 0x35 )  then ( slot2 port call!)
     @p !b push . ( /) @p @p c.s* ( /) !b pop !b ;
( list prix2) ( 0x38 )  then drop push push pshr
     pop pop 2* ;
: step ( pri-pri) ( 0x3b ) dup bx@ push inc pop xxt ;
: bitsy ( pri) ( 0x3e ) step bitsy ; ( 0x3e ) ( in block) ( 1100 )

( 0x40 ) exit ( started by ide)
: start 0xfff0 0x5 dup ( rp.r.ip) left ( stack) b!
     right ( terminal) a! bitsy ; ( 0x47 )

( block 1097 )
( notes-)
     ( the bit-threaded code technique confines execution to the)  bitsy ( loop and a small number of code subroutines. it uses one or more bits of the execution token to select the class-)
      00.10**.xxaa.aaaa.aaaa ( code.s-xt's)
     00.11**.xxaa.aaaa.aaaa ( code.b-xt's)
     00.0aaa.aaaa.aaaa.aaaa ( list-xt)
( -and process the token. code tokens are called while list tokens are interpreted by pushing the current) ip ( address onto the return stack and continuing at 2*xt.)
     ( the) ide ( can single-step the bitsy node by calling)  step ( instead of executing) bitsy.

( block 1098 )
( -- bitsy right bud dxxx) node 104 host  :: 'lu 0x165 lit ; target org 0x20 
: start @p b! ..  ' , r---  'lu a! ahead
: xqt ( 0x24 ) @b push ex
: cmd ( 0x25 ) then @p !b ( ...) xqt ; ( /)  drop !p .. ( /)


: message ( nw-w) ( 0x27 ) @p ! - . ( /) @p over @p ; ( /)
 over ! ! @ ( ...) drop @ or drop @ ;
: n@ ( n-w) ( 0x2c ) 0x3ffff message 0xffff and ;
: n! ( nw-) ( 0x30 ) message drop ;


: br!p ( i-) ( 0x32 ) @p !b !b ; ( /)  bpops .. ( /)
: brpops ( 0x34 ) @p br!p ; ( /)  !p .. ( /)
: pn!; ( n-) @p br!p ( /) !p ; ( /)  @b n! ;
: n@p; ( n-) ( 0x39 ) n@ @p !b !b ; ( /)  @p bpshw ; ( /)
: .n@ ( 0x3c ) brpops @b n@p; ;
: .n! ( 0x3e ) brpops @b pn!; ;


: .rx ( 0x40 ) 200 n@p; ; : .io@ ( 0x42 ) 100 n@p; ;
: .tx ( 0x44 ) 100 pn!; ; : .io! ( 0x46 ) 200 pn!; ;
( 0x48 ) ( must be at or before) ( 0x60 )

( block 1099 )


( block 1100 )


( block 1101 )


( block 1102 )
( -- bitsy up bud exxx) node 205 org 0x20 
: start @p b! ahead  ' , ---u 
: xqt ( 0x22 ) @b push ex
: cmd ( 0x23 ) then @p !b ( ...) xqt ; ( /)  drop !p .. ( /)

( 0x25 )

( block 1103 )


( block 1104 )


( block 1105 )


( block 1106 )
( -- bitsy down bud fxxx) node 5 org 0x20 
: start @p b! ahead  ' , -d-- 
: xqt ( 0x22 ) @b push ex
: cmd ( 0x23 ) then @p !b ( ...) xqt ; ( /)  drop !p .. ( /)


: 'next ( pri-pri) ( 0x25 ) @p !b @b ( /) push !p .. ( /)
if @p !b !b @p ( /) @p dec ( ') pop bx@ ; ( /)  !b ;
 then drop @p @p @p ( reversed!)
     ( /) pop inc ; ( ')  dup bx@ ( ') inc ( /) !b !b !b ;
: '@exe ( pri-pri) ( 0x31 ) @p @p @p . ( reversed!)
     ( /) ?exe ; ( ')  bx@ ( ') bpops ( /) !b !b !b ;
: 'r@ ( pri-pri) ( 0x36 ) @p !b ; ( /)  over bpshw ; ( /)
: 'lit ( pri-pri) ( 0x38 ) @p @p @p ( reversed!)
     ( /) inc ; ( ')  bpshw ( ') dup bx@ ( /) !b !b !b ; ( 0x3d )

( block 1107 )


( block 1108 )


( block 1109 )


( block 1110 )
( - flash to sram pipe) host  :: head :: pipe  1112  load ; target
( -------- --in-- --out- ----)
node 307 ' ---u ' -d-- pipe
node 407 ' -d-- ' ---u pipe
node 507 ' ---u ' -d-- pipe
node 607 ' r--- ' ---u pipe
node 606 ' --l- ' r--- pipe
node 605 ' -d-- ' --l- head

node 705 ( interface) 1116 load

( block 1111 )


( block 1112 )
( -- head/pipe nodes take two parameters!)
org 0x20 ( programmed with abandon)
: start ( init) leap warm ;
: init ( 0x22 ) then @p b! .. ( ,  out)  @p a! ; ( , in) 
: prime ( i-i) ( 0x26 ) dup !p ; ( install /* */)
: pump ( 0x27 ) ( /*) begin @ !b unext ; ( */)
: run ( in) ( 0x28 ) init
     @p !b over . ( /) @p prime ( /)
     !b @p !b dup ( /) @p run ( /)
     !b push pump ;

( used in the 'head' node)
: hf2s ( n) ( 0x2f ) @p prime ( /) begin @ !b unext ; ( /)
 over run ;
: hs2f ( n) ( 0x32 ) @p prime ( /) begin @b ! unext ; ( /)
 over run ; ( 0x35 )

( block 1113 )
( notes-)
( this is a bi-directional port pump! it assumes control comes from the 'head' and passes the it to the b-reg 'tail' of the pipe. a-reg the registers are set each time it is used, so the pipe may be crossed by other 'courteous' users. at this point only the count is passed--the tail has a fixed address to read to or write from.)

( block 1114 )
( -- tail / starter node takes three parameters!) org 0x0 ( programmed with abandon)
: tf2s ( 0x0 ) ( e4base) 0
     begin @ over x! 1 . + next warm ;
: ts2f ( 0x8 ) ( e4base) 0
     begin dup x@ ! 1 . + next warm ;
: xm! ( m-) ( 0xf ) dup dup or dup - mk! ; ( 0x11 )

org 0x20 
: start ( 0x20 ) @p @p b! @p ( ,  mask) ( , out) ( , in)
      a! xm! warm ;
: prime ( i-i) ( 0x26 ) ; ( dummy)  ;
: run ( in) ( 0x28 ) push @p or ( /*) begin @b ! unext ; ( */)  if tf2s ;  then ts2f ; ( 0x2d )

( block 1115 )
( notes-)
      xm!  mask ( sets which neighbor nodes get access to memory.) ( 0x8000 ) ( is 106,) ( 0x800 ) ( is 108,) ( 0x200 ) ( is 207,) ( 0x8a00 ) ( is all three.) use carefully!

( block 1116 )
( -- eforth flash interface) org 0x0 
: 2cmd ( dw-d) select ( +2r) : +cmd ( dw-d) 8obits ( +4r)
: cmd ( db-d) select : !8 ( db-d) 8obits drop ;
: reading ( dh-d) ( 0x5 ) io b! over . ( read) 0xc00 cmd ( +5r)
: !24h ( dhd-d) ( 0x9 ) drop 8obits
: !16 ( dw-d) ( 0xa ) 8obits !8 ;
: @16 ( d-dw) ( 0xc ) 15 dup push dup or ( 'ibits)  0xdb  end
: set ( ndo-n) ( 0xf ) down a! ! drop dup ! ;
: f2s ( dndh-d) ( 0x12 ) reading ( +6r) @p set ( /) @p hf2s ( /)
: readn ( dn-d) ( 0x15 ) for @16 ( +4r) ! next ;
: start ( dx-dx) ( 0x19 ) drop ( n-1) over 512 f2s ( +7r)
: restart ( d-dx) ( 0x1d ) ( resume) reading dup spi-exec ;
: deselect ( dx-dx) ( 0x20 ) io b! -++ half warm ;
( 0x25 ) exit 
: +wr ( d-d wren+wrsr) 0x1804 2cmd ( 0+ebsy) 0x1c0 +cmd ;
: er32k ( dh-dd) ( 0x29 ) over +wr ( +6r)
     ( wren+ers32) 0x1948 2cmd !24h dup select ;
: writing ( dh-d) ( 0x2e ) over +wr ( +6r)
     ( wren+aaip) 0x1ab4 2cmd !24h ;
: s2f ( dndh-d) ( 0x32 ) writing ( +7r) @p set ( /) @p hs2f ( /)
: writn ( dn-d) ( 0x35 ) push ahead begin  swap
     ( aaip)  0x2b400 cmd then @ !16 ( +5r)
     ( wait) dup select ( 0x3a ) begin drop @b -until
( 0x3b ) drop next ( wrdi+dbsy) 0x1200 2cmd ; ( 0x3e )

( block 1117 )
( notes-)
     ( assumes that during booting the delay value is on the top of the data stack and is preserved during all flash accesses.)
     ( also assumes b contains io.)

( block 1118 )


( block 1119 )


( block 1120 )
( - siobus16 wire nodes) host  :: wire  1122  load ; target
( ------- plug -dest- --in-- --out- ----)
node 204 999 ' r--- ' -d-- ' ---u wire
node 304 999 ' r--- ' ---u ' -d-- wire
node 404 999 ' r--- ' -d-- ' ---u wire
node 504 999 ' r--- ' ---u ' -d-- wire
node 604 704 ' -d-- ' --l- ' ---u wire ( *)
node 603 999 ' -d-- ' r--- ' --l- wire
node 602 999 ' -d-- ' --l- ' r--- wire
node 601 600 ' r--- ' ---u ' --l- wire ( *)
node 501 500 ' r--- ' -d-- ' ---u wire ( *)
node 401 999 ' r--- ' ---u ' -d-- wire
node 301 999 ' r--- ' -d-- ' ---u wire
node 201 200 ' r--- ' ---u ' -d-- wire ( *)
node 101 100 ' r--- ' --l- ' ---u wire ( *)
node 102 999 ' r--- ' r--- ' --l- wire
node 103 999 ' r--- ' --l- ' r--- wire

( block 1121 )
( notes-)
iobus ( nodes have) ( 4 ) ( values defined when booted-)  in-port ( and) destination ( are kept on the stack,) dest-port ( is put in a, and) out-port ( into b. an)  iobus ( node with a)  destination ( of)  999 ( only)
( passes messages from its)  in-port ( to) out-port. ( its) dest-port ( is unused. otherwise they are)
( the node-number and port of a node with pins.)
 iobus ( messages consist of three words;)
     ( /)  @p over @p ; ( /) [compile] destination ( /) [compile] data ( /)

[compile] destination ( is the node-number of a node with code to handle) [compile] data

[compile] data ( is) 0 ( for reads and the 18-bit inverse of a) 16-bit value ( for writes.)

( eforth originates all messages. they travel around the loop until their) [compile] destination ( matches an) iobus ( node's or they return to eforth. at a matching node) [compile] data ( is written and the)
( reply read and returned to eforth.)

( block 1122 )
( -- generic siobus wire) org 0x30


: start ( takes four parameters!)
     @p b! @p .. ( ,  out-port) ( , in-port)
      @p a! @p .. ( ,  dest-port) ( , dest-node) 
: wait ( id) ( 0x36 ) over push ex ( ... @p over @p ;)
: test ( idndw) ( 0x37 ) push over or if
: pass ( idnx.w) ( 0x39 )
     @p !b drop .. ( /) @p over @p ; ( /)
      !b pop !b wait ;
: mine ( idn0.w) ( 0x3d ) then pop ! @ push pass ; ( 0x3f )

( block 1123 )


( block 1124 )
( -- tx plug node) host  :: tx0 ( dumb) 0x25555 ( maxim) ( 0x35555 ) lit ; :: tx1 ( dumb) 0x35555 ( maxim) ( 0x25555 ) lit ; :: 'ru  0x1c5  lit ; :: 115k  2350  lit ;
target org 0x30 
: !bit ( im-i) ( 0x30 ) over and
     if tx0 !b drop ;  then tx1 !b drop ;
: putchar ( di-dx) ( 0x35 ) 0xff or 2* ..
( 1-start, 8-data, 1-stop bit) 9 for ( 0x39 )
     1 !bit 2/ over for . unext next ; ( 0x3e )

( 0x3e ) org 0x20 ( programmed with abandon)
: start io b! ( space) tx0 !b 'ru a! ( bit delay) 115k
: wait ( *d) ( 0x26 ) @ ( ...) if
( dly *d)  ' wait  -until
( n!) ( 0x28 ) ( *di) - putchar ! wait ;
( n@) ( 0x2a ) ( *d0)  then drop dup ! wait ; ( 0x2c )

( block 1125 )
( notes-)
     tx ( is inverted for compatibility with the boot node conventions, i.e. mark hi, space lo, data1 lo, data0 hi, start hi, stop lo.)


: putchar ( takes a clean inverted octet and)
( transmits it low bit first via p17.)


: wait ( suspends while waiting for an inverted)
( character or a new delay value. the message)
( protocol guarentees that there won't be a port conflict.)

( block 1126 )
( -- rx plug node) org 0x0 
: @bit ( cm-c) @b - over - and push and pop or ;
: getchar ( dx-di) ( 0x3 ) over 2/ for . unext ( 1/2 bit) 8 for ( 1-start, 8-data, 1-stop bits)
     0x1ffff @bit 2/ over for . unext
next 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 0xff and - ;


: baud ( n-ddd) ( 0x11 ) if dup dup ;  then - push
( 0x814 ) begin @b . -until ( at start-bit of space) ( 0x15 ) begin @b - -until ( at 1-bit)
( 0x16 ) begin @b . zif then . -until ( at 0-bits)
( 0x18 ) begin @b - zif then . -until ( stop-bit)
( 0x1a ) pop - ( n) dup 2/ . + ( 1.5n) dup dup ; ( 0x1d )

( block 1127 )
( notes-)
     rx ( is inverted for compatibility with the boot node conventions, i.e. mark hi, space lo, data1 lo, data0 hi, start hi, stop lo. received characters may have one stop bit.)


: getchar ( called after seeing leading edge of start bit. returns clean inverted character. must be called before start bit begins!)


: baud ( space is 1...1'0010.0000'0)
     ( stop bits ------' .hex..20. '--- start)


: idle

( block 1128 )
( --- more rx)

( 0x1d ) org 0x20 ( programmed with 2-stack abandon)
: start ( est 115k delay) 2350
     ( tri-state pin17) io b! 0x5555 !b
     ( 2-char empty buffer) 0 dup push
: pwait ( *dl.p*) ( 0x27 ) push
: wait ( *d.lp*) ( 0x28 ) ( io-mask) 0x28000 dup
     begin drop @b over and until -if
( pin *dm-.lp*) drop getchar pwait ;
( msg *dm+.lp*)  then drop drop right a! @ -if
( n! *d-.lp*) ( 0x32 ) - baud ! up a! ! wait ;
( n@ *d0.lp*) ( 0x36 )  then pop if
( *d0l.p*) pop if ( 2 ) ( chars in buffer)
     ( *d0lp.*) ! over push push drop wait ;
     ( *d0l0.*)  then push ( 0/1 char in buffer)
( *d0l.p*) then ! pwait ; ( 0x3d )

( block 1129 )


( block 1130 )
( -- 1-pin plug node) org 0x20 
: start right a! io b! ( p17 hi-imp) 0x5555 dup !b
: cmd ( m) ( 0x26 ) @ ( ...) -if
( n!) ( 0x27 ) ( mw) 1 or 7 for 2* 2* unext
     over over or !b ! cmd ;
( n@) ( 0x2f ) ( m0)  then @b -if drop - ! cmd ;
      then drop ! cmd ; ( 0x34 )

( block 1131 )
( notes-)
( currently plugged into nodes) ( 500 ) ( and) ( 600 ) ( .)
0  n! ( drives the pin lo.)
 1  n! ( drives the pin hi.)
 2  n! ( tri-states the pin.)
 3  n! ( attaches a weak pull-down to the pin.)
n@ ( samples the pin, returning)
      -1 ( when hi,) 0 ( when lo.)

( high level eforth code toggles at) ( 250 ) ( khz!)

( block 1132 )
( -- dummy flash controller plug) org 0x0 
: !x @p drop !p ; : x 0 ;
: xfers dup !x ; org 0x20 
: start down a!
: cmd ( 0x22 ) @ ( ...) -if
( n!) ( 0x23 ) ( w) - xfers ! cmd ;
( n@) ( 0x25 ) ( 0 )  then drop x ! cmd ;

( block 1133 )


( block 1134 )


( block 1135 )


( block 1136 )


( block 1137 )


( block 1138 )


( block 1139 )


( block 1140 )
( eforth ide) host load :: hoot ( pn) dup :: book ( pnb) push hook 0 64 pop boot pause ; :: 'lu  0x165  ; :: 'cold  0x5  ; ( eforth cold-start) :: e4base ( -a)  0x0 ( 0x8000 )  ; ( eforth location in sram) :: 'bitsy  0x3e  ; :: 'rp  0xfff0  ; :: 'sp  0xffe0  ; ( tools) 1142 4 loads ( build chip) 1160 load talk e4

( block 1141 )
( customize ide for eforth development.)


: hoot ( combines)  hook ( and) boot 
: e4 ( loads f18 virtual machine code, puts)
( threaded-code image in sram, and starts it.)
 note--initial 'space' character needed from
the terminal to determine the baud rate.

[compile] ***no [compile] canonical [compile] opcodes***
use the  'remote'  ones for both
compiled and interpreted scripts.

( block 1142 )
( - ide build paths)


: route ( p) pop b-a swap
: !path ( ap) dup -hook 'pths + ! panel pause ;


: srampath  1  align route  , 708 , 608
     , 508 , 408 , 308 , 208 , 108 , 107
     , 7 , 8 , 9 , -1 ( srampath)


: e4path  0  align route  , 708 , 707 ( 706 ) ( ,)
     ( 705 ) ( ,) ( 605 ) ( ,) ( 606 ) ( ,) , 607 , 507 , 407
     , 307 , 207 , 206 , 205 , 105 , 106
     , 6 , 5 , 4 , 104 , 103 , 102 , 101
     , 100 , 200 , 201 , 301 , 401 , 501
     , 500 , 600 , 601 , 602 , 603 , 703
     , 704 , 604 , 504 , 404 , 304 , 204
     , -1 ( e4path)


: flpath  0  align route  , 708 , 707 , 706
     , 705 , -1

( block 1143 )


( block 1144 )
( - read 16-bit eforth.bin file)
:var ft : e4max ( -h)  16384  ; :var e4siz [0x133e]
: a-b ( a-b) 2* 2* ; : b-a ( b-a)  3  + 2/ 2/ ;
: create ( -a) pop b-a ;
: string pop ; : h-b 2* ; : b-h  1  + 2/ ;
: fbuf ( -b)  nnc 2 * 0x8000 + block a-b  ;


: +e4  0 fnam b-a  r/w fopen if  ft  ! ;
 then drop abort ;
: -e4  ft  @  0  + if fclose 0 then  ft  ! ;
: !e4 +e4 if fbuf  e4max  h-b  ft  @ frd
     b-h  e4siz  ! -e4 then ;

named ( ef/eforth.bin) !e4 
: n-1  e4siz @ -1 +  ;



( block 1145 )


( block 1146 )
( - ide access sram16 from nodes) ( 108 ) ( and) ( 207 )
: n108 srampath 1 108 hook panel ?ram ;
: n207 e4path 0 207 hook panel ?ram ;
: get ( -w) upd  stak  @ rdrop ;
: put2 ( nn-) swap lit' lit' ;
: put4 ( nnnn-) push push put2 pop pop put2 ;


: xm! ( m-) lit' ( xm!)  0x37  call ;
: x! ( wa-) put2 ( x!)  0x39  call ;
: x@ ( a-w) lit' ( x@)  0x3c  call get ;
: ex! ( wap-) push put2 pop lit' ( ex!)  0x3a  call ;
: ex@ ( ap-w) put2 ( ex@)  0x3d  call get ;
: cx? ( wapw-f) put4 ( cx?)  0x3e  call get ;


: dmp ( ap-...) 7 for push dup i ex@
     swap  1  + pop -next drop drop ;
: fil ( wapn-) for push over over i ex!
      1  u+  1  + pop -next drop drop drop ;


: !e4th  fbuf  e4base  n-1  for
     over 2@ swab over x!  2  u+  1  +
-next drop drop ;

( block 1147 )
( notes)
     ( assumes the ide is hooked to one of the sram user nodes.)
    

( block 1148 )
( - ide access term16 from) ( 104 ) ( , flash from) ( 706 )
: n104 e4path 0 104 hook panel ?ram ;
: io! ( w) 200
: n! ( wn) lit' lit' ( n!) 0x30 call upd ;
: tx ( w) 100 n! ;
: io@ ( -w) 100
: n@ ( n-w) lit' ( n@) 0x2c call get ;
: rx ( -w) 200 n@ ;
: key ( -w) begin rx if 0xffff or ;  then drop end
: emit ( w-) 0xffff or tx ; exit


: n706 flpath 0 706 hoot panel ?ram ;
: ffo ( foc)  0x20  call ; : blk ( n-)  0x200  * lit ;
: len ( len)  0x23  call ; : f2s ( dnl)  0x32  call ;
: des ( des)  0x34  call ; : don ( don)  0x3c  call ;
: e32 ( e32)  0x36  call ; : s2f ( upl)  0x38  call ;
: burn ( k) foc blk n108 x@ -1 +
     0x0 path lit s2f don ;
: try ( k) foc blk len f2s don ;

( block 1149 )


( block 1150 )


( block 1151 )


( block 1152 )


( block 1153 )


( block 1154 )


( block 1155 )


( block 1156 )


( block 1157 )


( block 1158 )


( block 1159 )


( block 1160 )
( eforth chip builder)


: hooked panel pause 2 708 hook pause 2 -hook ;
: clean unfoc 2 -hook 1 -hook 0 -hook ;
: e4sram  1162  load ;
: e4sio  1164  load ;
: e4vm  1166  load ;
: e4boot e4sram e4sio e4vm clean ;
: e4bin e4sram !e4th ;
: e4 e4bin e4sio e4vm clean ;

( block 1161 )


( block 1162 )
( - build sram16 using) srampath

( address-bus) 1 9 hook 0 64 1617 boot 0x20 call ( control-pins) 1 8 hook 0 64 1616 boot 0x20 call ( data-bus) 1 7 hook 0 64 1615 boot 0x20 call ( interface) 1 107 hook 0 64 1614 boot down lit rb! ( 108+207 mask) 0x8a00 lit ( re) 0x17 call
( user) 1 108 hook 0 64 1817 boot

( block 1163 )


( block 1164 )
( - build siobus wires and plugs using) e4path 
: wire ( n) dup
: wbin ( bn) 0 swap hook push 0x30 16 pop boot pause 0x30 call ;
: plug ( n) dup
: pbin ( bn) 0 swap hook push 0x0 64 pop boot pause 0x20 call ; 204 wire 304 wire 404 wire 504 wire 604 wire ( flash) 704 plug 603 wire 602 wire 601 wire ( 1-pin) 1813 600 pbin ( plug 1-pin) 500 plug 501 wire 401 wire 301 wire 201 wire ( rx) 200 plug ( tx) 100 plug 101 wire 102 wire 103 wire exit ( for eforth) ( testing serial bus from bitsy right bud) 104 plug 'lu lit ra!

( block 1165 )


( block 1166 )
( - build e4vm16 nodes using) e4path 
: pipe ( n) dup node push 0x20 32 pop boot
     0x20 call ;

( bitsy right bud) foc 104 plug
( bitsy down bud) 5 plug
( stack down bud) 6 plug

( stack) 0 106 hoot right lit rb!
     'sp lit ( s) 0 lit ( t) 0 lit
     left call

( bitsy) 0 105 hoot left lit rb!
     'rp lit ( r) 0 lit ( ip) 'cold lit
     'bitsy call unfoc

( bitsy up bud) 205 plug
( stack up bud) 206 plug

( starter/tail node) 207 plug exit

( pipeline) 307 pipe 407 pipe 507 pipe
     607 pipe 606 pipe ( head) 605 pipe

( block 1167 )


( block 1168 )


( block 1169 )


( block 1170 )
( - sram loader nodes) ( wires) node 605 org 0 
: wire ( b! a!) @ dup !b for @ !b unext warm ; ( 0x4 ) 1815 bin ( sram loader node) ( 208 ) node 208 org 0  ahead
: !sram ( 0x1 ) ( an) @p !b !b .. ( /) @p @p .. ( /) !b @p !b ; ( /)  x! ( /)
: start ( 0x5 ) then down a! up b! 0 dup @ dup push !sram begin 1 . + dup @ !sram next warm ; ( 0x11 ) 1816 bin

( block 1171 )
( minimal version of plumbing for sram boot from flash. wires are compiled only once and are) ( initialized with source port in a and dest) ( port in b.) ( message consists of word count n-1 followed by n words to be passed along.)

( block 1172 )
( - spi flash) ( 8 ) ( bits) node 705 org 0 host  :: resume nnc 2 * 0x8000 + block @ 0xfffff and
     18 8 */ 4 * lit ; target 
: wait ( dw-dw) ( 0x0 ) select dup begin drop @b -until drop select ;
: 2cmd ( dw-d) ( 0x4 ) select 8obits
: cmd ( dw-d) select
: !8 ( dw-d) 8obits drop ;
: set ( -d) ( 0x9 ) io b! ( fast) 5 ;
: fet ( ah al-d) ( 0xc ) push push set ( read) 0xc00 cmd pop !8 pop 8obits !8 ;
: 16ibits ( d-db) ( 0x12 ) dup 15 for
rbit ibit - next 0xffff and ;
: start ( 0x19 ) down a! 0 0x20000 fet
16ibits dup ! for 16ibits ! next
     resume fet 18ibits 0x1e000 . + - -if
: done io b! 20 20 -++ half warm ;  then
5 resume push spicmd spi-boot ;
( 0x34 ) 1814 bin

( block 1173 )

: start ( 1st word read is count in words)

( block 1174 )
( load eforth kernel)
: /nwire ( in out) /b /a 0 4  1815  /part 0 /p ; 705 +node 1814 /ram 0x19 /p 605 +node down left /nwire 606 +node left right /nwire 607 +node right left /nwire 608 +node left up /nwire 508 +node up down /nwire 408 +node down up /nwire 308 +node up down /nwire 208 +node 1816 /ram 0 /p 108 +node 1817 /ram left /b

( block 1175 )


( block 1176 )


( block 1177 )


( block 1178 )


( block 1179 )


( block 1180 )
( build eforth bootstream) ( speedup) 0x0 0 3 1608 /root ( default) entire course
( sram driver) sram 2 + load ( flash to sram) 1174 load frame adjust ( resume point) fresh ( residual) sram 4 + load s705 course ( siobus and virtual machine) 1182 load ( flash-sram pipe) ( 1184 ) ( load) ( retain asynch boot) 708 +node 0xaa /p frame

( block 1181 )


( block 1182 )
( - build siobus and virtual machine bootstream)
: wire ( n) dup +node push 0x30 16 pop /part 0x30 /p ;
: plug ( n) dup
: pbin ( bn) +node /ram 0x20 /p ;

103 wire 102 wire 101 wire
     ( tx) 100 plug ( rx) 200 plug
201 wire 301 wire 401 wire 501 wire
     ( 1-pin) 500 plug ( 1-pin) 1813 600 pbin ( plug)
601 wire 602 wire 603 wire
     ( flash) 704 plug
604 wire 504 wire 404 wire 304 wire
204 wire

( bitsy) 105 +node 105 /ram
     ( rp) 0xfff0 ( r) 0 ( ip 'cold) 0x5 3 /stack
     left /b right /a ( 'bitsy) 0x3e /p
     ( buds) 205 plug 104 plug 5 plug

( stack) 106 +node 106 /ram
     ( sp) 0xffe0 ( s) 0 ( t) 0 3 /stack
     right /b left /p
     ( buds) 206 plug 6 plug

( starter/tail) 207 plug

( block 1183 )


( block 1184 )
( - build flash-sram pipe bootstream)
: pipe ( n) dup node push 0x20 32 pop boot 0x20 /p ;

( head) 605 pipe
( pipeline) 606 pipe 607 pipe
     507 pipe 407 pipe 307 pipe


( block 1185 )


( block 1186 )


( block 1187 )


( block 1188 )


( block 1189 )


( block 1190 )
( burn 16-bit eforth.bin file into flash)
empty compile streamer load
1190 loaded ! nores
( read eforth.bin) 1144 load
fbuf source ! n-1 len ! ( display image length) len @ 8 18 */ leng !

0x8000 stream nip ers
stream 0x8000 swap burn 1194 load

exit ( source cf-byte-addr) fbuf
( dest flash-byte-addr) 0x8000
( count 16-bit-words) n-1 burn

( block 1191 )


( block 1192 )


( block 1193 )


( block 1194 )
( burn 18-bit eforth bootstream into flash)
( 1st pass) empty compile streamer load
( framer) framer load ( the stream) 1180 load

( 2nd pass) empty compile streamer load
( framer) framer load ( the stream) 1180 load

1194 loaded ! ( display stream length) strlen leng ! ( write stream into flash)
     ( source cf-word-addr) stream
     ( dest flash-byte-addr) 0
     ( count 18-bit-words) swap ( flasher) 18burn

( block 1195 )


( block 1196 )


( block 1197 )


( block 1198 )
( eforth index and listing)

index load named ( eforth.txt) 1080 1200 run

html load named ( eforth.html) 1080 1200 run

exit

( block 1199 )


( block 1200 )


( block 1201 )


( block 1202 )


( block 1203 )


( block 1204 )


( block 1205 )


( block 1206 )


( block 1207 )


( block 1208 )


( block 1209 )


( block 1210 )


( block 1211 )


( block 1212 )


( block 1213 )


( block 1214 )


( block 1215 )


( block 1216 )


( block 1217 )


( block 1218 )


( block 1219 )


( block 1220 )


( block 1221 )


( block 1222 )


( block 1223 )


( block 1224 )


( block 1225 )


( block 1226 )


( block 1227 )


( block 1228 )


( block 1229 )


( block 1230 )
( sync boot testbed) :var addr [0x483e001] :var len [0x43] :var word [0xdea40000] :var bit [0x1] :var dly [0x32]
: clock  bit  @ ( -)  1  and ?v p17v ! ;
: data  word  @  0x40000  and ?v p1v ! ;
: 'stream ( -a)  nnc 2 * 0x8000 + block 2 +  ;
: stream ( -an)  'stream  dup  -2  + @ ;
: /sync softbed assign ( len)  0 +  nop  len  ! ( addr)  0 +  nop  addr  ! 50  dly  ! 'bed assign  vdd @  p17v !  0  p1v !  dly  @  -1  + if  dly  ! ;  then drop
: /word  addr  @ dup  1  +  addr  ! @ p-n  word  ! 18  bit  !
: /bit  word  @ 2*  word  ! 40  dly  ! 'bed assign clock data  dly  @  -1  + if  dly  ! ;  then drop  bit  @  -1  + if  bit  ! /bit ;  then drop  len  @  -1  + if  len  ! /word ;  then drop 'bed assign  0  p17v !  0  p1v ! ; 300 !node stream /sync

( block 1231 )
( sync boot)
: sync ac ( installs testbed) a ( is buffer base address of boot stream) c ( is word count of boot stream) ( testbed holds clock high for) ( 25 ) ( ticks before) ( clocking out stream data)

( block 1232 )


( block 1233 )


( block 1234 )


( block 1235 )


( block 1236 )
( configuration tables) :var com
: tabl pop 2/ 2/  com  @ + ;
: jsr 0xe8 dst ; ( call has been clobbered already)
: table ( nn) [compile] align jsr tabl for dup , next drop ;
: a-boot  -1 144 table
: c-boot  -1 144 table 
: b-boot  -1 144 table 
: a-reg  -1 144 table
: b-reg  io 144 table
: /a ( a) a-reg ! ;
: /b ( a) b-reg ! ;
: /p ( a)  com  @ !inode entry ! ;
: +node ( n) nn-n  com  ! ;
: /part ( acb) b-boot ! c-boot ! a-boot ! ;
: /ram ( b) b-boot ! 64 c-boot ! 0 a-boot ! ;
: rammer ( -acb) a-boot @ c-boot @ b-boot @ ;
: aaray pop 2/ 2/  com  @  11  * + ;
: array ( n) [compile] align jsr aaray  11  * for 0 , next ;
: 'stack  144 array :var stkp [0xa]
: @s+ 'stack  stkp  @ + @ 1  stkp  +! ;
: !s- ( n) 'stack  stkp  @ + ! -1  stkp  +! ;
: /stack ( stuff count) 10  stkp  ! dup !s- for !s- next ;

( block 1237 )
( - configuration tables)
: tabl
: jsr ( call from block) ( 88 ) ( has been clobbered) ( so replace it with jsr instead)
: table ( build and initialize a table) ( tables hold configuration information)
: /a a ( specifies)  a ( value for current node)
: /b a ( specifies)  b ( value for current node)
: /p a ( specifies entry point for current node) ( using preexisting) entry ( mechanism)
: +node n ( makes n the current node)
: /part acb ( specifies)  address count ( and) bin ( for code to be loaded into current node later)
: /ram b ( specifies just the bin, load all) ( 64 )
: rammer -acb ( returns)  address count ( and) bin ( from table)
: /stack stuff count ( specifies)  count ( items to be placed on the stack at load time)

( block 1238 )
( - initial values)
: ?load c-boot @  0  + drop -if ;  then rammer swap push nn-n inode over + swap  comb  @ + pop move ;
: -com  comb  @  0x8000 block negate  + 0x200 /  com  ! ;
: deliver  'boot  assign -com ?load a-reg @ -  0  + drop -if a-reg @ lit ra! then b-reg @ -  0  + drop -if b-reg @ lit rb! then 'stack  10  + @ dup and if dup dup negate  10  +  stkp  ! for @s+ lit next then drop ; deliver

( block 1239 )


( block 1240 )
( interactive)
: node ( n) nn-n dup !inode  nod  ! ;
: other ( n) nn-n  nod2  ! ;
: exec ( n) pc @ +r ir ! 1 slot ! 0 cnt ! ;
: fin step listen -track ;
: !b ( .!b;;)  0x2db55  exec !b, fin ;
: !a ( .!a;;)  0x2da55  exec !a, fin ;
: !+ ( .!+;;)  0x2d855  exec !+, fin ;
: @b ( .@b;;)  0x2df55  exec @b, fin ;
: @a ( .@a;;)  0x2de55  exec @a, fin ;
: @+ ( .@+;;)  0x2dc55  exec @+, fin ;
: r@ ( a-n) lit ra! @a -t ;
: r! ( na) lit ra! lit !a ;
: call pc @ lit rpush lit rpush ret fin h ;
: boot ( acn) swap push nn-n inode over + swap  nod  @ inode + pop move ;
: break ( san)  comb  @ push !node 2* 2* or bp ! pop  comb  ! ;
: -break ( n)  comb  @ swap !node  -1  bp !  comb  ! ;

( block 1241 )
( memory operators and constants)

( block 1242 )
( build boot stream for softsim testbeds) ( exit) streamer load framer load ( smtm frame for spi) ( 2 ) ( 0 ) ( 64 ) ( 0 ) ( /root) ( smtm frame for sync) 1 0 64 0 /root stream drop drop

( block 1243 )
( makes a boot stream from the smtm example) ( starting at address) ( 2 ) ( in order to avoid) ( running into the edge) stream ( leaves its address and length on stack)

( block 1244 )
( spi testbed) :var clk [0x1] :var btcnt [0x21]
:var cmd [0xffffffff] 0 cmd ! :var spbit [0x5145c4c8]
: 'stream ( -a)  nnc 2 * 0x8000 + block 2 +  ;
: setmem ( b) 0xffffff and 8 * ( byte offset in bits)
 'stream  18 * +  spbit  ! ; 0 setmem 
: 'cmd ( -a)  cmd  dup @ p5v @ low? -if
     2* over ! ;  then - 2* - over ! ;
: ?bit  btcnt  @ -1 + 0 max dup  btcnt  !
     dup and drop if 'cmd @ setmem
     pop drop ;  then ;
: bitn ( n-nn) dup @ swap over 1 + swap !
     18 /mod @ p-n swap 1 + ;
: bit17 0  spbit  bitn for 2* next
     0x40000 and drop if drop  vdd @  then
     p17v ! ;

( block 1245 )
( spi testbed)
boot stream is assembled starting at nnc 
: setmem ( adds an offset and converts to bits)
: ?bit ( reads command or allows data write)


: spi ( assigns initial behavior to softbed)
 first waits for select high ,
then waits for select low , then watches
spi clock and accumulates data until select
goes high , at which point it starts over

( block 1246 )
( spi testbed)
: threshold ( -v)  vdd @ 2 / negate  ;
: clk? ( -n) p1v @ threshold + - 0 max 1 min ;
: hi? ( a) @ threshold + 0 max dup and drop ;
: lo? ( a) @ threshold + - 0 max dup and drop ;
: /spi softbed assign
: desel -1  cmd  ! 33  btcnt  !
'bed assign p3v lo? if ;  then
'bed assign clk?  clk  ! p3v lo? if
'bed assign p3v hi? if desel ;  then
      clk  @ clk? dup  clk  ! or
     drop if  clk  @ dup and drop
     if ;  then ?bit bit17 then then ; 705 !node /spi

( block 1247 )
( spi testbed)
boot stream is assembled starting at nnc 
: setmem ( adds an offset and converts to bits)
: ?bit ( reads command or allows data write)


: /spi ( assigns initial behavior to softbed)
 first waits for select high ,
then waits for select low , then watches spi clock and accumulates data until select
goes high , at which point it starts over

( block 1248 )
( show directions) :var arrow [0x5c] 92 arrow ! 
: magenta 0xff00ff color ;
: .dir ( o)  xy  @ dup push +  xy  !
      arrow  @ emit pop  xy  ! ;
: ?dir ( n-n) dup 1 and drop if pop drop then ;
: .ndir 2/ ?dir 0x160000 .dir ;
: .sdir 2/ ?dir 0x1600a5 .dir ;
: .wdir 2/ ?dir 0xfff5004b .dir ;
: .edir 2/ ?dir 0x37004b .dir ;
: .eswn ( a) magenta .ndir .wdir
     red .sdir .edir drop ;
: .wsen ( a) magenta .ndir .edir
     red .sdir .wdir drop ;
: .enws ( a) magenta .sdir .wdir
     red .ndir .edir drop ;
: .wnes ( a) magenta .sdir .edir
     red .ndir .wdir drop ;
: which 92 dbus @  wrq  and drop
     if -2 + then  arrow  ! ;
: .drs abus @ dup - 0x100 and drop
     if drop ;  then which 0xa0 or 8 /
      comb  @  0x8000 block negate  +  0x200  /
     dup 9 / 2 and swap 1 and or
     jump .enws .wnes .eswn .wsen

( block 1249 )

: which dbus @ dup wrq and drop
     if drop 90  arrow  ! ;  then
     rrq and drop if 92  arrow  ! then ;

( block 1250 )
( prelude) :var comb [0x4808000]
: xqt? ( a) @ ( b) dup and if push ;  then drop ;
: nodes ( i-n) 2* blks ;
: inode ( i-a) nodes  0x8000 block  + ;
: !node ( n) nn-n
: !inode ( i) inode  comb  ! ;
: my ( o-a)  comb  @ + ; ( node variables)
: memory ( o-a) 0xbf and my ;
: rombit ( -m) 0x80 ; ( 40-7c defined later)
: brk  0x7c  my ;
: bp  0x7d  my ;
: entry  0x7e  my ;
: pins  0x7f  my ;
: nnxmod ( -n)  100  ;
: io  0x15d  ;
: data  0x141  ;
: ldata  0x171  ;
: right  0x1d5  ;
: down  0x115  ;
: left  0x175  ;
: up  0x145  ;
: enter ( a nn) !node entry ! ;
: /enter  nns -1 +  for i dup !inode resets @ rstadr entry ! -next ; /enter

( block 1251 )
( prelude)
: comb ( base address of node vars for this node)
: xqt? ( execute code starting at adr in preceding variable)

( block 1252 )
( softsim node variables)
( cpu -pattern- buses and registers)
: dbus 0x40 my ;
: uport 0x41 my ; : udest 0x4e my ;
: lport 0x42 my ; : ldest 0x4d my ;
: dport 0x44 my ; : ddest 0x4b my ;
: rport 0x48 my ; : rdest 0x47 my ;
( pins and testbed)
: p17v 0x50 my ; : p5v 0x51 my ;
: p3v 0x52 my ; : p1v 0x53 my ;
: edge 0x54 my ; : ios 0x55 my ;
: softbed 0x56 my ;
( cpu -number- buses and registers)
: abus 0x57 my ; : ioc 0x58 my ;
: ar 0x59 my ; : b 0x5a my ;
: t 0x5b my ; : pc 0x5c my ; : ir 0x5d my ;
: s 0x5e my ; : ss ( i) 7 and 0x60 my + ;
: r 0x5f my ; : rs ( i) 7 and 0x68 my + ;

( block 1253 )
( softsim node variables)

( some node variables make more sense as hardware patterns, others as numbers)

( block 1254 )
( softsim node variables and shared code)
: 'tik 0x43 my ;
: 'tok 0x45 my ;
: sp 0x46 my ;
: slot 0x49 my ;
: cnt 0x4a my ;
: pre 0x4c my ;
: cy 0x4f my ;
: 'opcode 0x70 my ;
: rp 0x71 my ;
: mem 0x72 my ;
: pwv 0x73 my ;
: vis 0x74 my ;
: ip 0x75 my ;
: 'group 0x76 my ;
: rqs 0x77 my ;
: iom 0x78 my ;
: 'bed 0x79 my ; ( 7a-7b available)
: rrq 0x80000 ;
: wrq 0x40000 ;
: brq 0xc0000 ; :var 'trk [0x102fb8a8]
: -track  'trk  assign nop ;
: track  'trk  assign ip @ 2/ 2/ 0xb8 and mem ! ; macro
: 2/s ?lit 0xf8c1 2, 1, ;
: 2*s ?lit 0xe0c1 2, 1, ; forth 
: @10 @
: 10bit 0x3ff and ;
: p-n
: n-p 0x15555 or ;
: 18bit 0x3ffff and ;
: 8bit 0xff and pc @ 0x200 and or ;
: !18 ( na) push 18bit i @ 0xfffc0000 and or pop ! ;
: !10 ( na) push 10bit i @ 0x3fc00 and or pop ! ; :var vdd [0x708] 1800 vdd ! 
: ?v ( w-v) if drop  vdd @  then ;

( block 1255 )
( softsim node variables and shared code)
( variables)
: 'tik 'tok ( defered execution)
: sp slot ( stack and slot pointers)
: cnt pre ( timers)
: cy 'op ( carry)
: rp mem ( return stack pointer , mem dump pointer)
: pwv vis
: ip bp' ( instruction pointer ,)
     ( alternate breakpoint)
: rqs ( requests from all ports accumulated here)
: rrq wrq brq ( read , write , both requests)


: 2/s ( right shift macro)
: 2*s ( left shift macro)
: @10 10bit ( mask and store 10 bit address)
: p-n n-p ( convert pattern to/from numbers)
: 18bit 8bit ( mask address bits)
: !18 ( store masked off 18 bit address)
: !10 ( store masked off 10 bit address) vdd ( is 1.8v)
: ?v  must follow an operation that sets  w  to zero/non-zero

( block 1256 )
( softsim all tiks)
: out ( apm) and if drop  vdd @  then swap ! ;
: low? ( v-)  vdd @ 2 / negate  + drop ;
: ?1p wrq
: pw! ( m) ioc @ p17v @ low? -if - then 0x800 and drop if dup or then edge @ 18bit or edge ! ;
: ?18p p17v  8 !node ioc  @ pwv @ ( phantom) out
: npw!  brq  dbus @ over and or pw! ;
: ?sp ( to.do) ;
: ?ap p17v pwv @ @ 0x20000 ( shared) out npw! ;
: ?wake pins @ jump nul ?1p ?1p ?1p ?18p ?sp ?ap
: @dest ( a-p) 0xf or @ @ ;
: +ours ( pa-p) dup @ swap @dest +or  brq  and or 2/ 2/ ;
: @ours ( -p)  0  uport +ours lport +ours dport +ours rport +ours ;
: status ?wake @ours 2/ rqs ! ;

( block 1257 )
( softsim all tiks)
: out ( output is zero or 1.8v)
: low? ( output negative if voltage is low)
: pw! ( pin-wakeup sets request flag in) edge
: npw! ( neighbor-pin-wakeup sets opposite request flag based on local copy of phantom/shared pin in otherwise unused p17v.)
: @ours ( accumulate r/w requests into) rqs

( block 1258 )
( softsim all toks)
: v-b ( mn-mb) low? -if 0 ;  then dup ;
: @pin ( mpma-mp) @ v-b v+ ;
: @4p ( mp-mp) 0x20 p5v @pin 0x8 p3v @pin
: @2p ( mp-mp) 0x2 p1v @pin
: @1p ( mp-mp) 0x20000 p17v @pin ;
: @sp ( mp-mp to.do) ;
: @pins pins @ jump nul @1p @2p @4p @1p @sp @1p
: !ios ios 0x1fe00 0 @pins push - over @ and pop or rqs @ or swap ! ;
: !pin ( vm) ioc @ over over and drop if 2* out ;  then ( in) 2* - and drop if ( tri) drop ;  then ( weak0) dup @ dup 2/ 2/ negate + swap ! ;
: !4p p5v 0x20 !pin p3v 0x8 !pin
: !2p p1v 0x2 !pin
: !1p p17v 0x20000 !pin ;
: !18p abus @ 0x100 or 0x110 and drop if ; ( up/data)  then dbus @ cnt @ - 2* drop -if 18bit then p-n edge ! ;
: !sp ( to.do) ;
: !ap ( to.do) ;
: !pins pins @ jump nul !1p !2p !4p !18p !sp !ap

( block 1259 )
( softsim all toks)

( block 1260 )
( softsim suspended tiks and toks)
: cnt? cnt @ dup and drop ;


: -hand ( mp-mp) 2* 2* over over over and or drop ;
: -shake  brq  rqs @ 2* -hand if -hand if
     -hand if -hand then then then drop drop ;
: wait? cnt? if -shake ;  then ;


: +mine ( pa-p) @  brq  and or 2/ 2/ ;
: @mine  0  uport +mine lport +mine
     dport +mine rport +mine 2/ rqs ! ;
: !port ( mo-mo) over over and
     if drop dbus @ then over dbus + ! 2/ ;
: !ports abus @ 0x155 or dup 4 2/s 0x8
     4 for !port next drop drop
     0x14 or drop if -1 cnt ! then @mine ;

( block 1261 )
( softsim suspended tiks and toks)


: @mine ( accumulate r/w requests into) rqs

( block 1262 )
( softsim tik/tok and power) :var op [0x102fcec0] :var 'boot [0x102fd02a] :var bail 0 bail ! ( breakpoint)
: update !pins 'bed xqt !ios ;
: ipower !inode 'tok assign  0  p17v  p17v negate softbed +  fill  0 p-n  abus  softbed negate 7 rs +  fill 0 mem ! entry @ pc ! softbed @ 'bed !  'boot  xqt 4 slot !  0xa9  ip ! -track update
: newop  0  cnt !  0  dbus ! pc @ abus !  0  rqs !  0  rport !  0  dport !  0  lport !  0  uport !  op  @ 'tik !  3  pre ! ;
: ?bp ip @ slot @ or bp @ or if drop ;  then -  bail  !  comb  @ brk ! ;
: itik ( i) !inode
: tik 'tik xqt ;
: itok ( i) !inode
: tok  0  brk ! 'tok xqt ;
: tiks  nns -1 +  for i itik -next ;
: toks  nns -1 +  for i itok -next ;
: power  nns -1 +  for i ipower -next toks tiks ;

( block 1263 )
( opcode ---tick--- ---tock---)
( -alu-- ..update.. .!results.)
( ...... ..........)
( -addr- .upd,bus,? /)

( alu ops don't have to change tick;)
( addr ops set abus,dbus in tick, then check for completion; if not done, tock writes dbus to ports and tick checks again, repeated til done. when done, tock clears ports and resumes opcode.)

( block 1264 )
( softsim read/write access)
: @port ( mop-mop) push over over and if dbus + @dest then pop +or over u+ ;
: @ports dbus @  wrq  ? drop if ;  then abus @ 4 2/s 0x15 or 0x1 0 4 for @port next nip nip 18bit dbus ! ;
: ir/w abus @ 0x15d or drop if ;  then dbus @  wrq  ? if 18bit p-n ioc ! ;  then drop ios @ dbus ! ;
: romw? dbus @  wrq  ? drop if abus @  rombit  ? drop then ;
: mr/w dbus @  wrq  ? if 18bit abus @ memory ! ;  then drop abus @ memory @ dbus ! ;

( block 1265 )
( softsim read/write access)

( block 1266 )
( softsim port, register, and memory access) ( tik0)
: por@! status 'tok assign ( tok0) !ports update -1 cnt +! 'tik assign ( tiki) status wait? if 'tok assign ( toki) update -1 cnt +! ; ( tike)  then @ports 'tok assign
: toke 'opcode xqt 'group xqt newop ;  begin 'tik assign ( tiki)
: reg@! status cnt? while 'tok assign ( toki) update -1 cnt +! end ( tike) then 'tok assign ( toke) ir/w toke ;  begin 'tik assign ( tiki)
: mem@! status cnt? while 'tok assign ( toki) update -1 cnt +! end ( tike) then romw? if 'tok assign  op  @ 'tik ! ;  then 'tok assign ( toke) mr/w toke ;
: access ( apc) pop 'group ! pop 'opcode ! cnt ! dbus ! 0x3ff and dup abus ! 0x100 ? if 0x155 or 0xf0 and drop if ( ports) 1 cnt ! por@! ; ( regs)  then 2 cnt ! reg@! ; ( mem)  then ( x) drop mem@! ;

( block 1267 )
( notes) ( opcode ---tick--- ---tock---) ( -alu-- ..update.. .!results.) ( ...... ..........) ( -addr- .upd,bus,? /) ( alu ops don't have to change tick;) ( addr ops set abus,dbus in tick, then check) ( for completion; if not done, tock writes dbus to ports and tick checks again, repeated til) ( done. when done, tock clears ports and resumes opcode.)

( block 1268 )
( softsim ops common code)
: ++@ ( a-n) dup push @ 1 + dup pop ! ;
: @-- ( a-n) dup push @ dup -1 + pop ! ;
: +t ( n) t @ s @ sp ++@ ss ! s ! t ! ;
: -t ( -n) t @ s @ t ! sp @-- ss @ s ! ;
: +r ( n) r @ rp ++@ rs ! r ! ;
: -r ( -n) r @ rp @-- rs @ r ! ;
: bin ( -nn) -t t @ ;
: @19 ( -n) @ dup 0x20000 and 2* or ;
: 3bit ( a-a) 0x7 and pc @ 0x2f8 and or ;
: addr ( a-a) slot @ jump 10bit 8bit 3bit nul nul
: ++abus ( -n) abus @ 0x100 ? if ;  then 0x27f
: /++/ ( nm-n) over dup 1 + or and or ;
: pc++ ++abus pc ! ;
: ar++ ++abus ar !10 ;
: ?+c ( n-n) pc @ - 0x200 and drop if ;  then cy @ 1 and + dup 18 2/s 1 and cy ! ;
: ?+*c ( n-n) pc @ - 0x200 and drop if ;  then cy @ 1 and + dup - 18 2/s 1 and cy ! ;
: ?s+ ( n-n) ar @ 1 ? if push s @19 + ?+*c pop then 2/ over 1 and drop if 0x20000 or then ar ! ;

( block 1269 )
( softsim ops common code)


: @19 ( fetch then extend sign into bit 18)
: ?+c ( add carry for + when p9 set)
: ?+*c ( add carry for +* when p9 set)
     ( includes sign extend in s)

( block 1270 )
( softsim ops control)
: /fet/ ( a)  rrq  3
: /pre/ ( adc) access ( control group) abus @ 2* 2* ip ! dbus @ p-n ir ! pc++
: slot0 0 slot ! ; ( tike)
: /unext/ status pop 'opcode ! 'tok assign ( toke) update 'opcode xqt  3  pre ! ;
: ret r @ /fet/ -r drop ;
: ex r @ /fet/ pc @ r !10 ;
: jmp ir @ addr /fet/ nop ;
: call ir @ addr /fet/ r @ +r pc @ r !10 ;
: ur r @ dup and drop if ( jump) /unext/ -1 r +! slot0 ; ( fall)  then /unext/ -r drop
: slot+ 1 slot +! ;
: jr r @ dup and drop if ( jump) ir @ addr /fet/ -1 r +! ; ( fall)  then pc @ /fet/ -r drop ;
: jz 0x3ffff
: jc t @ and drop if ( fall)
: fetch pc @ /fet/ nop ; ( jump)  then jmp ;
: jp 0x20000 jc ;

( block 1271 )
( notes)
: /fet/ ( begins a forced instruction fetch)
: /pre/ ( uses) access ( to set control-group) ( behavior) ( unconditional jumps specify source of next) ( instruction followed by) /fet/ ( group behavior) ( followed by instruction completion behavior) ( conditional jumps make their test which) ( determines which of two actions to follow)

( block 1272 )
( softsim ops read/write and alu.1)
: /w/ ( r) @ t @ n-p  wrq  or  3  access ( write group) -t drop slot+ ;
: /r/ ( r) @  rrq  3 access ( read group) dbus @ p-n +t slot+ ;
: @a
: @a, ar /r/ nop ;
: !a
: !a, ar /w/ nop ;
: @b
: @b, b /r/ nop ;
: !b
: !b, b /w/ nop ;
: @+
: @+, ar /r/ ar++ ;
: !+
: !+, ar /w/ ar++ ;
: @p pc /r/ pc++ ;
: !p pc /w/ pc++ ;
: /alu/ slot @ 3 or drop if ( slot0-2) ( tike) status pop 'opcode ! 'tok assign ( toke) update 'opcode xqt -1 pre +! slot+ ;  then ( slot3) pc @  rrq  pre @ 0 max /pre/ ;
: +* /alu/
: r+* t @19 ?s+ 2/ 18bit t ! ;
: 2*x /alu/
: r2* t @ 2* 18bit t ! ;
: 2/x /alu/
: r2/ t @19 2/ t ! ;
: -x /alu/
: r- t @ 0x3ffff or t ! ;
: +x /alu/
: r+ bin + ?+c 18bit t ! ;
: andx /alu/
: rand bin and t ! ;
: orx /alu/
: ror bin or t ! ;
: t! /alu/
: rdrop -t drop ;

( block 1273 )
( notes)
: /alu/ ( alu opcodes in slots 0-2 don't end any) ( over-lapping prefetch behavior, while in slot) ( 3 ) ( both actions finish together.) pre ( fakes the simultaneity by keeping track of how many) ( contiguous alu opcodes were at the end of the instruction word.)

( block 1274 )
( softsim ops alu.2 and jump table)
: t@ /alu/
: rdup t @
: lit ( n) +t ;
: .x /alu/ nop ;
: r@ /alu/
: rpop -r +t ;
: r! /alu/
: rpush -t +r ;
: s@ /alu/
: rover s @ +t ;
: b! /alu/
: rb! -t 10bit b ! ;
: a@ /alu/
: ra@ ar @ +t ;
: a!x /alu/
: ra! -t ar ! ;
: s0 ( p-o) 13 2/s 0x1f and ;
: s1 ( p-o) 8 2/s 0x1f and ;
: s2 ( p-o) 3 2/s 0x1f and ;
: s3 ( p-o) 2* 2* 0x1f and ;
: s4 ( p-o) drop 0x20 ;
: @op ( ps-o) jump s0 s1 s2 s3 s4
: !op  op  assign ?bp ir @ n-p slot @ @op jump ret ex jmp call ur jr jz jp @p @+ @b @a !p !+ !b !a +* 2*x 2/x -x +x andx orx t! t@ r@ s@ a@ .x r! b! a!x fetch  !op

( block 1275 )


( block 1276 )
( softsim display ops) :var ?op [0x10192905]
: tab/2 ( xy) push  11  *  3  + pop  15  *  3  +
     over lm at ;
: cr/2 cr -15  xy  +! ;
: emit/2 ( c)  48  + emit
: -sp/2  -11 0x10000 *  nop  xy  +! ;


: v- ( xyxy-xy) push negate pop negate v+ ;


: 'ops align strings ( ; ex jump call unext next if -if @p @+ @b @ !p !+ !b ! +* 2* 2/ - + and or drop dup pop over a . push b! a! fetch)


: .op ( i) 'ops @  0xfffffff0  and
     begin dup and while unpack emit/2
     end then drop sp/2 ;
: ?more ( o)  0x18  ? if drop ( t) ;
      then  0x3  ? if dup or drop ( f) ;
      then  0x4  and drop ( t/f) ;
: .ops ( p) 0 4 for  ?op  xqt
     over over @op dup .op
     ?more while  1  + next ;  then
     pop drop ;

( block 1277 )
( softsim display ops)

( block 1278 )
( softsim display numbers) :var base [0x10]
: hex 16  base  ! ;
: dec 10  base  ! ;
: digits ( i-n) 1 + 0 max 17 min align tbl  , 47 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 5 , 19 , 10 , 16 , 4 , 14 , 48 
: digit ( i) digits emit/2 ;
: .n ( nc) dup push -1 + for  base  @ /mod next begin digit next ;
: awake cnt? -if -shake if silver pop drop ;  then then ;
: ?blue awake
: blue 0x4040ff color ;
: ?cyan awake
: cyan 0xffff color ;
: ?red awake red ;
: yellow 0xe0e000 color ;
: ?white awake white ;
: ?green awake
: green 0xd000 color ;
: broke  comb  @ brk @ or drop if pop drop then ;
: ?brk broke  xy  @ 0x10000 /mod 56 + swap 136 + 0x3f3f color box ;

( block 1279 )
( softsim display)
: base ( radix for small character number display)
: hex ( change)  base ( to hex)
: dec ( change)  base ( to decimal)
: digits ( table of character values)
: digit ( display digit as small character)
( ? if too low, pacman if too high, for debug)
: .n ( display) c ( digits of) n ( in the current)  base
: awake ( exits caller if not awake)
: ?white
: ?green
: ?blue
: ?red ( change to named color if only awake)
: broke ( exit caller if breakpoint not reached)
: ?brk ( draw a box around the node which has) ( reached a breakpoint)

( block 1280 )
( softsim display directions)

: .some ( p- -sp/2) 0x80 ? if ( r) 1 emit/2 then
     0x40 ? if ( d) 16 emit/2 then
     0x20 ? if ( l) 12 emit/2 then
     0x10 ? if ( u) 22 emit/2 then
     drop pop drop ;
: .rdlu ( p-) 0xf0 over over or and drop
     if .some ;  then ( a) 5 emit/2
     ( l) 12 emit/2 ( l) 12 emit/2 drop pop drop ;
: .iocs ( p- i) 7 emit/2 ( o) 3 emit/2
     drop pop drop ;
: .adirs ( a-?) 0x100 over over or and drop if ( -n) ;
: .dirs ( a-?) dup n-p if 0x15400 or 0x3fd00 and
     while then drop ( -n) ;
      then drop sp/2 sp/2
     then 8bit 0x55 or 0xf0 ? if .rdlu ;
      then 0x8 ? if .iocs ;
      then sp/2 ( ?) 47 emit/2 drop pop drop ;
: noadr ( w) drop ; : .10b ( w) p-n 0x3ff and 3 .n ;
: .8b ( w) p-n 0xff and 2 .n ;
: .3b ( w) 43 emit/2 p-n 7 and digit ;
: .adr ( wi) over over @op -2 + drop
     -if drop drop ;  then
     jump .10b .8b .3b noadr noadr

( block 1281 )
( softsim display directions)


( block 1282 )
( softsim display registers)
: adr. abus @10 .adirs 3 .n ;
: db. dbus @ p-n 5 .n ;
: tr. cy @ 1 and drop if -sp/2 0x25 emit/2 then
t @ 5 .n ;
: sr. s @ 5 .n ;
: ar. ar @ .dirs 5 .n ;
: br. b @10 .adirs 3 .n ;
: ioc. ioc @ 5 .n ;
: ios. ios @ p-n 5 .n ;
: rqs. rqs @ 9 2/s 0xff and 0x2 .n ;
: ir. ir @ 5 .n ;
: op. ir @ n-p slot @ @op .op ;
: pc. pc @10 .adirs 3 .n ;
: rr. r @ 5 .n ;
: sl. slot @ digit ;
: rp. rport @ 5 .n ;
: dp. dport @ 5 .n ;
: lp. lport @ 5 .n ;
: up. uport @ 5 .n ;


: ?+- ( -c) -shake if ( -) 35 ;  then white ( +) 43 ;
: cnt. cnt @ dup and
     -if drop ?+- emit/2 ;  then digit ;

( block 1283 )
( softsim display registers)

( building blocks for the 2d display, com.)

( block 1284 )
( softsim display pins)
: i/o ( m) cyan ioc @ and drop if yellow then ;
: .io ( m) dup i/o ios @ and if drop 0x1 then digit ;
: .1p 0x20000 .io ;
: .2p .1p 0x2 .io ;
: .4p .1p 0x20 .io 0x8 .io 0x2 .io ;
: .18p 0x1000 i/o edge @ 5 .n ;
: .sp ( to-do) red  0  2 .n ;
: .ap ( to-do) red  0  2 .n ;
: .pin pins @ jump nul .1p .2p .4p .18p .sp .ap
: .pins  comb  @  0x8000 block negate  +  0x200  / dup -17 + drop -if drop 165  xy  +! .pin ;  then 18 mod -17 + drop -if .pin ;  then 0x2c0000  xy  +! .pin ;
: mv. ( ab) i/o @ sp/2 4 .n ;
: .mvs p17v 0x20000 mv. p5v 0x20 mv. p3v 0x8 mv. p1v 0x2 mv. ;
: ?pex  ?op  assign dup slot @ or drop if white ;  then red
: /?op  ?op  assign white ; /?op 
: ?ip ( nf-n) dup and drop if ?green /?op ;  then ;
: ?pc ( n-nf) dup pc @ or  0x240 -  and drop if dup 2* 2* ip @ or  0x900 -  and drop if  1  ;  then red ?pex  0  ;  then yellow  0  ;

( block 1285 )
( softsim display pins)

( block 1286 )
( softsim display big nodes) :var nod :var nod2 [0x12]
 begin drop red ;
: me? ( i) dup  nod  @ or drop until  nod2  @ or drop if broke cyan ;  then yellow ;
: .focus ( i) dup me? n-nn dec 3 .n hex ;
: stack sp @ 8 for dup ss @ 5 .n cr/2 -1 + next drop ;
: return rp @ 8 for 1 + dup rs @ 5 .n cr/2 next drop ;
: stacks white return ?red rr. cr/2 ?green tr. cr/2 sr. cr/2 white stack ;
: /mem. ( i)  'trk  xqt mem @ + dup white ?pc swap 2 .n sp/2 ?ip memory @ dup p-n 5 .n sp/2 .ops .adr cr/2 ;
: mem. mem @ 0xb8 and mem ! 15 for i /mem. -next ;
: .pex ip @ dup 0x400 and drop if red -sp/2 2/ 2/ 0x3ff and 3 .n sp/2 ir. sp/2 ir @ p-n ?pex .ops .adr ;  then drop ;
: .big ( hvn) dup push !inode hex over 30 + over tab/2 stacks tab/2 pop .focus sp/2 white ar. cr/2 space space space br. cr/2 .pex cr/2 mem. cr/2 white ( ios. sp/2 rqs. cr edge @ h. cr) ;

( block 1287 )
( softsim display big nodes)

( block 1288 )
( softsim display small nodes)
:var xo :var yo :var xs [0x8] 8 xs ! :var ys [0x4] 4 ys ! 
: com. ( i) hex  xy  @ push .drs .pins pop  xy  ! cr/2 -sp/2 silver ( i) .focus white adr. cr/2 ?brk
-sp/2 ?white sl. ?green op. cr/2
     ?white ir. cr/2
     ?green cnt. sp/2 ?white pc. cr/2
     ?white ar. cr/2 space ?white br.
cr/2 ?cyan ioc. cr/2 ?red rr. cr/2
?green tr. cr/2 sr. ;
: ?com ( i) dup !inode vis @ dup and
     if  0x10000  /mod tab/2 com. ;
      then drop drop ;
: coms. nnx  xs  @ negate +  xo  @  yo  @  nnx  * +
 ys  @ for  xs  @ for dup ?com 1 + next
over + next drop drop ;
: out? ( i-xy)  nnx  /mod  xo  @  yo  @ v-
     over over +or push over over
      xs  @  ys  @ v- and - pop +or drop ;
: loc ( i-l) dup !inode out? -if drop drop 0 ;
 then push ( x)  7  *  1  +
     pop ( y) -  ys  @ + ( 11 )  12  * ( hv)  16  2*s + ;
: !vis  comb  @  nns -1 +
      for i loc vis ! -next  comb  ! ;

( block 1289 )
( softsim display small nodes)

( block 1290 )
( softsim display map and screen)
:var gap [0x1] :var wind? [0xffffffff] :var time
: xm ( -n) nnx  xs  @ negate + ;
: ym ( -n) nny  ys  @ negate + ;
: .vis ( hv) 2/  yo  @ - ym +  2  + +  30  * push
     2/  xo  @ +  22  * pop over over at
      xs  @  22  *  ys  @  30  * v+ blue box ;
: .node ( n) nn-n dup !inode ?green 48 emit
     me? 0xffea0000  xy  +! 21 emit ;
: .line ( n) cr 17 for dup .node 1 + -next drop ;
: .map ( hv) over over .vis tab/2
     7 for i  nnxmod  * .line -next ;
: .wind ( hv)  wind?  @ dup and drop if .map ;
      then 1 1 v+  nod2  @ .big ;
: bg 0x1f1f1f color
     25 for 46 for 48 emit next cr next ;
: .so ( bg)  comb  @ coms.
     56 0 .wind 57 22  nod  @ .big cr/2
     white  time  @ . cr  gap  @ .  comb  ! ;
: ok !vis show black screen text .so keyboard ;

( block 1291 )
( softsim display map and screen)

( block 1292 )
( softsim keyboard handler)
: wtog  wind?  @ -1 or  wind?  ! ;
: we 1 : dx ( n)  xo  swap over @ + xm
: dw ( ann) min 0 max swap ! !vis ;
: ww -1 dx ;
: wn 1 : dy ( n)  yo  swap over @ + ym dw ;
: ws -1 dy ;
: wy+  ys  @ 1 + 4 min  ys  ! 0 dy ;
: wy-  ys  @ -1 + 1 max  ys  ! 0 dy ;
: wx+  xs  @ 1 + 8 min  xs  ! 0 dx ;
: wx-  xs  @ -1 + 1 max  xs  ! 0 dx ;
: ftog  nod2  @  nod  @  nod2  !
      nmem  @  n2mem  @  nmem  !  n2mem  !
: nod! ( n) dup !inode  nod  ! mem @  nmem  ! ;
: fw -1
: +nod  nod  @ +  0  max  nns -1 +  min nod! ;
: fn  nnx  nop
: ++nod  nod  @ over +nod swap over +  nod  @ or drop if nod! ;  then drop ;
: fs  nnx negate  ++nod ;
: fe 1 +nod ;
: mh  8 64 +  nop
: mhl -track  comb  @ swap  nod  @ !inode mem @ +  0xbf  and dup  nmem  ! mem !  comb  ! ;
: ml  -8  mhl ;

( block 1293 )
( softsim keyboard handler)

( block 1294 )
( softsim keyboard handler)
: gtog  big  @ 1 or  gap  @ or  gap  ! ;
: +gap 1
: +g  big  @ + 2 max dup  big  !  gap  ! ;
: ++gap 100 +g ;
: --gap -100 +g ;
: -gap -1 +g ;
: brk?  bail  @ dup and drop ;
: restart 0  time  !  comb  @ power nm2m  comb  ! ;
: step 1  time  +!  comb  @ toks tiks  comb  ! ;
: quick  gap  @
: steps ( n) 0  bail  ! for step brk? if pop drop ;  then next ;
: upto ( n)  time  @ negate + 0 max steps ;
: go quick pause brk? if ;  then key? go ;
: -stp -track quick ;
: +stp step
: listen awake begin  op  @ 'tik @ or drop while pause key? step end then track ;
: h pad ( -n.alt) nul +stp accept nul ( ur) ww wn ws we ( mr) fw fn fs fe ( lr) ftog mh ml wtog ( ul) nul nul --gap ++gap ( ml) restart gtog go -stp ( ll) nul nul -gap +gap ( n.alt)  , 0x2507 ( ur) , 0x110160c ( mr) , 0x110160c ( lr) , 0xf0c1403 ( ul) , 0x2b230000 ( ml) , 0x80d0e12 ( ll) , 0x2b230000

( block 1295 )
( softsim keyboard handler)


: h ( keyboard handler)
      -+ ( by) ( 100 )
     pfgs ( power fast go step)
     -+ ( by) ( 1 )

     ludr ( left up down right) window
     ludr ( left up down right) focus
     oudw ( other up down window) memory dump

     i. ( instruction) step complete opcode ( quit)

note/  pad ( other-keys del-key space-bar alt-key)  also, 1st chars are ( del-key space-bar alt-key) right-to-left

( block 1296 )
( softsim connect node ports)
: !dests ( onn-on) !inode over dbus + push dup !inode over dbus + pop ( onaa) over over 0xf or ! swap 0xf or ! ;
: row ( on-o)  nnx  for dup  nnx  + !dests 1 + next drop ;
: rows ( non) for over row  nnx 2 *  u+ next drop drop ;
: col ( on-o)  nny  for dup 1 + !dests  nnx  + next drop ;
: cols ( non) for over col 2 u+ next drop drop ; dbus negate 
: rights 0  dup rport +  nop  nnx 2/  cols ;
: lefts 1  dup lport +  nop  nnx 2/ -1 +  cols ;
: downs 0  dup dport +  nop  nny 2/  rows ;
: ups nnx  uport +  nop  nny 2/ -1 +  rows ;
: edges  nns -1 +  for i !inode  0  pins !  0x201ff  iom !  ' nul  softbed ! edge dup ldest ! udest ! -next ;
: connect edges rights lefts ups downs ; connect

( block 1297 )
( softsim connect node ports)

edge ( is the dummy destination for unassigned)
( left and up ports)
: !dests ( using a port index /1,2,4,8/ and two)
( nodes, node numbers, stores both port)
( addresses in the other's *dest variable)
: row : rows : col : cols ( calc neighbors and assign *dest)
: rights : downs : lefts : ups
: edges
: connect

( block 1298 )
( softsim assign node pins and wake-up)
: c0, ( n) 0x1e00
: iom! ( nm) swap !node iom @ or iom ! ;
: l0, ( n) 0x1800 iom! ;
: u0, ( n) 0x600 iom! ;
: l1, ( n) 0x21800 1
: !p ( nmi) push iom! pop pins ! ;
: l2, ( n) 0x21803 2 !p ;
: u1, ( n) 0x20600 1 !p ;
: u2, ( n) 0x20603 2 !p ;
: u4, ( n) 0x2063f 3 !p ;
: u18, ( nw) swap 0x20600 4 !p pwv ! ;
: us, ( n) 0x20600 5 !p ( dummy) ;
: !ap ( nwm) swap !node ios push 6 !p pop pwv ! ;
: la, ( nw) 0x21800 !ap ;
: ua, ( nw) 0x20600 !ap ; ( single) 100 l1, 217 l1, 317 l1, 417 l1, 500 l1, 517 l1, 600 l1, 715 u1, ( serdes) 1 us, 701 us, ( spi) 705 u4, ( async) 708 u2, ( 1wire) 200 l1, ( sync) 300 l2, ( parallel) 7 0x200 u18, 8 u4, 9 0x80 u18, ( analog) 117 217 la, 617 517 la, 709 715 ua, 713 715 ua, 717 715 ua, ( no pins) 0 c0, 2 u0, 3 u0, 4 u0, 5 u0, 6 u0, 10 u0, 11 u0, 12 u0, 13 u0, 14 u0, 15 u0, 16 u0, 17 c0, 400 l0, 700 c0, 702 u0, 703 u0, 704 u0, 706 u0, 707 u0, 710 u0, 711 u0, 712 u0, 714 u0, 716 u0,

( block 1299 )
( softsim assign node pins and wake-up)

( block 1300 )
 unused  see 150 ( test code for chip) reclaim

( ide parts) 1372 5 loads reclaim

( custom code) 1302 load ( exit)

( polyforth) 730 load
( smtm test) node 0 1342 load exit

( */ exerciser) node 402 1354 load
     node 401 1356 load node 400 1358 load
( serdes) node 1 1360 load node 701 1362 load
( spi flash write) node 702 1364 load
( ana) node 715 1366 load node 717 1368 load


( block 1301 )
( this block is loaded to compile test code for any desired nodes. write *nnn node* either here before loading a node's source, or in the source itself. the *node* phrase compiles the appropriate rom for the given node so that test code may reference the rom.)

( things like ide and common tests are loaded here, and this base code is presently assigned up at the top of this area just below 1380. to simplify base maintenance, please use) ( 1302 ) ( for your own testing and load it from here. when we begin using personal space above) ( 1440 ) ( your own tests can go there.)

( block 1302 )
 unused ( custom test code exit)

( read/write) ( 18 ) ( bit flash)
      node 705 1364 load 1609 bin
     node 706 1216 load 1610 bin
( read/write) ( 8 ) ( bit flash)
     node 705 1370 load 1611 bin
( read image from flash to sram)
host  :: sram ( -n) 4095 lit ; :: resume ( -n adjusted)  656 18 8 */ 4 *  lit ;
target
     node 705 292 load 1612 bin
( spi speedup)
     node 705 284 load 1608 bin

( block 1303 )
( this load block, and the following) ( 25 ) ( source/shadow pairs, are yours to do with as you please!)

( block 1304 )
( eforth rom code)

( sdram addr) node 9 1320 load
     ( ctrl) node 8 1322 load ( ram)
     ( data) node 7 1324 load
     ( idle) node 108 1326 load
     ( user) node 107 1328 load

( eforth stack) node 106 1310 2 loads
     ( bitsy) node 105 1306 2 loads



( block 1305 )
( load block for rom resident sdram and eforth in the ga144. loaded by) ( 940 ) ( even for tapeout.)

( block 1306 )
( e4 bitsy 1of2)
org 0xaa 
: rp-- ( a-a') ( 0xaa ) -1 . + ;
: bs@ : 'else ( a-w) ( 0xac )
     @p+ !b !b . ( ') @p+ x@ ( ')
     @p+ !b @b ; ( ')  . . . !p+ ( ')
: rp@ ( ri-ri) ( 0xb0 ) over rp--
: pshbs ( w-) ( 0xb1 ) @p+ !b !b ; ( ')  @p+ pshw ( ')
: 'r@ ( ri-ri) ( 0xb3 ) over rp--
: @w ( a-) ( 0xb4 ) bs@ pshbs ;
: rfrom ( ri-r'i) ( 0xb6 ) over rp-- over over @w ;
: popbs ( -w) ( 0xb9 ) @p+ !b @b ; ( ')  !p+ pops ( ')
: pshr ( aw-a) ( 0xbb )
     @p+ !b !b dup ( ') @p+ . . @p+ ( ')
     !b @p+ !b . ( ') x! ( ')
: rp++ : ip++ ( a-a') ( 0xbf ) 1 . + ;
: tor ( ri-r'i) ( 0xc1 ) push popbs pshr pop ;
: rp! ( i-ri) ( 0xc4 ) push popbs rp++ pop ;


: 'con ( ra-r'i) ( 0xc7 ) bs@
: 'var ( ra-r'i) ( 0xc8 ) dup pshbs
: 'exit ( rx-r'i) ( 0xc9 ) drop rp-- dup bs@ ;

( block 1307 )
( e4 bitsy shadow 1of2)
: rp-- ( internal)
: x@ ( internal) : 'else ( eforth microcode)
: rp@ ( eforth microcode)
: pshw ( internal)
: 'r@ ( eforth microcode)
: @w ( internal)
: rfrom ( eforth microcode)
: popw ( internal)
: pshr ( internal)
: rp++ ( internal) : ip++ ( internal)
: tor ( eforth microcode)
: rp! ( internal)
: 'con ( eforth microcode)
: 'var ( eforth microcode)
: 'exit ( eforth microcode)

( block 1308 )
( e4 bitsy 2of2)

( 0xcb )  begin dup 2* -if
     ( code.s-xt) drop !b ahead  swap  then
     ( code.r-xt) drop push ;'

: bitsy ( 0xce ) then dup bs@ push ip++
: xxt ( 0xd0 ) pop -until
     ( list-xt) push pshr pop bitsy ;

( execute)
: 'ex ( 0xd3 ) ( xt--) popbs push xxt ;
: 'lit ( 0xd5 ) ( --w) dup bs@ push ip++ pop pshbs ;
: 'if ( 0xd8 ) ( f--) popbs if
     drop ip++ ;  then drop 'else ;

( 0xdc ) exit ( start is run in ide)
: start right a! ( terminal) left b! ( stack)
     -32 0 ( rp.ip) bitsy ;

( block 1309 )
( e4 bitsy 2of2 shadow)
: 'con ( runtime constant)
: 'var ( runtime variable)
: 'exit ( runtime end call)


: btc ( label e4 interpreter)
( bitsy main interpreter entry)
: xxt ( internal)


: 'ex ( runtime execute)
: 'lit ( runtime literal)
: 'if ( runtime conditional branch)

: @io ( return the serial bit delay)
: !io ( init serial 0-autobps n-fixedbps)
: t!io ( internal)
: tx! ( transmit one character)
: ttx! ( internal)
: trx? ( internal)
: rx? ( test recieved char - 0 if no char else 18bit inverted char)

( block 1310 )
( e4 stack 1of2)
org 0x3c 
: xa@ ( a-) ( 0x3c ) @p+ !b !b ; ( ')  @p+ sd@ ( ')
: xa! ( a-) ( 0x3e ) @p+ !b !b ; ( ')  @p+ sd! ( ')
( 0x40 )  org 0xaa 
: 'c@ : '@ : x@ ( a-w) ( 0xaa ) xa@ @b ;
: sp++ : char+ : cell+
: 1+ ( w-w') ( 0xac ) 1 . + ;
: popt ( p-xp't) ( 0xae ) dup sp++ over x@ ;
: sp-- : char- : cell-
: 1- ( w-w') ( 0xb0 ) -1 . + ;
: psht ( pt-p') ( 0xb2 ) push sp-- pop over
: x! ( wa-) ( 0xb4 ) xa! !b ;
: 'c! : '! ( pwa-p'st) ( 0xb6 ) x!
: popts ( p-p'st) ( 0xb7 ) popt
: pops ( pt-p'st) ( 0xb8 ) push popt pop ;
: pshs ( pst-p't) ( 0xba ) push psht pop ;
: page@ ( pst-p'tw) ( 0xbc ) @p+ !b @b . ( ') dup !p+ ; ( ')
: pshw ( pstw-p'tw) ( 0xbe ) push pshs pop ;
: page! ( ptw-p'st) ( 0xc0 ) @p+ !b !b . ( ') drop @p+ ; ( ')  pops ;
: sp@ ( 0xc3 ) ( -a) pshs psht dup pops ;
: sp! ( 0xc6 ) ( a-) pshs popts ;

( block 1311 )
( e4 stack 1of2 shadow)
: 'c@ ( runtime c@)
: '@ ( runtime @)
: x@ ( inline external ram)
: sp++ ( increment data stack pointer)
: char+ ( increment address by char size)
: cell+ ( increment address by cell size)
: 1+ ( increment by one)
: popt ( internal)
: sp-- ( decrement data stack pointer)
: char- ( decrement address by char size)
: cell- ( decrement address by cell size)
: 1- ( decrement by one)
: psht ( internal)
: x!
: 'c! ( runtime c!)
: '! ( runtime !)
: popts ( internal)
: pops ( internal)
: pshs ( internal)
: page@ ( inline external ram)
: pshw ( inline external ram)
: page! ( inline external ram)

( block 1312 )
( e4 stack 2of2)
: 'drop ( 0xc8 ) ( w-) drop pops ;
: 'over ( 0xc9 ) ( ww-www) over pshw ;
: 'dup ( 0xca ) ( w-ww) dup pshw ;
: 'swap ( 0xcb ) ( ab-ba) over push push drop pop pop ;
: '2/ ( 0xcd ) ( w-w) 2/ ; : '2* ( 0xce ) ( w-w) 2* ;
: um+ ( 0xcf ) ( uu-uc) over or -if
     ( 0xd0 ) over or . + -if
: 'nc ( 0xd2 ) ( -0) dup dup or ;
: 'cy ( 0xd3 ) ( -1) then 1 ;
     ( 0xd5 )  then over or -if + 'cy ;  then + 'nc ;
: zless ( 0xd8 ) ( n-f) -if dup or - ;  then dup or ;
: 'or ( 0xdb ) ( ww-w) over - and
: 'xor ( 0xdc ) ( ww-w) or pops ;
: 'and ( 0xdd ) ( ww-w) and pops ;
: negate ( 0xde ) ( w-w) 1-
: invert ( w-w') ( 0xdf ) begin ( .) - ;
: zeq ( w-f) ( 0xe0 ) until dup or ;
: '+ ( pww-p'sw') ( 0xe2 ) + pops ; ( 0xe3 ) ( exit)
: swap- ( 0xe3 ) ( ww-w) - . + - pops ; ( 0xe5 )

( 0xe5 ) exit ( start is run in ide)
: start right b! ( sdram)
0 dup dup ( sp.s.t) --l- ; ( bitsy)

( block 1313 )
( e4 stack 2of2 shadow)
: pshw ( internal)
: sp@ ( get data stack pointer)
: sp! ( set data stack pointer)
: 'drop ( runtime drop)
: 'over ( runtime over)
: 'dup ( runtime dup)
: 'swap ( runtime swap)
: zless ( runtime zero less)
: um+ ( add with carry)
: 'nc ( no carry is 0)
: 'cy ( carry set is 1)
: 'xor ( runtime exclusive or)
: 'and ( runtime and)
: 'or ( runtime inclusive or)
: negate ( runtime negate)
: invert ( runtime invert)
: zeq ( runtime zero equals)
: '+ ( runtime +)
: '2/ ( runtime 2/)
: '2* ( runtime 2*)

( block 1314 )
( e4th bitsy)


: @io ( 0x31 ) ( --u) @p+ ! @ . ( ') push t'@io ( ') pshw ;
( init io device 0-autobps n-fixedbps)
: !io ( 0x34 ) ( u--) popw
: t!io ( 0x35 ) ( u-) @p+ ! ! ; ( ')  @p+ t'!io ; ( ')
: tx! ( 0x37 ) ( c--) popw
: ttx! ( 0x38 ) ( c-) @p+ ! ! ; ( ')  @p+ - ; ( ')
: trx? ( 0x3a ) ( -c'0) @p+ ! @ ; ( ')  !p+ t'rx? ; ( ')
: rx? ( 0x3c ) ( --c'0) trx? pshw ;

( block 1315 )


( block 1316 )
( e4 terminal 1of2 - serial i/o)


: getchar ( 0x0 ) ( delay in'0 f - delay -char f) push over 2/ for . unext .. ( middle of start-bit)
7 for ( 8-data bits)
     over for . unext ..
     0x1ffff @b ( middle +/-)
     over - and push and pop or
2/ next
2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ .. 0xff and - dup
begin drop @b -until drop pop ;


: putchar ( 0x13 ) ( delay in'0 c - delay in'0)
push over pop
2* 0x3fe00 dup push - and pop or
10 for ( 1-start, 8-data, 2-stop bits)
     2 over over 2/ and or !b
     over for . unext ..
2/ next drop drop ; ( 0x21 )

( block 1317 )
( note. both tx and rx are completely in stock rs232 polarity, i.e. mark lo space hi, data low start low. ultimately we need to invert the whole thing for compatibility with s40 boot node conventions but for testing purposes we will leave it as is and invert the rs232 board.)


: getchar ( called after seeing leading edge of start bit. returns clean inverted character.)


: putchar ( takes a dirty octet of data and transmits it as startbit, eight data bits no parity one stop bit.)

( block 1318 )
( e4 terminal 2of2 - bitsy commands)


: baud ( 0x21 ) ( 0-d) - push ( space is 0'0000.0100'1)
( 0x22 ) begin @b - -until ( at start-bit)
( 0x23 ) begin @b -until ( at 1-bit)
( 0x24 ) begin @b zif then - . -until ( at 0-bits)
( 0x26 ) begin @b zif then . -until ( at stop-bit)
pop - ( n) dup 2/ . + ( 1.5n) ;


: @io ( 0x2a ) ( delay - delay in'0 0)
     pop a! push dup or baud !
     pop pop dup dup or ;
      begin baud
: !io ( 0x2f ) ( delay in'0 u - delay 0 0)
     until ( abandon old values)
: rx? ( 0x30 ) ( delay - delay 0 0) 0 dup ;


: terminal ( 0x32 ) ( delay in'0 x)
begin drop @b - -if getchar then
     - 2* 2* -if drop .. r--- ( bitsy) then
-until ( delay in'0 -c) - putchar dup terminal ; ( 0x3c )

( block 1319 )

: @io ( return the serial bit delay)


: !io ( sets nonzero baud rate delay over garbage. if zero, waits for a space character to autobaud with.)


: rx? ( test for received char)


: tx! ( send one character)


: terminal ( polling loop for character receive or send)

( block 1320 )
( sdram address-bus)
( copy command to address bus)

org 0xaa 
: cmd ( c-) ( 0xaa ) 0x3d555 ( nop.xxx) !b ..
     @ ( sleeps) !b cmd ;

( 0xad ) exit ( start is run in ide)
: start right a! data b! cmd ;

( block 1321 )


( block 1322 )
( sdram control-pins)
( each word runs the requested rise..fall cycle 12+11 ticks per cycle is a 42ns period)
org 0x0 
: nooop ( rfr-rfr) ( 0x0 ) ( 'nooop') . .. !b
     .. over over .. . . !b ;
: rcol1 ( rf-rfrf) ( 0x4 ) . . !b
     .. 0x2b .. !b ( transfer)
     . 0x22e .. . . !b ;
( 0xa ) org 0x10 ( 8-word page accessible to down port)
: cmmd ( rfr-rfr) ( 0x10 ) ( '@p+ ! cmmd') !b
     .. over over .. . . !b ;
: rcol ( rfr-rfr) ( 0x13 ) ( '@p+ ! rcol') !b
     over over .. rcol1 ;
: wcol ( rfr-rfr) ( 0x15 ) ( '@p+ ! wcol') !b
     0x2003e 0x2002e .. !b
     .. 0x3022b .. !b ( transfer)
     0x3023b !b .. . . !b
     0x2002e .. !b 0x2b !b ( recover)
     .. over over .. . . !b ;

( 0x23 ) exit ( start is run in ide)
: start right a! io b! 0x2e ( cmd-fall) -d-- ;

( block 1323 )


( block 1324 )
( sdram data-bus)

( db@ isn't used with 7j chip!)
org 0xaa ( called with 'db@' '...!p+')
: db@ ( -w) ( 0xaa ) @ ; ( wakeup when data ready)

( db! called with '@p+ db!')
: db! ( w-) ( 0xab ) 0x15555 !b ( .. set output state)
     ! ( wakeup when data taken)
: inpt ( 0xad ) 0x14555 !b ; ( restore input state)

( 0xaf ) exit ( start is run in ide)
: start up a! io b! down push inpt ;

( block 1325 )


( block 1326 )
( sdram idle-loop)
org 0xaa 
: noop ( -) ( 0xaa ) @p+ ! ; ( ')  nooop ( ')
: cmd ( c-) ( 0xac ) 0x5a48 ! ! ; ( '@p+ ! cmmd')

: idle ( m-m) ( 0xae ) @p+ ! .. ( ') nooop ( ') 0x8003 cmd noop 120 for ( 7.8us 42ns/ 5- is 181)
     @p+ ! .. ( ') nooop ( ')
     begin ( 0xb7 ) @b and if
     ( ...) @ .. @ ! ! ( user to ctrl)
     ( ...) *next idle ; ( 0xbc )
      then drop
next @p+ ! .. ( ') nooop ( ') idle ;

: init ( m-m) ( 0xc0 ) ( run only at power-up/reset)
     4761 for ( 200us 42ns/ 1-) noop next
     noop 0x10400 ( pre.all) cmd noop
     0x8001 ( rfr.123) cmd noop noop
     0x8002 ( rfr.123) cmd noop noop
     0x21 ( std.mode) cmd noop noop
     0x4000 ( ext.mode) cmd noop idle ;

( 0xd8 ) exit ( start is run in ide)
: start 0x135 ( '-dl-) a! io b!
0x800 ( n13w?) dup dup dup dup dup dup
dup dup dup init ;

( block 1327 )


( block 1328 )
( sdram user interface)
org 0xaa ( user cmds+data from/to up or right)
: a2rc ( pa-pbc) ( 0xaa ) dup ( 2* 16mw) push 2/ ( 32mw)
2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ 2/ -if
: row! ( pr-pbc) ( 0xaf ) 0x7fff ( row.mask) and dup ..
0x18000 ( activate) or .. ! 0x5a48 ! .. ( '@p+ ! cmmd') 0x6000 ( bank.mask) and pop .. 0x3ff ( col.mask) and ;  then over + row! ;
: sd@ ( pa-p) ( 0xbb ) a2rc 0x28400 ( read+pre) or or
! 0x5a4b ! .. ( '@p+ ! rcol') down b! ..
@p+ !b @b ( ') @ !p+ .. ( ') pop b! !b ;
: sd! ( pa-p) ( 0xc5 ) a2rc 0x20400 ( write+pre) or or
! 0x5a4d ! .. ( '@p+ ! wcol') pop b! @b ..
down b! .. @p+ !b !b ; ( ')  @p+ db! ( ')
: poll ( ru-ru) ( 0xcf ) io b! @b
2* 2* -if push over .. r--- over pop then
0x800 and . if push .. ---u pop then
drop poll ;

( 0xdc ) exit ( start is run in ide)
: start left ! 0 0 ( r.u) poll ;

( block 1329 )
( configure for sdram wiring as follows)
 2* ( 16mw) push ( 2/ 32mw)  for 16 mw wiring
( 2* 16mw push)  2/ ( 32mw)  for 32.

( block 1330 )
( async ats interface) org 0 
: obit ( dwn-dw) ( 0x0 ) !b over push delay ;
: word ( dw-d) ( 0x2 ) leap drop leap drop leap drop drop ;
: obyt ( dw-dwx) ( 0x6 ) then then then 3 obit drop 7 for dup 1 and 3 or obit drop 2/ next 2 obit ;
: -out ( 0x11 ) ser-exec ( rdl-) ; ( 0x12 )


: ok ( 0x12 ) 0x31416 word -out ;
: fet ( 0x15 ) 0
: pump ( n) for @+ word next -out ;
: stat ( 0x1b ) 9 pump ;
: bstk ( 0x1d ) @ push .. @ word pop dup push word .. ( @p+.push) 0x49ba ! 7 .. dup push ! .. @p+ ! .. ( /+) begin !p+ . . unext .. begin @ word .. next .. @p+ ! pop .. ( /+) pop @p+ ;  .. ! -out ; ( 0x2c )

( block 1331 )
( this code is loaded on top of ide boot node.)
: obit ( sends one bit 0-3/hi 1-2/low)
: word ( sends a word as) ( 3 ) ( octets.)
: obyt ( sends and discards) ( 8 ) ( lsb of w, lsb first, with one start bit hi and one stop bit low.)

( block 1332 )


( block 1333 )


( block 1334 )


( block 1335 )


( block 1336 )


( block 1337 )


( block 1338 )


( block 1339 )


( block 1340 )


( block 1341 )


( block 1342 )
( smtm test) org 0x32 
: go a! 0x1557f !b 0x1556a !b . pop @p+
     ( ') @p+ dup 2/ . ( ') a ! ! 0x43 for
     0x3f !+ . unext
     ( ') 2* a! push . ( ' ') begin @p+ !+ . unext ( ')
     ( ') @p+ push ; ( ')  ! warm ;
( 0x12 ) org 0x2a 
: r @p+ go ;  r---
: d @p+ go ;  -d--
: l @p+ go ;  --l-
: u @p+ go ;  ---u
 org 0 ( avoid node1)  d r l
: path r l r l d l r l r d path ;

( block 1343 )
( smtm test)

( steven's crawling memory tester)

( block 1344 )
( 14 ) ( word ga144 creeper test frame 3/25/11)
( see db007 for detailed discussion.)

org 0x36 
: focus ( 0x36 ) ( jport) dup dup a! dup ! @p ! dup
( ') @p b! . ! or !b ;
: creep ( 0x3a ) ( 67 ) dup !b push
begin @p ! unext . ( 0x3c )
( ') 0x3f push dup ( ') or a!
( ') begin @b !+ unext ( 0xc40 )

: wire begin @b ! @b ! @
: rip ( 0x42 ) dup !b -until ( 0x43 ) warm ;
( 0x44 ) org 4 
: test ( 0x4 ) ( n1)

( block 1345 )
( creeper input side data flow iio)
( @p call to focus, creep, wire, rip, or)
( anywhere in the test package from) ( 0x4 ) ( to) ( 0x35 )
( with any n1 on the stack)


: focus ( prepares to use neighbor thru)  jport ( sets a forward and neighbor pc and b back. result is zero.)
: creep  67 ( returned as early sync. crawl to focused node, make it active, we become wire. copies) ( 68 ) ( words to neighbor)
( fallthrough after copy to wire must be at) ( 0x40 )
: wire ( passes iio messages until result negative at which time this node and all before it return to warm.)
: rip ( argument and result must be negative to restore all nodes to warm state.)
: test ( can call any address from) ( 0x4 ) ( to) ( 0x35 ) ( and can do what it wants with)  n1. ( result must be positive,) ( 0 ) ( normally means ok.)

( block 1346 )
( fill neighbor's memory fake test)
( creeper) 1344 load 
: ping ( 0x45 ) @p ! ! . ( ' @p) @b 2/ ( !p) !b .
@ !b ; ( 0x48 ) exit 
: why -1 . + down a! ! ; exit 
: nulltest ( 0x45 ) 1 . + !b ; ( 0x48 ) exit 
: test ( -10485760 ) ( n1) 63 @p ! . ( ') dup or a! @p
! @p ! @p ( ') push ( ') begin a !+ unext .
! dup dup or !b drop ; ( -26214400 )

( block 1347 )


( block 1348 )
( extensive neighbor's memory test 005-035)
org 0x29 : err  org 0x5 
: test ( n1) @p ! @p dup ( ') 0x3f push dup dup
! @p ! ( ') or dup a! .
@p ! ( ') begin dup !+ unext . ( erased)
for

0x19999 @p ! dup ( ') @p ! @ .
! @p ! . ( ') !b @p !
@ or if ( 0x13 ) pop err ;  then ( 0x14 ) ( test1)
0xcccc dup ! @p ( ') @ !b dup dup
! @ or if ( 0x19 ) pop err ;  then ( 0x1a ) ( 0 test2)
@p ! . ( ') or ! . ( erased)

drop @p ! @p ( ') dup ( 0 0) - ( 0x3ffff ) ! 0x3e
! @p ! ( ') @+ !b push ( 0x0 )
@ - if ( 0x22 ) pop err ;  then ( 0x23 ) ( test3)
drop @p ! ( ') begin @+ !b unext . ( 0x0 )
0x3e for @ if pop pop
: err ( 0x29 ) 1 + !b ;  then ( test4)
drop next
@p ! . . ( ') dup !+ . next ( erased)
dup dup or !b ; ( 0x31 ) ( 3/5/11)


( block 1349 )
( test tests neighbor's memory)
( 19999 cccc test shorts to bits two bits away)
( 3ffff) ( 0x0 ) ( test shorts to bits one bit away)
( tests for shorts between two addresses)
( by reading) ( 64 ) ( words after each) ( 0x3ffff ) ( !)


( block 1350 )
( 1604 ) ( all nodes template) node 15 org 0 
: poll io b! @b ( mask) 0xaa00 ( 0x3 ) and if ( drop) warm ;  then drop ; ( 0x6 )
: incr poll if 1 . + ;  then drop 1 . + 1 ;
: run ( 0xe ) -1 0 ( 9999 ) 99999 for ( 9999 ) 44999 for incr next next 0x3e a! !+ !+ 0x600d warm ;
: run ( 0x1d ) 0 1 begin begin while poll 1 . + end then drop 1 . + 1 end ;
( 0x2a ) 1604 bin

( block 1351 )


( block 1352 )
( erase flash) org 0 
: wait ( dw-dw) ( 0x0 ) select dup begin drop @b -until drop select ;
: 2cmd ( dw-d) ( 0x4 ) select 8obits
: cmd ( dw-d) select
: !8 ( dw-d) 8obits drop ;
: set ( -d) ( 0x9 ) io b! ( fast) 5 ;
: fet ( ah al-d) ( 0xc ) push push set ( read) 0xc00 cmd pop !8 pop 8obits !8 ;
: +wr ( -d) ( 0x12 ) set ( wren+wrsr) 0x1804 2cmd
     ( hi8 zero) dup !8 ( ebsy) 0x1c000 cmd ;
: ers32k ( 0x18 ) +wr ( wren+ers32) 0x1948 2cmd
0 !8 0 8obits !8 dup select ;
: ersall ( 0x21 ) +wr ( wren+eras) 0x1980 2cmd
dup select ;
: 16ibits ( d-db) ( 0x25 ) dup 15 for
rbit ibit - next 0xffff and ;
: stash ( d-d) ( 0x2c ) a push 0x3f a! 16ibits ! pop a! ; ( 0x30 )

( block 1353 )


( block 1354 )
( hardware multiply test) org 0 +cy 
: clc ( 0x200 ) dup dup or dup . + drop ;
: d2* ( hl-hl) ( 0x202 ) dup . + push dup . + pop ;
: um+ ( hln-hl) ( 0x205 ) . + push dup dup or . + pop ; ( 0x208 ) -cy 
: h* ( nu-hl) ( 0x8 ) dup a! dup or 17 for +* unext a ;
: abs ( n-n) ( 0xc ) -if
: neg ( n-n) ( 0xd ) - 1 . + then ; ( 0x10 ) +cy 
: u/mod ( hld-rq) ( 0x210 ) clc neg
: -u/mod ( 0x212 ) a! 17 push begin begin dup . + push dup . + dup a . + -if drop pop *next dup . + ;  then over or or pop next dup . + ; ( 0x21e ) -cy 
: try ( 0x21e ) right b! ( ba) @b @b h* ( r) @b um+ ( a) @b u/mod ( b) !b ( r) !b try ; ( 0x226 )

( block 1355 )

: h* ( is simplest multiply; first arg is a signed number and second, the multiplier, is a full) ( 18 ) ( bit unsigned number.)
: try ( slaves this node to another by the port given. it expects to receive numbers b a r and calculates b*a+r then receives a and returns b and r. the multiply is done using the h* here which is why b is signed and a is unsigned.)

( block 1356 )
( soft multiply test) org 0 +cy 
: clc ( 0x200 ) dup dup or dup . + drop ;
: d2* ( hl-hl) ( 0x202 ) dup . + push dup . + pop ;
: um+ ( hln-hl) ( 0x205 ) . + push dup dup or . + pop ;
: u* ( nn-hl) ( 0x208 ) a! clc dup push dup or dup pop 17 for begin push d2* a -if 2* a! pop dup push . + push 0 . + pop pop *next drop ;  then 2* a! pop next drop ; ( 0x219 ) -cy 
: abs ( n-n) ( 0x19 ) -if
: neg ( n-n) ( 0x1a ) - 1 . + then ;
: *. ( ff-f) ( 0x1d ) over over or push abs swap abs u* d2* d2* drop pop -if drop neg ;  then drop ; ( 0x26 ) +cy 
: u/mod ( hld-rq) ( 0x226 ) clc neg
: -u/mod ( 0x228 ) a! 17 push begin begin dup . + push dup . + dup a . + -if drop pop *next dup . + ;  then over or or pop next dup . + ; ( 0x233 ) ( -cy)
: try ( 0x233 ) right b! @b @b u* @b um+ @b u/mod !b !b try ; ( 0x23a )

( block 1357 )


( block 1358 )
( multiply exerciser) org 0x0 
: dec ( n-n) -1 . + ;
: +or ( nn-n) over - and or ;
: try ( abr-ab bad) ( 0x4 ) right a! ( 12033 !) push dup ! over ! pop dup ! push over ! dup @ or @ pop or +or ;
: test ( abr-abr) dup push try if pop ;  then drop pop
: poll @b 0x200 and if up b! @b push ;' io b! then drop
: run ( abr-abr) ( 0x1a ) if dec test ;  then drop if dec over dec test ;  then drop dec if ( -1) 0x1ffff over dec test ;  then drop 0x600d ; ( 0x29 )
: go ( 0x29 ) io b! ( 20000) 0x1ffff ( -1) 0x1ffff over dec run ;


: -u/mod ( old) ( 0x2f ) a! 17 push dup . begin begin
+ push dup . + dup a . + -if drop pop dup *next + ;  then over or or pop dup next + ; ( 0x3c )

( block 1359 )

: try ( exercises slave node given a test vector. for the hardware version a is unsigned and b is signed. but the divide is unsigned so b is limited to the largest positive number.)

( block 1360 )
( serdes test) org 0xaa  data a! 0x3fffe dup ! up a! begin @ drop unext ( rdlu)  org 0 
: try io b! 0x20000 !b 0x147 a! 0 10000 for 1 + dup a! next ;
: start @ io b!
: test 0x2aaaa @b or ! test . . . . down a! . . start

( block 1361 )


( block 1362 )
( serdes test) ( 2 ) org 0xaa  data a! 0x33333 dup ! up a! 0x20000 !b begin dup . . . . . . . . . . . . . . . . . . . . . ! unext . . . . . . .

( block 1363 )


( block 1364 )
( spi flash writer michael + greg 2.1) org 0 
: 2o ( dw-dw') ( 0x0 ) obit 2* obit ;
: wait ( dw-dw) ( 0x2 ) select dup begin drop @b -until drop select ;
: 2cmd ( dw-d) ( 0x6 ) select 8obits
: cmd ( dw-d) select
: !8 ( dw-d) 8obits drop ;
: set ( -d) ( 0xb ) io b! ( fast) 5 ( 20 ) ;
: fet ( ah al-d) ( 0xe ) push push set ( read) 0xc00 cmd pop !8 pop 8obits !8 ;
: +wr ( -d) ( 0x14 ) set ( wren+wrsr) 0x1804 2cmd
     ( hi8 zero) dup !8 ( ebsy) 0x1c000 cmd ;
: aaip ( d-d) ( 0x1a ) 0x2b400 wait !8 ;
: x8p ( hln-d asrc) ( 0x1d ) +wr ( wren+aaip) 0x1ab4 2cmd
drop push push push set pop !8 pop 8obits
!8 ahead begin aaip  swap  then 7 for
     pop dup push push @+
     begin 2o 2* next push aaip pop
     7 pop dup push or push
     begin 2o 2* next drop next next
( wrdi+dbsy) 0x1200 wait 2cmd -++ !b rdl- ; ( 0x3b )
: ers32 ( 0x3b ) ( h-dd +wr wren+ers32) ( 0x1948 ) ( 2cmd)
( over 8obits 8obits !8 dup select ;) ( 0x3b )

( block 1365 )
( run by an adjacent node through a port.)
 $ 24 bit addresses ( are represented in two) ( 18 ) ( bit words. for continuous bit sync, all operations must start on) ( 0 ) ( mod) ( 18 ) ( byte boundaries.)
 high ( word contains the most significant) ( 8 ) ( bits of the address shifted left) ( 10 ) ( bits.)
low ( word contains the least significant) ( 16 ) ( bits shifted left two bits.)


: x8p ( writes)  n ( words into flash starting at address whose) high ( and) low ( parts are given. the data are read from wherever) a ( points; to feed a stream through a port,) a ( must be focused to the port before starting.)


: fet ( starts a read operation)
: 18ibits ( reads one word; take care with)  'd'

( block 1366 )
( take adc data) org 0 
: sam+ ( -n) ( 0x0 ) ( 0x155 ) 0x2155 ( 0x6155 )
: s+- ( k-n) io b! !b up b! !b @b ;
: sam- ( -n) ( 0x6 ) ( 0x955 ) 0x2955 ( 0x6955 ) s+- ;


: sam ( 0x8 ) 0x20 a! sam+ sam- 11 2* for
push sam+ dup - pop . + ( !+) push
push sam- dup - pop . + pop + !+ next ; ( 0x16 )

exit  sam+ drop

( block 1367 )
( this block supports taking of data manually for a/d transfer function. to use it, put a/d in the desired mode by editing the constants in sam+ and - then set desired voltage and execute sam. you will find a sequence of samples stored in ram at) ( 32 )

( original version sampled each half cycle of the incoming clock.)

( block 1368 )
( generate dac waves) org 0 
: dly ( 0x0 ) 100 for unext ;
: sano ( n-n) 0x3ffdf and ;  0x10 or ;
: tri ( n) ( 0x7 ) push 0x155 0 begin
510 for over or dup sano !b
     dly over or 1 . + next
510 for over or dup sano !b
     dly over or -1 . + next next drop drop ;
: try ( 0x1c ) io b!
: sing ( 0x1e ) 1000 tri
: poll ( 0x20 ) @b 0x2000 and if down b! @b push ;' io b! then drop sing ;
: haul ( 0x29 ) io b! -1 dup push dup push dup push dup push dup push dup push dup push dup push push 0x155 0xaa over over over over over over ( /) dup dup
: spin ( 0x36 ) begin !b ( . .) unext ( !b !b !b !b !b !b !b !b) spin ; ( 0x37 ) exit
 0x155 0x1d5 0x55 0xd5 0xaa 0xd5 0x55 0x1d5 ( /)

( block 1369 )


( block 1370 )
( spi flash) ( 8 ) ( bits) org 0 
: 2o ( dw-dw') ( 0x0 ) obit 2* obit ;
: wait ( dw-dw) ( 0x2 ) select dup begin drop @b -until drop select ;
: 2cmd ( dw-d) ( 0x6 ) select 8obits
: cmd ( dw-d) select
: !8 ( dw-d) 8obits drop ;
: set ( -d) ( 0xb ) io b! ( fast) 5 ;
: fet ( ah al-d) ( 0xe ) push push set ( read) 0xc00 cmd pop !8 pop 8obits !8 ;
: 16ibits ( d-db) ( 0x14 ) dup 15 for
rbit ibit - next 0xffff and ;
: +wr ( -d) ( 0x1b ) set ( wren+wrsr) 0x1804 2cmd
( hi8 zero) dup !8 ( ebsy) 0x1c000 cmd ;
: aaip ( d-d) ( 0x21 ) 0x2b400 wait !8 ;
: ers ( 0x24 ) +wr ( wren+eras) 0x1980 2cmd dup select ;
: wp ( hln-d asrc) ( 0x28 ) +wr ( wren+aaip) 0x1ab4 2cmd
drop push push push set pop !8 pop 8obits
!8 ahead begin aaip  swap  then @+ 8obits !8
next ( wrdi+dbsy) 0x1200 wait 2cmd -++ !b rdl- ;
: stash ( d-d) ( 0x3b ) a push 0x3f a! 16ibits ! pop a! ; ( 0x3f )

( block 1371 )
( run by an adjacent node through a port.)
 $ 24 bit addresses ( are represented in two) ( 18 ) ( bit words. for continuous bit sync, all operations must start on) ( 0 ) ( mod) ( 18 ) ( byte boundaries.)
 high ( word contains the most significant) ( 8 ) ( bits of the address shifted left) ( 10 ) ( bits.)
low ( word contains the least significant) ( 16 ) ( bits shifted left two bits.)


: wp ( writes)  n ( words into flash starting at address whose) high ( and) low ( parts are given. the data are read from wherever) a ( points; to feed a stream through a port,) a ( must be focused to the port before starting.)


: fet ( starts a read operation)
: 16ibits ( reads one word; take care with)  'd'

( block 1372 )
( 1600 ) ( ide via async boot) node 708 org 0 
: obit ( dwn-dw) ( 0x0 ) !b over push delay ;
: word ( dw-d) ( 0x2 ) leap drop leap drop leap drop drop ;
: obyt ( dw-dwx) ( 0x6 ) then then then 3 obit drop 7 for dup 1 and 3 or obit drop 2/ next 2 obit ;
: -out ( 0x11 ) ser-exec ( rdl-) ; ( 0x12 )


: ok ( 0x12 ) 0x31416 word -out ;
: fet ( 0x15 ) 0
: pump ( n) for @+ word next -out ;
: stat ( 0x1b ) 9 pump ;
: bstk ( 0x1d ) @ push .. @ word pop dup push word .. ( @p+.push) 0x49ba ! 7 .. dup push ! .. @p+ ! .. ( /+) begin !p+ . . unext .. begin @ word .. next .. @p+ ! pop .. ( /+) pop @p+ ;  .. ! -out ;
( 0x2c ) 1600 bin

( block 1373 )


( block 1374 )
( 1601 ) ( ide via sync boot) node 300 org 0 
: 1bit ( wx-w'x) drop -if 3 ahead  swap  then 2
then !b 2* dup ;
: word ( w) ( 0x6 ) 8 dup for begin drop @b -until 1bit begin drop @b - -until 1bit next drop drop ;
: +out ( x) ( 0xf ) begin drop @b - -until drop 3 !b ;
: -out ( x) ( 0x13 ) begin drop @b -until
drop 2 !b 1 !b ser-exec ;


: ok ( 0x18 ) dup +out 0x31416 word dup -out ;
: fet ( 0x1c ) 0
: pump ( n) dup +out for @+ word next dup -out ;
: stat ( 0x23 ) 9 pump ;
: bstk ( 0x25 ) +out @ dup push . @ word word ( / @p+.push) 0x49ba ! 7 . ( /) dup push ! . ( /) @p+ ! . . ( /+) begin !p+ . . unext ( /) begin @ word ( /) next ( /) @p+ ! pop . ( /+) pop @p+ ; ( /)  ! -out ;
( 0x34 ) 1601 bin

( block 1375 )


( block 1376 )
( 1602 ) ( ide wire node) node 17 org 0 
: fet ( 0x0 ) @p+ !b @ . fet !b @b ! ; ( 0x3 ) org 5 
: sto ( 0x5 ) @p+ !b @ . sto !b @ !b ; ( 0x8 ) org 0xa 
: ins ( 0xa ) @p+ !b @ . ins !b ; ( 0xd ) org 0xd 
: psh ( 0xd ) @p+ !b @ . psh !b ; ( 0x10 ) org 0x10 
: stk ( 0x10 ) @p+ !b . . stk 9 for @b ! unext ;
( 0x15 ) 1602 bin

( block 1377 )


( block 1378 )
( 1603 ) ( ide last guy) node 16 org 0x1e 
: focus ( i0) ( 0x1e ) @p+ !b !b ; ( /)  focus ; org 0 
: fet ( 0x0 ) @p+ focus ( /+) @p+ a! @ !p+ ( /) @ !b @b @p+ ( /+) ; ( /)  !b ! ;
: sto ( 0x5 ) @p+ focus ( /+) @p+ a! . @p+ ( /) @ !b @ . ( /) !b @p+ !b ; ( /+)  ! ;
: ins ( 0xa ) @ focus ; ( /)  ins ins
: psh ( 0xd ) @p+ focus ( /+) @p+ ; ( /)  @ !b ;
: stk ( 0x10 ) @p+ focus ( /+) !p+ dup push !p+ ( /) @b @b ! dup ( /) ! ( @p+.push) 0x49ba !b 7 ( /) dup push !b . ( /) @p+ !b ( /+) begin !p+ . . unext ( /) begin @b ! unext . ( /) @p+ !b !b ; ( /+)  pop @p+ ;
( if past size-2 not ok-) ( 0x1c ) 1603 bin

( block 1379 )


( block 1380 )
( common) org 0x155 ( bomb) org 0x145
: ---u  org 0x175
: --l-  org 0x165
: --lu  org 0x115
: -d--  org 0x105
: -d-u  org 0x135
: -dl-  org 0x125
: -dlu  org 0x1d5
: r---  org 0x1c5
: r--u  org 0x1f5
: r-l-  org 0x1e5
: r-lu  org 0x195
: rd--  org 0x185
: rd-u  org 0x1b5
: rdl-  org 0x1a5
: rdlu

( block 1381 )


( block 1382 )
( polynomial approximation)
: poly ( xn-xy) pop a! push @+ a begin
     push *. pop a! @+ + a next push ;

( block 1383 )

: poly ( xn-xy)
( evaluation of chebyshev polynomials using)
( the horner scheme.)

( x is the input value. n is the length of)
( the coefficient table minus 2. coefficient)
( table follows inline, and execution)
( continues after the final table entry. x is)
( left on the stack under the result, y.)

( for example...)
: cos ( f-f')
( hart 3300)
( -0.0043 0.0794 -0.6459 0.5708)
     2* 2* . triangle dup *. 2 poly
      -281 , 5203 , -42329 , 37407 ,
      push drop pop *. + ;

( block 1384 )
( interpolate)
: interp ( ims-v) dup push push over
     begin 2/ unext a!
     and push @+ dup @+ - . + -
     pop a! dup dup or
     begin +* unext push drop pop . + ;

( block 1385 )

: interp ( ims-v)
( to determine values for m and s ...)
( let l be number of meaningful input bits.)
( let n be power of 2 where 2**n + 1 is the)
( number of table entries.)

( s equals l-n-1)
( m equals 2** l-n - 1)

( so for example if you have an 8 bit adc,)
( l equals 8. let n equal 2 for a 5 entry table. the table is expected to be at address 0,)
( so to represent 0 to 1800 millivolts...)

 $ 0 org $ 0 , $ 450 , $ 900 , $ 1350 , $ 1800 ,

: mv ( i-n) 0x3f $ 5 interp ;

0 mv ( gives) 0
128 mv ( gives) 900
256 mv ( gives) 1800
( and intermediate values are interpolated.)

( block 1386 )
( fir or iir filter)
: taps ( yxc-y'x') pop a! push begin
     @+ @ push a push *.17 pop a!
     push !+ pop . + pop next @ a! ;

( block 1387 )

: taps ( yxc-y'x')
( for example...)


: fir ( yx-y'x') 15 taps  -53 , 0 , 2276 , 0 , 382 , 0 , -1706 , 0 , -1158 , 0 , 2014 , 0 , 2406 , 0 , -1977 , 0 , -4206 , 0 , 1289 , 0 , 6801 , 0 , 678 , 0 , -11109 , 0 , -6250 , 0 , 23531 , 0 , 54145 , 0 ,

( 16 taps, 16 coefficients with intermediate)
( storage interleaved.)

( block 1388 )
( routing; called with 'a relay')
: relay ( a) pop a! @+ push @+ zif
     drop ahead ( done)  swap  then
     pop over push @p+ ( ') a relay ( ')
     !b !b !b begin @+ !b unext
: done then a push a! ;

( block 1389 )
( relay moves a port executable packet down)
( a sequence of nodes linked by their b)
( registers. the packet consists of a 1-cell)
( index, a 1-cell count) less one ( of body)
( size, and the body cells.)

( a packet) may ( be started from memory within)
( a node, or it may simply be fed to a port.)

( relay assumes that b points to the next)
( node in the chain. uses one return stack)
( location and four data stack locations.)
( it must be at the same location in every)
( node.)

( block 1390 )
( multiply)
: *.17 ( a b - a a*b) a! 16 push dup dup or
     begin +* unext - +* a -if
     drop - 2* ;  then drop 2* - ;

( block 1391 )

: *.17 ( multiplies a fraction by a fraction,)
( giving a fraction, or an integer by a)
( fraction, giving an integer. note that f1)
( is left in s to be ignored, dropped, or)
( reused. note that the definition of) *.
( contains a call to this word.)

( 17 bit fractions --- s.i ffff ffff ffff ffff)

( block 1392 )
( lshift rshift)
: lsh push begin 2* unext ;
: rsh push begin 2/ unext ;

( block 1393 )


( block 1394 )
( triangle)
: triangle ( x-y call with; 2* 2* triangle)
     0x10000 over -if drop . + ;  then
     drop - . + - ;

( block 1395 )

: triangle ( assuming an angle expressed as a)
( 16 bit fraction of a revolution,)
 2* 2* triangle ( produces a triangle wave)
( approximation to the cosine of that angle.)

( block 1396 )
( fractional multiply)
: *. ( 0xb7 ) ( f1 f2 - f1 f1*f2) *.17
     a 2* -if drop - 2* - ;  then
     drop 2* ;

( block 1397 )

: *. ( multiplies a fraction by a fraction,)
( giving a fraction, or an integer by a)
( fraction, giving an integer. note that f1)
( is left in s to be ignored, dropped, or)
( reused.)

( 16 bit fractions --- si. ffff ffff ffff ffff)

( block 1398 )
( divide)
+cy ( 0x2d3 ) ( enter ea mode)
: clc dup dup or dup . + drop ;
: --u/mod ( 0x2d5 ) clc
: -u/mod ( hld-rq) ( 0x2d6 ) a! 17 push begin begin
     dup . + . push dup . +
     dup a . + -if
     drop pop *next dup . + ;  then
     over or or . pop next dup . + ;
-cy ( 0xe1 ) ( exit ea mode)

( block 1399 )

: clc ( clears the carry bit for addition in)
( ea mode.)

( the following defines u/mod in ram ...)

: u/mod ( hld-rq) - 1 . + --u/mod ;

( if the divisor is a constant, just negate)
( it at edit or compile time.)

( block 1400 )
( f18 compiler) :var h [0xd] :var ip [0xc] :var slot [0x4] :var call? :var cal [0x102f9621] :var com [0x2] macro 
: !7 0xbd0489 3, 0xfffffffc , [compile] drop ;
: 2*s ?lit 0xe0c1 2, 1, ;
: call ( nn) [compile] ?dup 0xb8 1, , 0xe9 1,  cal  @ here 3 + - + , ; forth 
: swap swap ;
: eras ( nn) push 0x61fc ( call a9) swap block pop ( blks) fill ;
: node's ( -n)  com  @ 2* 0x8000 + ;
: memory ( n-a)  0x240 -  and node's block + ;
0x8000 nnc 2 * blks eras 
: -org ( n) dup  h  !  ip  ! 0  call?  !
: break 4  slot  ! ;
: p, ( n)  h  @ memory !  h  @ 1 over + over or 0x7f and or  h  ! ;
: s4  h  @  ip  ! 13 2*s dup  call?  ! p, 1  slot  ! ;
: s0 13 2*s
: sn dup  call?  !  ip  @ memory +! 1  slot  +! ;
: s1 8 2*s sn ;
: s2 3 2*s sn ;
: s3 dup 3 and drop if 7 sn s4 ;  then 4 / sn ;
: i,  slot  @ jump s0 s1 s2 s3 s4

( block 1401 )
( f18 target compiler) includes support for f18a addressing see 1404 
: h ( address of next available word in target memory here)
: ip ( address of current instruction word)
: slot ( next available instruction slot)
: call? ( was last instruction a call ?)
: call a ( compile a call)
: eras ( fills f18 memory with call 155 number)
: 2*s n ( shift left n bits)
: node's ( target node's starting memory block no.)
: memory n-a ( host address for target memory) :: -org n ( set current target memory location, see) ( next block for true directive.) :: break ( break in emulator only) :: p, n ( compile pattern into target memory) :: s0-s4 ( assemble opcode into slot 0-3) :: i, ( assemble opcode into next slot *note** simple code jump table using)  jump

( block 1402 )
( target)
: cnt 2/ -1 + ;
: defer ( -b) pop ;
: execute ( b) push ;
: f! ( bn)  sp  + ! ;
: f@ ( n-b)  sp  + @ ;
: class ( b)  last 1 +  ! ;
: empty empt :: host 0 class  6 f@  nop  4 f@  nop  13 f@  nop :: functions ( bbb) 13 f! 4 f! 6 f! ; :: . 0x1c i, ; ( nop) :: hhere here ; :: ..  slot  @ 4 or drop if . .. ;  then 0  call?  ! ; :: here ..  h  @ 0x3ff and ; hhere  :: report ( here)  h  @  slot  @ 3 and 1024 * or 32 *  13 16 +  + !7 ; :: org ( n) .. -org ; :: f18 ( b) 1 f@  0 +  functions ; :: +cy here 0x200 over - and or org ; :: -cy here  0x200 -  and org ; :: await  com  @ idle  cal  @ execute ;

( block 1403 )

: defer -a ( byte address of the compiled code that follows -- used for forward referencing)
: execute a ( code at this address)
: f! an ( store address of code executed when a word with this function is interpreted)
: f@ n-a ( fetch address of function code)
: class a ( store address of code to be executed for each word subsequently defined)
: empty ( redefine empty to restore altered functions) :: host ( change context back to colorforth) :: functions aa ( store functions in kernel specific way) :: c18 ( save green word and number functions. set green short-number to n, compile to call. target words are executed to assemble instructions) :: . ( nop used to fill instruction words) :: .. ( fills rest of word with nops) :: here -a ( starts new instruction word. leaves target address as number) :: org ( sets compilation address safely.) :: await ( generates call to node's idle ports.)

( block 1404 )
( f18 jump instructions)
: 9same ( axa-ax) push over pop - or  0x200  and drop ;
: j3 .
: j0 i,  ip  @ memory +! break ;
: j1  h  @ 9same if over 0x100 and drop if swap 0xff and swap j0 ;  then then . . j3 ;
: j2 over 0x155 or  h  @ or 0x3f8 and drop if . j3 ;  then swap 7 and swap j0 ;
: -adr ( an) swap 0x155 or swap  slot  @ jump j0 j1 j2 j3 j0
: adr ( n-n)  slot  @ 3 or drop if i,  ip  @ 8 *  h  @  ip  @ negate + + 8 *  slot  @ + break ;  then . adr ;
: @h ( n-a) 8 /mod + ;
: -rng -range abort ;
: f3 ( an) over 0x155 or over @h or 0x2f8 and drop if -rng ;  then swap 7 and swap 8 / memory +! ;
: f2 dup @h 9same if over 0x100 and drop if swap 0xff and swap
: f1 8 / memory +! ;  then then -rng ;
: then ( n) here 0x155 or swap 8 /mod swap jump f1 f1 f2 f3

( block 1405 )
the f18a uses adr bit 9 for mode; 8 for i/o; 7 for rom. incrementer maintains bits 0-6, rest are left alone except for return and slot 0 jumps.


: 9same ( is true if the two addresses match in bit 9 - the extended arithmetic mode bit.)
: -adr an ( assembles jump to known address)
: adr n-a ( assembles forward jump in slot 0,1,2. value left on stack is instr addr * 64 + here-ip + slot.)
: @h ( given that vlue value / 8 returns p at time the jump executes.)
: then a ( insert address for forward jump)

( block 1406 )
( complex instructions)
: def defer here [compile] call ;
: call defer ( a) 3 -adr ; call cal ! 
: ;  call?  @ dup 0x6000 or drop if dup 0x300 or drop if dup 0x18 or drop if 0 and i, break ;  then then then dup 2/ and negate  ip  @ memory +! ;
: -if ( -a) 7 adr ;
: if ( -a) 6 adr ;
: -until ( a) 7 -adr ;
: until ( a) 6 -adr ;
: -while ( a-aa) 7 adr swap ;
: while ( a-aa) 6 adr swap ;
: zif ( -a) 5 adr ;
: *next ( aa-a) swap
: next ( a) 5 -adr ;
: unext ( a) 4 i, drop ;
: n defer 8 f@ execute
: lit 8 i, 0x3ffff and ( ok in slot 3)
: , ( n) 0x15555 or p, ;
: for 0x1d i,
: begin here ;
: ahead ( -a) 2 adr ;
: end ( a) 2 -adr ;
: leap ( -a) 3 adr ;

( block 1407 )

: def -a ( deferred to class. executed for every target definition to compile host code that compiles target call)
: call a ( compile target call)
: ; ( will be executed as a target word. the pentium macro has precedence while compiling)
: if/-if ( leaves address of jump on stack)
: -until a ( jump if positive to) begin
: zif ( forward) next ( decrements r and jumps if r! else pops and falls thru)
: next/for
: n ( executed for green short-numbers. all 18-bit target numbers are short. executes white short-number to put interpreted number on stack. then assembles literal instruction with number in next location. inverted for rom)
: , n ( compile number into target memory)
: ?lit -n ( retrieve previously compiled number)
: begin -a ( starts new instruction word. leaves properly formatted target address)
: ahead ( compiles fwd ref jump resolve w/then)
: leap ( like ahead but compiles a call)

( block 1408 )
( instructions)
: target n f18 def class ;
: ex : ;' 1 i, break ;
: rx
: @p : @p+ 8 i, ;
: @+ 9 i, ;
: @b 0xa i, ;
: @ 0xb i, ;
: !p : !p+ 0xc i, ;
: !+ 0xd i, ;
: !b 0xe i, ;
: ! 0xf i, ;

( block 1409 )
( words being redefined for the target computer. these host words can no longer be executed. although pentium macros take precedence during compilation, they will no longer be used.)
: f18 ( instructions)
: 0 ( ;) ....8 ( @p) .10 ( +*) ..18 ( dup)
: 1 ( ex) ...9 ( @+) .11 ( 2*) ..19 ( pop)
: 2 ( j) ....a ( @b) .12 ( 2/) ..1a ( over)
: 3 ( call) .b ( @) ..13 ( -) ...1b ( a)
: 4 ( unext) c ( !p) .14 ( +) ...1c ( .)
: 5 ( next) .d ( !+) .15 ( and) .1d ( push)
: 6 ( if) ...e ( !b) .16 ( or) ..1e ( b!)
: 7 ( -if) ..f ( !) ..17 ( drop) 1f ( a!)

( block 1410 )
( port literals and constants)
: right ( .)  0x1d5  lit ; ( 0101111111 register bits)
: down ( ..)  0x115  lit ; ( 0110111111)
: left ( ..)  0x175  lit ; ( 0111011111)
: up ( ....)  0x145  lit ; ( 0111101111)
: io ( ....) 0x15d lit ; ( 0111110111)
: ldata ( .) 0x171 lit ; ( 0111011011)
: data ( ..) 0x141 lit ; ( 0111101011 port calls)
: warp ( ..)  0x157  lit ; ( 0111111101)
: center 0x1a5 lit ;
: top 0x1b5 lit ;
: side 0x185 lit ;
: corner 0x195 lit ;
: /mod /mod ;
: spispeed 497 ( 0) lit ; 0x0 ( 24-bit adrs) 4 * 262144 /mod ( al ah) 0x3 ( read cmd) 256 * + 4 * 
: spicmd ( c.ah)  0 +  lit ;
: spiadr ( al)  0 +  lit ;

( block 1411 )


( block 1412 )
( more instructions)
: +* 0x10 i, ; ( slot 3 ok)
: 2* 0x11 i, ;
: 2/ 0x12 i, ;
: - 0x13 i, ;
: + 0x14 i, ; ( slot 3 ok)
: and 0x15 i, ;
: or 0x16 i, ; ( exclusive-or)
: drop 0x17 i, ;
: dup 0x18 i, ; ( slot 3 ok)
: pop 0x19 i, ;
: over 0x1a i, ;
: a 0x1b i, ;
: push 0x1d i, ;
: b! 0x1e i, ;
: a! 0x1f i, ;

( block 1413 )

: o ( replaces top-of-stack with 0. f18 instructions can't be used in macros - forth macros take precedence)

( block 1414 )


( block 1415 )


( block 1416 )


( block 1417 )


( block 1418 )
( math rom anywhere) 0 kind

org 0xa1
( 0xa1 ) 1388 load ( relay)
( 0xa9 ) : warm await ;

org 0xb0
( 0xb0 ) 1390 load ( multiply)
( 0xb7 ) 1396 load ( fractional multiply)
( 0xbc ) 1386 load ( taps)
( 0xc4 ) 1384 load ( interpolate)
( 0xce ) 1394 load ( triangle)
( 0xd3 ) 1398 load ( -u/mod)

org 0xaa
( 0xaa ) 1382 load ( polynomial approximation)
( 0xb0 )

( block 1419 )


( block 1420 )
( serdes boot top/bot) 6 kind 0xaa reset

org 0xa1
( 0xa1 ) 1388 load ( relay)
( 0xa9 ) : warm await ;

: cold ( 0xaa ) 0x3141 a! 0x3fffe dup ! rdlu cold ;

( 0xb0 ) 1390 load ( multiply)
( 0xb7 ) 1396 load ( fractional multiply)
( 0xbc ) 1386 load ( taps)
( 0xc4 ) 1384 load ( interpolate)
( 0xce ) 1394 load ( triangle)
( 0xd3 ) 1398 load ( -u/mod)
( 0xe1 )

( block 1421 )


( block 1422 )
( sync serial boot side) 2 kind 0xaa reset
( 0xbf ) org 0xbe : sget
 org 0xa1
( 0xa1 ) 1388 load ( relay)
( 0xa9 ) : warm await ;

: cold ( 0xaa ) 0x31a5 a! @ @b . . -if ( 0pin)
0x3fd85 ( 'rd-u 3fc00 +) dup push dup begin
drop @b . -if ( /pin) *next  swap  then
0x185 ( 'rd-u) push drop push ;  then
: ser-exec ( 0xb6 ) ( x-x) sget push sget a! sget
: ser-copy ( 0xb9 ) push zif ;  then
begin sget ( push sget pop !+) !+ next ;
: sget ( 0xbe ) ( -4/3-w) dup leap leap
: 6in ( 0xc0 ) then then leap leap
: 2in ( 0xc2 ) then then 2* 2* dup begin
. drop @b . - -until - 2 and dup begin
. drop @b . . -until 2 and 2/ or or ;

( 0xcc ) 1390 load ( multiply)
( 0xd3 ) 1386 load ( taps)
( 0xdb ) 1394 load ( triangle)
( 0xe0 )

( block 1423 )
( sync serial boot side)


: ser-exec ( reads and processes a boot frame.)
: ser-copy ( receives)  n ( words at a, nop if n zero.)

: sget ( receives) ( 18 ) ( bits, first bit on falling clock edge, second bit on rising, and so on. ends with clock line high. data line must be stable by the time clock edge is seen. spins the whole time, no suspension.)

( block 1424 )
( async serial boot top/bot) 1 kind 0xaa reset
( 0xcf ) org 0xcb : 18ibits
 org 0xa1
( 0xa1 ) 1388 load ( relay)
( 0xa9 ) : warm await ;
: cold ( 0xaa ) 0x31a5 ( 'rdlu) a! @ @b .. -if
: ser-exec ( 0xae ) ( x-d) 18ibits drop push .
18ibits drop a! . 18ibits
: ser-copy ( 0xb3 ) ( xnx-d) drop push zif ;
 then begin 18ibits drop !+ next ;
 then drop 0x1b5 ( 'rdl-) push push ;
: wait ( 0xbb ) ( x-1/1) begin . drop @b -until . drop ;
: sync ( 0xbe ) ( x-3/2-d) dup dup wait or - push
begin @b . -if . drop *next await ;
 then . drop pop - 2/ ;
: start ( 0xc5 ) ( dw-4/2-dw,io)
dup wait over dup 2/ . + push
: delay ( 0xc8 ) ( -1/1-io)
begin @b . -if then . drop next @b ;

( 0xcb ) 1426 load ( 18ibits)
( 0xd9 ) 1392 load ( lsh rsh)
( 0xdd )

( block 1425 )
( async serial boot.)

: cold ( reads) ( 4 ) ( ports, falls thru if pin high. else assumes a focusing call received, simulates its execution as though from warm.)


: ser-exec ( reads and processes a boot frame.)
: ser-copy ( receives)  n ( words at a, nop if n zero.)

: delay ( waits one bit time and samples io. enter via jump with)  d ( in r.)
: wait ( waits for input pin to be high.)
: start ( waits for rising edge of a normally start bit, delays 1.5 bit times and samples io.)


: sync ( waits for rising edge then measures high time, designed to be) ( 2 ) ( bit-time start, followed by falling edge. returns)  d ( for) ( 1 ) ( bit time. times out after approx) ( 3 ) ( ms, going warm.)

( block 1426 )
( more async serial)
: 18ibits ( 0xcb ) ( x-4/6-dwx)
     sync sync dup start leap ( 2bits) leap
: byte ( 0xd0 ) then drop start leap
: 4bits ( 0xd2 ) then leap
: 2bits ( 0xd3 ) then then leap
: 1bit ( 0xd4 ) ( nw,io-nw,io) then
     push 2/ pop over or
     0x20000 and or over push delay ;
( 0xd9 )

( block 1427 )


( block 1428 )
( spi boot top/bot) 4 kind 0xaa reset host  :: ---  0x2a  lit ; ( do, ce-, clk) :: --+  0x2b  lit ; :: +--  0x3a  lit ; :: +-+  0x3b  lit ; :: -++  0x2f  lit ; target
org 0xa1 1388 load ( relay)

org 0xc2 
: 8obits ( dw-dw') 7 for leap ( obit) 2* *next ;
: ibit ( 0xc7 ) ( dw-dw')
     @b . -if drop - 2* ;  then drop 2* - ;
: half ( 0xca ) ( dwc-dw) !b over for . . unext ;
: select ( 0xcc ) ( dw-dw) -++ half --+ half ;
: obit ( 0xd0 ) ( dw-dw) then
     -if +-- half +-+ half ;  then
: rbit ( 0xd5 ) ( dw-dw) --- half --+ half ;
: 18ibits ( 0xd9 ) ( d-dw) dup 17 ( for) push
: ibits begin rbit ibit - next ;

: u2/ 2/ 0x1ffff and ; ( 0xe1 )
org 0xa9
( 0xa9 ) : warm await ;
( 0xaa ) 1430 load ( the rest)
( 0xc1 )

( block 1429 )
( clock management is mode 3, high when idle.)
: ibits ( is entered by jump with count already on return stack. no rom effect to adding this.)

( block 1430 )
( more spi)
: cold ( 0xaa ) @b - ..  0x1b5 ( 'rdl-)  -until
     spispeed spiadr push spicmd
: spi-boot ( 0xb0 ) ( dly adrh . adrl - dly x)
     select 8obits 8obits
     drop pop . 8obits 8obits
: spi-exec ( 0xb6 ) ( dx-dx) drop 18ibits
     0x1e000 . +  0x1b5 ( 'rdl-)  -until
     push 18ibits a! 18ibits
: spi-copy ( 0xbc ) ( dn-dx) push zif ;  then begin
     18ibits ( push 18ibits pop !+) !+ next dup ; ( 0xc1 ) ( was) ( 0xc2 )

( block 1431 )
( more spi)

( spi-copy reads one word per loop and the loop counter is the actual number of words being)
( sent ie a count of zero means no words sent)

( block 1432 )
( analog) 0 kind

org 0xa1
( 0xa1 ) 1388 load ( relay)
( 0xa9 ) : warm await ;

org 0xb0
( 0xb0 ) 1390 load ( multiply)
( 0xb7 ) 1396 load ( fractional multiply)
( 0xbc ) 1434 load ( -dac)
( 0xc4 ) 1384 load ( interpolate)
( 0xce ) 1394 load ( triangle)
( 0xd3 ) 1398 load ( -u/mod)

org 0xaa
( 0xaa ) 1382 load ( polynomial approximation)
( 0xb0 )

( block 1433 )


( block 1434 )
( dac)
: -dac ( legacy entry name below)
: dac27 ( 0xbc ) ( mcpaw-mcp) dup push push
     over pop - . + push push 0x155
     pop over or a
     begin unext !b .
     begin unext !b !b ;

( block 1435 )


( block 1436 )
( 1-wire) 3 kind org 0xaa

org 0x9e 
: rcv ( s-sn) ( 0x9e ) a push dup dup a! 17 for begin
: bit ( 0xa1 ) @ drop @b -if
     drop - 2* - *next pop a! ;  then
     drop 2* next pop a! ; ( 0xa8 )

org 0xa9 
: warm ( 0xa9 ) await ;
: cold ( 0xaa ) left center a! . io b!
     dup dup 0xb7 ( rest) dup push push 16 push
     @ drop @b  0x185 ( side)  -until
     drop a! . bit ; ( 0xb7 ) ( rest)
      push rcv a! rcv push zif ;  then
     begin rcv !+ next ; ( 0xbe )

( 0xbe ) 1394 load ( triangle) ( 5 )
( 0xc3 ) 1390 load ( multiply *.17) ( 7 )
( 0xca ) 1396 load ( fractional multiply *.) ( 5 )
( 0xcf ) ( 1384 ) ( load interpolate interp) ( 10 )
( 0xcf ) 1398 load ( -u/mod) ( 14 )
( 0xde ) ( equals) ( 0x9e )

( block 1437 )


( block 1438 )
( null rom anywhere) 0 kind

org 0xa9

: warm ( 0xa9 ) await ;

( block 1439 )
( default code for null rom, or for special rom to be loaded out of sequence.)


: warm ( is assumed by crawlers, and is also the destination of the call instruction that rom is initialized with.)  avoid clobbering this word since steven's test code will not work in its absence.

